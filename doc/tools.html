<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>coa.tools API documentation</title>
<meta name="description" content="Project : PyCoA - Copyright ©pycoa.fr
Date :
april 2020 - march 2022
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coa.tools</code></h1>
</header>
<section id="section-intro">
<p>Project : PyCoA - Copyright ©pycoa.fr
Date :
april 2020 - march 2022
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint LICENSE file</p>
<p>Module : coa.tools</p>
<h2 id="about">About</h2>
<p>This is the PyCoA tools module to be considered as a swiss knife list of functions.
One find function for
- verbose or warning mode management.
- kwargs analysis
- filling nan values of given pandas
- date parsing validation
- automatic file caching system</p>
<p>The _verbose_mode variable should be set to 0 if no printing output needed. The
default value is 1 (print information to stdout). The 2 value grants a debug level information
printing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;Project : PyCoA - Copyright ©pycoa.fr
Date :    april 2020 - march 2022
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint LICENSE file

Module : coa.tools

About
-----
This is the PyCoA tools module to be considered as a swiss knife list of functions.
One find function for
 - verbose or warning mode management.
 - kwargs analysis
 - filling nan values of given pandas
 - date parsing validation
 - automatic file caching system

The _verbose_mode variable should be set to 0 if no printing output needed. The
default value is 1 (print information to stdout). The 2 value grants a debug level information
printing.
&#34;&#34;&#34;

import pandas as pd
import numpy
import datetime
import time
import os.path
import requests
from tempfile import gettempdir
from getpass import getuser
from zlib import crc32
from urllib.parse import urlparse
import unidecode

from coa.error import CoaKeyError, CoaTypeError, CoaConnectionError, CoaNotManagedError

# testing if coadata is available
import importlib
_coacache_folder=&#39;&#39;
_coacache_module_info = importlib.util.find_spec(&#34;coacache&#34;)
if _coacache_module_info != None:
    _coacache_folder = _coacache_module_info.submodule_search_locations[0]

# Verbosity of pycoa
_verbose_mode = 1 # default

# Known db
_db_list_dict = {&#39;jhu&#39;: [&#39;WW&#39;,&#39;nation&#39;,&#39;World&#39;],
    &#39;owid&#39;: [&#39;WW&#39;,&#39;nation&#39;,&#39;World&#39;],
    &#39;jhu-usa&#39;: [&#39;USA&#39;,&#39;subregion&#39;,&#39;United States of America&#39;],
    &#39;spf&#39;: [&#39;FRA&#39;,&#39;subregion&#39;,&#39;France&#39;],
    &#39;spfnational&#39;: [&#39;FRA&#39;,&#39;nation&#39;,&#39;France&#39;],
    &#39;opencovid19&#39;: [&#39;FRA&#39;,&#39;subregion&#39;,&#39;France&#39;],
    &#39;opencovid19national&#39;: [&#39;WW&#39;,&#39;nation&#39;,&#39;France&#39;],
    &#39;dpc&#39;: [&#39;ITA&#39;,&#39;region&#39;,&#39;Italy&#39;],
    &#39;covidtracking&#39;: [&#39;USA&#39;,&#39;subregion&#39;,&#39;United States of America&#39;],
    &#39;covid19india&#39;: [&#39;IND&#39;,&#39;region&#39;,&#39;India&#39;],
    &#39;rki&#39;:[&#39;DEU&#39;,&#39;subregion&#39;,&#39;Germany&#39;],
    &#39;escovid19data&#39;:[&#39;ESP&#39;,&#39;subregion&#39;,&#39;Spain&#39;],
    &#39;phe&#39;:[&#39;GBR&#39;,&#39;subregion&#39;,&#39;United Kingdom&#39;],
    &#39;sciensano&#39;:[&#39;BEL&#39;,&#39;region&#39;,&#39;Belgium&#39;],
    &#39;dgs&#39;:[&#39;PRT&#39;,&#39;region&#39;,&#39;Portugal&#39;],
    &#39;obepine&#39;:[&#39;FRA&#39;,&#39;region&#39;,&#39;France&#39;],
    &#39;moh&#39;:[&#39;MYS&#39;,&#39;subregion&#39;,&#39;Malaysia&#39;],
    &#39;risklayer&#39;:[&#39;EUR&#39;,&#39;subregion&#39;,&#39;Europe&#39;],
    &#39;imed&#39;:[&#39;GRC&#39;,&#39;region&#39;,&#39;Greece&#39;],
    &#39;govcy&#39;:[&#39;CYP&#39;,&#39;nation&#39;,&#39;Cyprus&#39;],
    &#39;insee&#39;:[&#39;FRA&#39;,&#39;subregion&#39;,&#39;France&#39;],
    &#39;europa&#39;:[&#39;EUR&#39;,&#39;subregion&#39;,&#39;Europe&#39;],
    #&#39;minciencia&#39;:[&#39;CHL&#39;,&#39;subregion&#39;,&#39;Chile&#39;]
    }

# ----------------------------------------------------
# --- Usefull functions for pycoa --------------------
# ----------------------------------------------------

def get_db_list_dict():
    &#34;&#34;&#34;Return db list dict&#34;&#34;&#34;
    return _db_list_dict


def get_verbose_mode():
    &#34;&#34;&#34;Return the verbose mode
    &#34;&#34;&#34;
    return _verbose_mode

def set_verbose_mode(v):
    &#34;&#34;&#34;Set the verbose mode
    &#34;&#34;&#34;
    global _verbose_mode
    _verbose_mode=v
    return get_verbose_mode()

def info(*args):
    &#34;&#34;&#34;Print to stdout with similar args as the builtin print function,
    if _verbose_mode &gt; 0
    &#34;&#34;&#34;
    if _verbose_mode &gt; 0:
        print(*args)

def verb(*args):
    &#34;&#34;&#34;Print to stdout with similar args as the builtin print function,
    if _verbose_mode &gt; 1
    &#34;&#34;&#34;
    if _verbose_mode &gt; 1:
        print(*args)

def kwargs_test(given_args, expected_args, error_string):
    &#34;&#34;&#34;Test that the list of kwargs is compatible with expected args. If not
    it raises a CoaKeyError with error_string.
    &#34;&#34;&#34;

    if type(given_args)!=dict:
        raise CoaKeyError(&#34;kwargs_test error, the given args are not a dict type.&#34;)
    if type(expected_args)!=list:
        raise CoaKeyError(&#34;kwargs_test error, the expected args are not a list type&#34;)

    bad_kwargs=[a for a in list(given_args.keys()) if a not in expected_args ]
    if len(bad_kwargs) != 0 :
        raise CoaKeyError(error_string+&#39; Unrecognized args are &#39;+str(bad_kwargs)+&#39;.&#39;)

    return True

def tostdstring(s):
    &#34;&#34;&#34;Standardization of string for country,region or subregion tests
    &#34;&#34;&#34;
    return unidecode.unidecode(&#39; &#39;.join(s.replace(&#39;-&#39;,&#39; &#39;).split())).upper()

def fill_missing_dates(p, date_field=&#39;date&#39;, loc_field=&#39;location&#39;, d1=None, d2=None):
    &#34;&#34;&#34;Filling the input pandas dataframe p with missing dates
    &#34;&#34;&#34;
    if not isinstance(p, pd.DataFrame):
        raise CoaTypeError(&#34;Expecting input p as a pandas dataframe.&#34;)
    if not date_field in p.columns:
        raise CoaKeyError(&#34;The date_field is not a proper column of input pandas dataframe.&#34;)
    if not loc_field in p.columns:
        raise CoaKeyError(&#34;The loc_field is not a proper column of input pandas dataframe.&#34;)
    # datatoilettage :)
    p = p.loc[~p[loc_field].isin([&#39;&#39;])]

    if d2==None:
        d2=p[date_field].max()
    if d1==None:
        d1=p[date_field].min()

    if not all(isinstance(d, datetime.date) for d in [d1,d2]):
        raise CoaTypeError(&#34;Waiting for dates as datetime.date.&#34;)
    if d1 &gt; d2:
        raise CoaKeyError(&#34;Dates should be ordered as d1&lt;d2.&#34;)

    idx = pd.date_range(d1, d2, freq = &#34;D&#34;)
    idx = idx.date

    all_loc=list(p[loc_field].unique())
    pfill=pd.DataFrame()
    for l in all_loc:
        pp=p.loc[p[loc_field]==l]
        pp2=pp.set_index([date_field])
        pp2.index = pd.DatetimeIndex(pp2.index)
        pp3 = pp2.reindex(idx,fill_value=numpy.nan)#pandas.NA)
        pp3[loc_field] = pp3[loc_field].fillna(l)  #pp3[&#39;location&#39;].fillna(method=&#39;bfill&#39;)
        #pp3[&#39;codelocation&#39;] = pp3[&#39;codelocation&#39;].fillna(method=&#39;bfill&#39;)
        #pp3[&#39;codelocation&#39;] = pp3[&#39;codelocation&#39;].fillna(method=&#39;ffill&#39;)
        pfill=pd.concat([pfill, pp3])
    pfill.reset_index(inplace=True)
    return pfill


def check_valid_date(date):
    &#34;&#34;&#34;Check if a string is compatible with a valid date under the format day/month/year
    with 2 digits for day, 2 digits for month and 4 digits for year.
    &#34;&#34;&#34;
    raise_error=False
    if type(date) != type(str()):
        raise CoaTypeError(&#39;Expecting date given as string.&#39;)

    d=date.split(&#39;/&#39;)
    if len(d)!=3:
        raise_error=True
    else:
        if len(d[0])!=2 or len(d[1])!=2 or len(d[2])!=4:
            raise_error=True
        else:
            try:
                year=int(d[2])
                month=int(d[1])
                day=int(d[0])
            except ValueError:
                raise_error=True

    if raise_error:
        raise CoaTypeError(&#34;Not a valid date should be : day/month/year, with 2 digits &#34; \
            &#34;for month or day, 4 digits for year.&#34;)

    try:
        return datetime.date(int(year),int(month),int(day))
    except ValueError:
        raise CoaTypeError(&#34;Check consistancy of the given date. e.g. the day (btw 1 and 31), &#34; \
            &#34;the month (btw 1 and 12) and the year value.&#34;)

def extract_dates(when):
    &#34;&#34;&#34;Expecting None or 1 or 2 dates separated by :. The format is a string.
    If 2 dates are given, they must be ordered.
    When 1 date is given, assume that&#39;s the latest which is given.
    When None date is give, the oldest date is 01/01/0001, the newest is now.

    It returns 2 datetime object. If nothing given, the oldest date is 01/01/0001,
    &#34;&#34;&#34;
    #w0=datetime.datetime(1,1,1) # minimal year is 1
    #w1=datetime.datetime.now()
    w0=datetime.date(1,1,1) # minimal year is 1
    w1=datetime.date.today()
    if when:  # when input is not None, assume min and max date
        if type(when) != type(str()):
            raise CoaTypeError(&#34;Date expected as string.&#34;)
        w=when.split(&#39;:&#39;)

        if len(w)&gt;2 :
            raise CoaTypeError(&#34;Too many dates given. Expecting 1 or 2 with : as a separator. &#34;)
        if len(w) == 1:
            w1=check_valid_date(w[0])
        if len(w) &gt; 1:
            if w[1] != &#39;&#39;:
                w1=check_valid_date(w[1])
            if w[0] != &#39;&#39;:
                w0=check_valid_date(w[0])

        if w0&gt;w1:
            raise CoaTypeError(&#34;First date must occur before the second one.&#34;)

    return w0,w1

def week_to_date(whenstr):
    &#34;&#34;&#34;
    convert week to date.
    2 cases:
    - Rolling week
        if format is Y-M-D-Y-M-D: return middle dates
    - One week data Wnumber: return monday correction to the week number
    &#34;&#34;&#34;
    convertion = 0
    if len(whenstr) == 21:
        firstday = datetime.date(int(whenstr.split(&#39;-&#39;)[0]),int(whenstr.split(&#39;-&#39;)[1]),int(whenstr.split(&#39;-&#39;)[2]))
        lastday  = datetime.date(int(whenstr.split(&#39;-&#39;)[3]),int(whenstr.split(&#39;-&#39;)[4]),int(whenstr.split(&#39;-&#39;)[5]))
        convertion = firstday + (lastday - firstday)/2
    elif len(whenstr) == 10:
        firstday = datetime.date(int(whenstr.split(&#39;-&#39;)[0]),int(whenstr.split(&#39;-&#39;)[1]),int(whenstr.split(&#39;-&#39;)[2]))
        convertion = firstday+datetime.timedelta(days=3)
    else:
        convertion = datetime.datetime.strptime(whenstr  + &#39;-1&#39; , &#34;%G-S%V-%u&#34;)
    return convertion

def get_local_from_url(url,expiration_time=0,suffix=&#39;&#39;):
    &#34;&#34;&#34;&#34;Download data from the given url and store it into a local file.

    If the expiration time is 0 (default), the data will never be downloaded anymore if available.
    If the expiration time is &lt; 0, it forces to download the file.
    If the expiration time (in seconds) is lower than time difference between now and last modification
    time of the file, the file is downloaded.

    One may add a suffix to the local filename if known.
    &#34;&#34;&#34;

    tmpdir=os.path.join(gettempdir(),&#34;pycoa_data&#34;+&#34;_&#34;+getuser())
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)

    local_base_filename=urlparse(url).netloc+&#34;_&#34;+str(crc32(bytes(url,&#39;utf-8&#39;)))+suffix
    local_tmp_filename=os.path.join(tmpdir,local_base_filename)

    local_file_exists=False

    if _coacache_folder != &#39;&#39;:
        local_cached_filename=os.path.join(_coacache_folder,local_base_filename)
        local_file_exists=os.path.exists(local_cached_filename)
        local_filename=local_cached_filename

    if os.path.exists(local_tmp_filename):
        if local_file_exists: # prefering the file in tmp if more recent
            if os.path.getmtime(local_tmp_filename) &gt; os.path.getmtime(local_filename):
                local_filename = local_tmp_filename
        else:
            local_file_exists=True
            local_filename=local_tmp_filename

    if expiration_time &gt;=0 and local_file_exists:
        if expiration_time==0 or time.time()-os.path.getmtime(local_filename)&lt;expiration_time:
            verb(&#39;Using locally stored data for &#39;+url+&#39; stored as &#39;+local_filename)
            return local_filename

    # if not : download the file in tmp area
    local_filename=local_tmp_filename
    try:
        headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#39;}
        urlfile = requests.get(url, allow_redirects=True,headers=headers) # adding headers for server which does not accept no browser presentation
        fp=open(local_filename,&#39;wb&#39;)
        fp.write(urlfile.content)
        fp.close()
        verb(&#39;Download content of &#39;+url+&#39; . Locally stored as cached data in &#39;+local_filename)
    except requests.exceptions.RequestException :
        if local_file_exists and expiration_time &gt;=0 :
            info(&#39;Cannot access to &#39;+url+&#39; . Will use locally stored cached version.&#39;)
            pass
        else:
            raise CoaConnectionError(&#39;Cannot access to the url &#39;+\
                url+&#39; . Please check your internet connection or url path.&#39;)
    except Exception as e2:
        raise CoaNotManagedError(type(e2).__name__+&#34; : &#34;+str(e2))

    return local_filename

class dotdict(dict):
    &#34;&#34;&#34;dot.notation access to dictionary attributes&#34;&#34;&#34;
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coa.tools.check_valid_date"><code class="name flex">
<span>def <span class="ident">check_valid_date</span></span>(<span>date)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a string is compatible with a valid date under the format day/month/year
with 2 digits for day, 2 digits for month and 4 digits for year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_valid_date(date):
    &#34;&#34;&#34;Check if a string is compatible with a valid date under the format day/month/year
    with 2 digits for day, 2 digits for month and 4 digits for year.
    &#34;&#34;&#34;
    raise_error=False
    if type(date) != type(str()):
        raise CoaTypeError(&#39;Expecting date given as string.&#39;)

    d=date.split(&#39;/&#39;)
    if len(d)!=3:
        raise_error=True
    else:
        if len(d[0])!=2 or len(d[1])!=2 or len(d[2])!=4:
            raise_error=True
        else:
            try:
                year=int(d[2])
                month=int(d[1])
                day=int(d[0])
            except ValueError:
                raise_error=True

    if raise_error:
        raise CoaTypeError(&#34;Not a valid date should be : day/month/year, with 2 digits &#34; \
            &#34;for month or day, 4 digits for year.&#34;)

    try:
        return datetime.date(int(year),int(month),int(day))
    except ValueError:
        raise CoaTypeError(&#34;Check consistancy of the given date. e.g. the day (btw 1 and 31), &#34; \
            &#34;the month (btw 1 and 12) and the year value.&#34;)</code></pre>
</details>
</dd>
<dt id="coa.tools.extract_dates"><code class="name flex">
<span>def <span class="ident">extract_dates</span></span>(<span>when)</span>
</code></dt>
<dd>
<div class="desc"><p>Expecting None or 1 or 2 dates separated by :. The format is a string.
If 2 dates are given, they must be ordered.
When 1 date is given, assume that's the latest which is given.
When None date is give, the oldest date is 01/01/0001, the newest is now.</p>
<p>It returns 2 datetime object. If nothing given, the oldest date is 01/01/0001,</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_dates(when):
    &#34;&#34;&#34;Expecting None or 1 or 2 dates separated by :. The format is a string.
    If 2 dates are given, they must be ordered.
    When 1 date is given, assume that&#39;s the latest which is given.
    When None date is give, the oldest date is 01/01/0001, the newest is now.

    It returns 2 datetime object. If nothing given, the oldest date is 01/01/0001,
    &#34;&#34;&#34;
    #w0=datetime.datetime(1,1,1) # minimal year is 1
    #w1=datetime.datetime.now()
    w0=datetime.date(1,1,1) # minimal year is 1
    w1=datetime.date.today()
    if when:  # when input is not None, assume min and max date
        if type(when) != type(str()):
            raise CoaTypeError(&#34;Date expected as string.&#34;)
        w=when.split(&#39;:&#39;)

        if len(w)&gt;2 :
            raise CoaTypeError(&#34;Too many dates given. Expecting 1 or 2 with : as a separator. &#34;)
        if len(w) == 1:
            w1=check_valid_date(w[0])
        if len(w) &gt; 1:
            if w[1] != &#39;&#39;:
                w1=check_valid_date(w[1])
            if w[0] != &#39;&#39;:
                w0=check_valid_date(w[0])

        if w0&gt;w1:
            raise CoaTypeError(&#34;First date must occur before the second one.&#34;)

    return w0,w1</code></pre>
</details>
</dd>
<dt id="coa.tools.fill_missing_dates"><code class="name flex">
<span>def <span class="ident">fill_missing_dates</span></span>(<span>p, date_field='date', loc_field='location', d1=None, d2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filling the input pandas dataframe p with missing dates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_missing_dates(p, date_field=&#39;date&#39;, loc_field=&#39;location&#39;, d1=None, d2=None):
    &#34;&#34;&#34;Filling the input pandas dataframe p with missing dates
    &#34;&#34;&#34;
    if not isinstance(p, pd.DataFrame):
        raise CoaTypeError(&#34;Expecting input p as a pandas dataframe.&#34;)
    if not date_field in p.columns:
        raise CoaKeyError(&#34;The date_field is not a proper column of input pandas dataframe.&#34;)
    if not loc_field in p.columns:
        raise CoaKeyError(&#34;The loc_field is not a proper column of input pandas dataframe.&#34;)
    # datatoilettage :)
    p = p.loc[~p[loc_field].isin([&#39;&#39;])]

    if d2==None:
        d2=p[date_field].max()
    if d1==None:
        d1=p[date_field].min()

    if not all(isinstance(d, datetime.date) for d in [d1,d2]):
        raise CoaTypeError(&#34;Waiting for dates as datetime.date.&#34;)
    if d1 &gt; d2:
        raise CoaKeyError(&#34;Dates should be ordered as d1&lt;d2.&#34;)

    idx = pd.date_range(d1, d2, freq = &#34;D&#34;)
    idx = idx.date

    all_loc=list(p[loc_field].unique())
    pfill=pd.DataFrame()
    for l in all_loc:
        pp=p.loc[p[loc_field]==l]
        pp2=pp.set_index([date_field])
        pp2.index = pd.DatetimeIndex(pp2.index)
        pp3 = pp2.reindex(idx,fill_value=numpy.nan)#pandas.NA)
        pp3[loc_field] = pp3[loc_field].fillna(l)  #pp3[&#39;location&#39;].fillna(method=&#39;bfill&#39;)
        #pp3[&#39;codelocation&#39;] = pp3[&#39;codelocation&#39;].fillna(method=&#39;bfill&#39;)
        #pp3[&#39;codelocation&#39;] = pp3[&#39;codelocation&#39;].fillna(method=&#39;ffill&#39;)
        pfill=pd.concat([pfill, pp3])
    pfill.reset_index(inplace=True)
    return pfill</code></pre>
</details>
</dd>
<dt id="coa.tools.get_db_list_dict"><code class="name flex">
<span>def <span class="ident">get_db_list_dict</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return db list dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_db_list_dict():
    &#34;&#34;&#34;Return db list dict&#34;&#34;&#34;
    return _db_list_dict</code></pre>
</details>
</dd>
<dt id="coa.tools.get_local_from_url"><code class="name flex">
<span>def <span class="ident">get_local_from_url</span></span>(<span>url, expiration_time=0, suffix='')</span>
</code></dt>
<dd>
<div class="desc"><p>"Download data from the given url and store it into a local file.</p>
<p>If the expiration time is 0 (default), the data will never be downloaded anymore if available.
If the expiration time is &lt; 0, it forces to download the file.
If the expiration time (in seconds) is lower than time difference between now and last modification
time of the file, the file is downloaded.</p>
<p>One may add a suffix to the local filename if known.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_from_url(url,expiration_time=0,suffix=&#39;&#39;):
    &#34;&#34;&#34;&#34;Download data from the given url and store it into a local file.

    If the expiration time is 0 (default), the data will never be downloaded anymore if available.
    If the expiration time is &lt; 0, it forces to download the file.
    If the expiration time (in seconds) is lower than time difference between now and last modification
    time of the file, the file is downloaded.

    One may add a suffix to the local filename if known.
    &#34;&#34;&#34;

    tmpdir=os.path.join(gettempdir(),&#34;pycoa_data&#34;+&#34;_&#34;+getuser())
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)

    local_base_filename=urlparse(url).netloc+&#34;_&#34;+str(crc32(bytes(url,&#39;utf-8&#39;)))+suffix
    local_tmp_filename=os.path.join(tmpdir,local_base_filename)

    local_file_exists=False

    if _coacache_folder != &#39;&#39;:
        local_cached_filename=os.path.join(_coacache_folder,local_base_filename)
        local_file_exists=os.path.exists(local_cached_filename)
        local_filename=local_cached_filename

    if os.path.exists(local_tmp_filename):
        if local_file_exists: # prefering the file in tmp if more recent
            if os.path.getmtime(local_tmp_filename) &gt; os.path.getmtime(local_filename):
                local_filename = local_tmp_filename
        else:
            local_file_exists=True
            local_filename=local_tmp_filename

    if expiration_time &gt;=0 and local_file_exists:
        if expiration_time==0 or time.time()-os.path.getmtime(local_filename)&lt;expiration_time:
            verb(&#39;Using locally stored data for &#39;+url+&#39; stored as &#39;+local_filename)
            return local_filename

    # if not : download the file in tmp area
    local_filename=local_tmp_filename
    try:
        headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#39;}
        urlfile = requests.get(url, allow_redirects=True,headers=headers) # adding headers for server which does not accept no browser presentation
        fp=open(local_filename,&#39;wb&#39;)
        fp.write(urlfile.content)
        fp.close()
        verb(&#39;Download content of &#39;+url+&#39; . Locally stored as cached data in &#39;+local_filename)
    except requests.exceptions.RequestException :
        if local_file_exists and expiration_time &gt;=0 :
            info(&#39;Cannot access to &#39;+url+&#39; . Will use locally stored cached version.&#39;)
            pass
        else:
            raise CoaConnectionError(&#39;Cannot access to the url &#39;+\
                url+&#39; . Please check your internet connection or url path.&#39;)
    except Exception as e2:
        raise CoaNotManagedError(type(e2).__name__+&#34; : &#34;+str(e2))

    return local_filename</code></pre>
</details>
</dd>
<dt id="coa.tools.get_verbose_mode"><code class="name flex">
<span>def <span class="ident">get_verbose_mode</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the verbose mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_verbose_mode():
    &#34;&#34;&#34;Return the verbose mode
    &#34;&#34;&#34;
    return _verbose_mode</code></pre>
</details>
</dd>
<dt id="coa.tools.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Print to stdout with similar args as the builtin print function,
if _verbose_mode &gt; 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(*args):
    &#34;&#34;&#34;Print to stdout with similar args as the builtin print function,
    if _verbose_mode &gt; 0
    &#34;&#34;&#34;
    if _verbose_mode &gt; 0:
        print(*args)</code></pre>
</details>
</dd>
<dt id="coa.tools.kwargs_test"><code class="name flex">
<span>def <span class="ident">kwargs_test</span></span>(<span>given_args, expected_args, error_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the list of kwargs is compatible with expected args. If not
it raises a CoaKeyError with error_string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kwargs_test(given_args, expected_args, error_string):
    &#34;&#34;&#34;Test that the list of kwargs is compatible with expected args. If not
    it raises a CoaKeyError with error_string.
    &#34;&#34;&#34;

    if type(given_args)!=dict:
        raise CoaKeyError(&#34;kwargs_test error, the given args are not a dict type.&#34;)
    if type(expected_args)!=list:
        raise CoaKeyError(&#34;kwargs_test error, the expected args are not a list type&#34;)

    bad_kwargs=[a for a in list(given_args.keys()) if a not in expected_args ]
    if len(bad_kwargs) != 0 :
        raise CoaKeyError(error_string+&#39; Unrecognized args are &#39;+str(bad_kwargs)+&#39;.&#39;)

    return True</code></pre>
</details>
</dd>
<dt id="coa.tools.set_verbose_mode"><code class="name flex">
<span>def <span class="ident">set_verbose_mode</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the verbose mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_verbose_mode(v):
    &#34;&#34;&#34;Set the verbose mode
    &#34;&#34;&#34;
    global _verbose_mode
    _verbose_mode=v
    return get_verbose_mode()</code></pre>
</details>
</dd>
<dt id="coa.tools.tostdstring"><code class="name flex">
<span>def <span class="ident">tostdstring</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Standardization of string for country,region or subregion tests</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostdstring(s):
    &#34;&#34;&#34;Standardization of string for country,region or subregion tests
    &#34;&#34;&#34;
    return unidecode.unidecode(&#39; &#39;.join(s.replace(&#39;-&#39;,&#39; &#39;).split())).upper()</code></pre>
</details>
</dd>
<dt id="coa.tools.verb"><code class="name flex">
<span>def <span class="ident">verb</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Print to stdout with similar args as the builtin print function,
if _verbose_mode &gt; 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verb(*args):
    &#34;&#34;&#34;Print to stdout with similar args as the builtin print function,
    if _verbose_mode &gt; 1
    &#34;&#34;&#34;
    if _verbose_mode &gt; 1:
        print(*args)</code></pre>
</details>
</dd>
<dt id="coa.tools.week_to_date"><code class="name flex">
<span>def <span class="ident">week_to_date</span></span>(<span>whenstr)</span>
</code></dt>
<dd>
<div class="desc"><p>convert week to date.
2 cases:
- Rolling week
if format is Y-M-D-Y-M-D: return middle dates
- One week data Wnumber: return monday correction to the week number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def week_to_date(whenstr):
    &#34;&#34;&#34;
    convert week to date.
    2 cases:
    - Rolling week
        if format is Y-M-D-Y-M-D: return middle dates
    - One week data Wnumber: return monday correction to the week number
    &#34;&#34;&#34;
    convertion = 0
    if len(whenstr) == 21:
        firstday = datetime.date(int(whenstr.split(&#39;-&#39;)[0]),int(whenstr.split(&#39;-&#39;)[1]),int(whenstr.split(&#39;-&#39;)[2]))
        lastday  = datetime.date(int(whenstr.split(&#39;-&#39;)[3]),int(whenstr.split(&#39;-&#39;)[4]),int(whenstr.split(&#39;-&#39;)[5]))
        convertion = firstday + (lastday - firstday)/2
    elif len(whenstr) == 10:
        firstday = datetime.date(int(whenstr.split(&#39;-&#39;)[0]),int(whenstr.split(&#39;-&#39;)[1]),int(whenstr.split(&#39;-&#39;)[2]))
        convertion = firstday+datetime.timedelta(days=3)
    else:
        convertion = datetime.datetime.strptime(whenstr  + &#39;-1&#39; , &#34;%G-S%V-%u&#34;)
    return convertion</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coa.tools.dotdict"><code class="flex name class">
<span>class <span class="ident">dotdict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dot.notation access to dictionary attributes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dotdict(dict):
    &#34;&#34;&#34;dot.notation access to dictionary attributes&#34;&#34;&#34;
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#about">About</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coa" href="index.html">coa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="coa.tools.check_valid_date" href="#coa.tools.check_valid_date">check_valid_date</a></code></li>
<li><code><a title="coa.tools.extract_dates" href="#coa.tools.extract_dates">extract_dates</a></code></li>
<li><code><a title="coa.tools.fill_missing_dates" href="#coa.tools.fill_missing_dates">fill_missing_dates</a></code></li>
<li><code><a title="coa.tools.get_db_list_dict" href="#coa.tools.get_db_list_dict">get_db_list_dict</a></code></li>
<li><code><a title="coa.tools.get_local_from_url" href="#coa.tools.get_local_from_url">get_local_from_url</a></code></li>
<li><code><a title="coa.tools.get_verbose_mode" href="#coa.tools.get_verbose_mode">get_verbose_mode</a></code></li>
<li><code><a title="coa.tools.info" href="#coa.tools.info">info</a></code></li>
<li><code><a title="coa.tools.kwargs_test" href="#coa.tools.kwargs_test">kwargs_test</a></code></li>
<li><code><a title="coa.tools.set_verbose_mode" href="#coa.tools.set_verbose_mode">set_verbose_mode</a></code></li>
<li><code><a title="coa.tools.tostdstring" href="#coa.tools.tostdstring">tostdstring</a></code></li>
<li><code><a title="coa.tools.verb" href="#coa.tools.verb">verb</a></code></li>
<li><code><a title="coa.tools.week_to_date" href="#coa.tools.week_to_date">week_to_date</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coa.tools.dotdict" href="#coa.tools.dotdict">dotdict</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>