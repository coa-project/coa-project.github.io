<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>coa.front API documentation</title>
<meta name="description" content="Project : PyCoA - Copyright ©pycoa.fr
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coa.front</code></h1>
</header>
<section id="section-intro">
<p>Project : PyCoA - Copyright ©pycoa.fr
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint LICENSE file</p>
<p>Module : coa.front</p>
<h2 id="about">About :</h2>
<p>This is the PyCoA front end functions. It provides easy access and
use of the whole PyCoA framework in a simplified way.
The use can change the database, the type of data, the output format
with keywords (see help of functions below).</p>
<h2 id="basic-usage">Basic Usage</h2>
<p><strong> plotting covid deaths (default value) vs. time </strong>
import coa.front as cf</p>
<pre><code>cf.plot(where='France')  # where keyword is mandatory
</code></pre>
<p><strong> getting recovered data for some countries </strong></p>
<pre><code>cf.get(where=['Spain','Italy'],which='recovered')
</code></pre>
<p><strong> listing available database and which data can be used </strong>
cf.listwhom()
cf.setwhom('jhu') # return available keywords (aka 'which' data)
cf.listwhich()
# idem
cf.listwhat()
# return available time series type (weekly,
# daily&hellip;)
cf.plot(option='sumall') # return the cumulative plot for all countries
# for default which keyword. See cf.listwhich() and
# and other cf.list**() function (see below)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;Project : PyCoA - Copyright ©pycoa.fr
Date :    april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
License: See joint LICENSE file

Module : coa.front

About :
-------

This is the PyCoA front end functions. It provides easy access and
use of the whole PyCoA framework in a simplified way.
The use can change the database, the type of data, the output format
with keywords (see help of functions below).

Basic usage
-----------
** plotting covid deaths (default value) vs. time **
    import coa.front as cf

    cf.plot(where=&#39;France&#39;)  # where keyword is mandatory
** getting recovered data for some countries **

    cf.get(where=[&#39;Spain&#39;,&#39;Italy&#39;],which=&#39;recovered&#39;)
** listing available database and which data can be used **
    cf.listwhom()
    cf.setwhom(&#39;jhu&#39;) # return available keywords (aka &#39;which&#39; data)
    cf.listwhich()   # idem
    cf.listwhat()    # return available time series type (weekly,
                     # daily...)
    cf.plot(option=&#39;sumall&#39;) # return the cumulative plot for all countries
                     # for default which keyword. See cf.listwhich() and
                     # and other cf.list**() function (see below)

&#34;&#34;&#34;

# --- Imports ----------------------------------------------------------
import pandas as pd
from functools import wraps
import numpy as np
from bokeh.io import show, output_notebook
import types

from coa.tools import kwargs_test, extract_dates, get_db_list_dict, info
import coa.covid19 as coco
from coa.error import *
import coa._version
import coa.geo as coge

output_notebook(hide_banner=True)

# --- Needed global private variables ----------------------------------
_listwhom = list(get_db_list_dict().keys())

if &#39;coa_db&#39; in __builtins__.keys():
    if not __builtins__[&#39;coa_db&#39;] in _listwhom:
        raise CoaDbError(&#34;The variable __builtin__.coa_db set to &#34; + str(__builtins__[&#39;coa_db&#39;]) +
                         &#34; which is an invalid db. Error.&#34;)
    _whom = __builtins__[&#39;coa_db&#39;]
else:
    _whom = _listwhom[0]  # default base

_db, _cocoplot = coco.DataBase.factory(_whom)  # initialization with default
_gi = None

_dict_bypop = {&#39;no&#39;:0,&#39;100&#39;:100,&#39;1k&#39;:1e3,&#39;100k&#39;:1e5,&#39;1M&#39;:1e6,&#39;pop&#39;:1.}

_listwhat = [&#39;cumul&#39;,  # first one is default, nota:  we must avoid uppercases
             &#39;daily&#39;,
             &#39;weekly&#39;]

_listoutput = [&#39;pandas&#39;,&#39;list&#39;, &#39;dict&#39;, &#39;array&#39;]  # first one is default for get

_listvisu = [&#39;bokeh&#39;, &#39;folium&#39;]


# --- Front end functions ----------------------------------------------

# ----------------------------------------------------------------------
# --- getversion() -----------------------------------------------------
# ----------------------------------------------------------------------
def getversion():
    &#34;&#34;&#34;Return the current running version of pycoa.
    &#34;&#34;&#34;
    return coa._version.__version__


# ----------------------------------------------------------------------
# --- listoutput() -----------------------------------------------------
# ----------------------------------------------------------------------

def listoutput():
    &#34;&#34;&#34;Return the list of currently available output types for the
    get() function. The first one is the default output given if
    not specified.
    &#34;&#34;&#34;
    return _listoutput


# ----------------------------------------------------------------------
# --- listvisu() -------------------------------------------------------
# ----------------------------------------------------------------------
def listvisu():
    &#34;&#34;&#34;Return the list of currently available visualization for the
    map() function. The first one is the default output given if
    not specified.
    &#34;&#34;&#34;
    return _listvisu


# ----------------------------------------------------------------------
# --- listwhom() -------------------------------------------------------
# ----------------------------------------------------------------------

def listwhom(detailed=False):
    &#34;&#34;&#34;Return the list of currently avalailable databases for covid19
     data in PyCoA.
     The first one is the default one.

     If detailed=True, gives information location of each given database.
    &#34;&#34;&#34;
    try:
        if int(detailed):
            df = pd.DataFrame(get_db_list_dict())
            df = df.T.reset_index()
            df.index = df.index+1
            df = df.rename(columns={&#39;index&#39;:&#39;Database&#39;,0: &#34;WW/iso3&#34;,1:&#39;Granularité&#39;,2:&#39;WW/Name&#39;})
            return df
        else:
            return _db.get_available_database()
    except:
        raise CoaKeyError(&#39;Waiting for a boolean !&#39;)


# ----------------------------------------------------------------------
# --- listwhat() -------------------------------------------------------
# ----------------------------------------------------------------------

def listwhat():
    &#34;&#34;&#34;Return the list of currently avalailable type of series available.
     The first one is the default one.
    &#34;&#34;&#34;
    return _listwhat


# ----------------------------------------------------------------------
# --- listoption() -----------------------------------------------------
# ----------------------------------------------------------------------

def listoption():
    &#34;&#34;&#34;Return the list of currently avalailable option apply to data.
     Default is no option.
    &#34;&#34;&#34;
    return _db.get_available_options()


# ----------------------------------------------------------------------
# --- listtile() -------------------------------------------------------
# ----------------------------------------------------------------------

def listtile():
    &#34;&#34;&#34;Return the list of currently avalailable tile option for map()
     Default is the first one.
    &#34;&#34;&#34;
    return _cocoplot.tiles_list()


# ----------------------------------------------------------------------
# --- listwhich() ------------------------------------------------------
# ----------------------------------------------------------------------

def listwhich():
    &#34;&#34;&#34;Get which are the available fields for the current base.
    Output is a list of string.
    By default, the listwhich()[0] is the default which field in other
    functions.
    &#34;&#34;&#34;
    return _db.get_available_keys_words()


# ----------------------------------------------------------------------
# --- listwhere() ------------------------------------------------------
# ----------------------------------------------------------------------
def listwhere(clustered = False):
    &#34;&#34;&#34;Get the list of available regions/subregions managed by the current database
    &#34;&#34;&#34;
    def clust():
        r = _db.geo.get_region_list()
        if isinstance(r, list):
            return r
        else:
            return sorted(r[&#39;name_region&#39;].to_list())

    if clustered:
        return clust()
    else:
        if _db.db_world == True:
            r = _db.geo.get_GeoRegion().get_countries_from_region(&#39;world&#39;)
            r = [_db.geo.to_standard(c)[0] for c in r]
        else:
            if get_db_list_dict()[_whom][1] == &#39;subregion&#39;:
                pan = _db.geo.get_subregion_list()
                r = list(pan.name_subregion.unique())
            else:
                r = clust()
        return r

# ----------------------------------------------------------------------
# --- listbypop() ------------------------------------------------------
# ----------------------------------------------------------------------

def listbypop():
    &#34;&#34;&#34;Get the list of available population normalization
    &#34;&#34;&#34;
    return list(_dict_bypop.keys())

# ----------------------------------------------------------------------
# --- setwhom() --------------------------------------------------------
# ----------------------------------------------------------------------

def setwhom(base):
    &#34;&#34;&#34;Set the covid19 database used, given as a string.
    Please see pycoa.listbase() for the available current list.

    By default, the listbase()[0] is the default base used in other
    functions.
    &#34;&#34;&#34;
    global _whom, _db, _cocoplot
    if base not in listwhom():
        raise CoaDbError(base + &#39; is not a supported database. &#39;
                                &#39;See pycoa.listbase() for the full list.&#39;)
    if True:  # force the init #_whom != base:
        _db, _cocoplot = coco.DataBase.factory(base)
        _whom = base

    return listwhich()


# ----------------------------------------------------------------------
# --- getwhom() --------------------------------------------------------
# ----------------------------------------------------------------------
def getwhom():
    &#34;&#34;&#34;Return the current base which is used
    &#34;&#34;&#34;
    return _whom


# ----------------------------------------------------------------------
# --- get(**kwargs) ----------------------------------------------------
# ----------------------------------------------------------------------

def getinfo(which):
    &#34;&#34;&#34;
        Return keyword_definition for the db selected
    &#34;&#34;&#34;
    #if not which:
        #which = listwhich()[0]
    #    print(&#39;Load default which:&#39;,which)
    #elif which not in listwhich():
    #    raise CoaKeyError(&#39;Which option &#39; + which + &#39; not supported. &#39;
    #                                                &#39;See listwhich() for list.&#39;)
    print(_db.get_keyword_definition(which),&#39;\nurl:&#39;, _db.get_keyword_url(which)[0],&#39;\n(more info &#39;,_db.get_keyword_url(which)[1],&#39;)&#39;)

# ----------------------------------------------------------------------
# --- Normalisation by pop input pandas return pandas whith by pop new column
# ---------------------------------------------------------------------
def normbypop(pandy, val2norm,bypop):
    &#34;&#34;&#34;
        Return a pandas with a normalisation column add by population
        * can normalize by &#39;100&#39;, &#39;1k&#39;, &#39;100k&#39; or &#39;1M&#39;
    &#34;&#34;&#34;
    global _gi
    if isinstance(pandy[&#39;codelocation&#39;].iloc[0],list):
        pandy = pandy.explode(&#39;codelocation&#39;)

    if _db.db_world == True:
        if not isinstance(_gi,coa.geo.GeoInfo):
            _gi = coge.GeoInfo()
        pop_field=&#39;population&#39;
        pandy = _gi.add_field(input=pandy,field=pop_field,geofield=&#39;codelocation&#39;)
    else:
        if not isinstance(_gi,coa.geo.GeoCountry):
            _gi=None
        else:
            if _gi.get_country() != _db.geo.get_country():
                _gi=None

        if _gi == None :
            _gi = _db.geo
        pop_field=&#39;population_subregion&#39;
        if pop_field not in _gi.get_list_properties():
            raise CoaKeyError(&#39;The population information not available for this country. No normalization possible&#39;)

        pandy=_gi.add_field(input=pandy,field=pop_field,input_key=&#39;codelocation&#39;)

    clust = pandy[&#39;clustername&#39;].unique()
    df = pd.DataFrame()
    for i in clust:
        pandyi = pandy.loc[ pandy[&#39;clustername&#39;] == i ].copy()
        pandyi.loc[:,pop_field] = pandyi.groupby(&#39;codelocation&#39;)[pop_field].first().sum()
        cody = [pandyi.groupby(&#39;codelocation&#39;)[&#39;codelocation&#39;].first().tolist()]*len(pandyi)
        pandyi = pandyi.assign(codelocation=cody)
        if df.empty:
            df = pandyi
        else:
            df = df.append(pandyi)
    df = df.drop_duplicates([&#39;date&#39;,&#39;clustername&#39;])
    pandy = df

    pandy=pandy.copy()
    pandy[pop_field]=pandy[pop_field].replace(0., np.nan)
    pandy.loc[:,val2norm+&#39; per &#39;+bypop]=pandy[val2norm]/pandy[pop_field]*_dict_bypop[bypop]
    return pandy

# ----------------------------------------------------------------------
# --- get(**kwargs) ----------------------------------------------------
# ----------------------------------------------------------------------
def get(**kwargs):
    &#34;&#34;&#34;Return covid19 data in specified format output (default, by list)
    for specified locations (&#39;where&#39; keyword).
    The used database is set by the setbase() function but can be
    changed on the fly (&#39;whom&#39; keyword)
    Keyword arguments
    -----------------

    where  --   a single string of location, or list of (mandatory,
                no default value)
    which  --   what sort of data to deliver ( &#39;death&#39;,&#39;confirmed&#39;,
                &#39;recovered&#39; for &#39;jhu&#39; default database). See listwhich() function
                for full list according to the used database.

    what   --   which data are computed, either in cumulative mode
                (&#39;cumul&#39;, default value), or &#39;daily&#39; (diff with previous day
                and &#39;weekly&#39; (diff with previous week). See
                listwhich() for fullist of available
                Full list of what keyword with the listwhat() function.

    whom   --   Database specification (overload the setbase()
                function). See listwhom() for supported list

    when   --   dates are given under the format dd/mm/yyyy. In the when
                option, one can give one date which will be the end of
                the data slice. Or one can give two dates separated with
                &#34;:&#34;, which will define the time cut for the output data
                btw those two dates.

    output --   output format returned ( pandas (default), array (numpy.array),
                dict or list). See listoutput() function.

    option --   pre-computing option.
                * nonneg means that negative daily balance is pushed back
                to previousdays in order to have a cumulative function which is
                monotonous increasing.
                * nofillnan means that nan value won&#39;t be filled.
                * smooth7 will perform a 7 day window average of data
                * sumall will return integrated over locations given via the
                where keyword. If using double bracket notation, the sumall
                option is applied for each bracketed member of the where arg.

                By default : no option.
                See listoption().
    bypop --    normalize by population (if available for the selected database).
                * by default, &#39;no&#39; normalization
                * can normalize by &#39;100&#39;, &#39;1k&#39;, &#39;100k&#39; or &#39;1M&#39;
    &#34;&#34;&#34;
    kwargs_test(kwargs, [&#39;where&#39;, &#39;what&#39;, &#39;which&#39;, &#39;whom&#39;, &#39;when&#39;, &#39;output&#39;, &#39;option&#39;, &#39;bins&#39;, &#39;title&#39;,\
                        &#39;visu&#39;, &#39;tile&#39;,&#39;typeofplot&#39;,&#39;dateslider&#39;,&#39;maplabel&#39;,&#39;typeofhist&#39;,&#39;mode&#39;,&#39;guideline&#39;,&#39;bypop&#39;,
                        &#39;plot_width&#39;,&#39;plot_height&#39;,&#39;textcopyright&#39;,&#39;textcopyrightposition&#39;],
                &#39;Bad args used in the pycoa.get() function.&#39;)
    # no dateslider currently

    global _db, _whom, _gi
    where = kwargs.get(&#39;where&#39;, None)
    what = kwargs.get(&#39;what&#39;, listwhat()[0])
    which = kwargs.get(&#39;which&#39;, None)
    whom = kwargs.get(&#39;whom&#39;, None)
    option = kwargs.get(&#39;option&#39;, None)
    when = kwargs.get(&#39;when&#39;, None)
    if &#39;mode&#39; in kwargs:
        kwargs.pop(&#39;mode&#39;)
    option = kwargs.get(&#39;option&#39;, None)
    bypop = kwargs.get(&#39;bypop&#39;,&#39;no&#39;)

    output = kwargs.get(&#39;output&#39;, listoutput()[0])

    if output not in listoutput():
        raise CoaKeyError(&#39;Output option &#39; + output + &#39; not supported. See help().&#39;)

    if whom is None:
        whom = _whom
    if whom != _whom:
        setwhom(whom)

    if not bool([s for s in listwhat() if what.startswith(s)]):
        raise CoaKeyError(&#39;What option &#39; + what + &#39; not supported. &#39;
                                                  &#39;See listwhat() for full list.&#39;)

    if not which:
        which = listwhich()[0]
    elif which not in listwhich():
        raise CoaKeyError(&#39;Which option &#39; + which + &#39; not supported. &#39;
                                                    &#39;See listwhich() for list.&#39;)
    if bypop not in listbypop():
        raise CoaKeyError(&#39;The bypop arg should be selected in &#39;+str(listbypop)+&#39; only.&#39;)

    pandy = _db.get_stats(which=which, location=where, option=option).rename(columns={&#39;location&#39;: &#39;where&#39;})
    when_beg, when_end = extract_dates(when)
    if when_end &gt; pandy[[which,&#39;date&#39;]].date.max():
        when_end = pandy[[which,&#39;date&#39;]].date.max()

    db_first_date = pandy[[which,&#39;date&#39;]].date.min()
    db_last_date = pandy[[which,&#39;date&#39;]].date.max()
    if when_beg &lt; db_first_date:
        when_beg = db_first_date
    if when_end &gt; db_last_date:
        when_end = db_last_date
    # when cut
    if when_beg &gt;  pandy[[which,&#39;date&#39;]].date.max() or when_end &gt;  pandy[[which,&#39;date&#39;]].date.max():
        raise CoaNoData(&#34;No available data after &#34;+str( pandy[[which,&#39;date&#39;]].date.max()))

    pandy = pandy[(pandy.date &gt;= when_beg) &amp; (pandy.date &lt;= when_end)]
    pandy.reset_index()
    pop_field = &#39;&#39;
    # manage pop norm if asked
    if bypop != &#39;no&#39;:
        if what:
            val2norm=what
        else:
            val2norm=which
        pandy = normbypop(pandy,val2norm,bypop)
    # casted_data = None
    if output == &#39;pandas&#39;:
        pandy = pandy.drop_duplicates([&#39;date&#39;,&#39;clustername&#39;])
        pandy = pandy.drop(columns=[&#39;cumul&#39;])
        pandy[&#39;cumul&#39;] = pandy[which]
        casted_data = pandy
    # print(pandy)
    # casted_data = pd.pivot_table(pandy, index=&#39;date&#39;,columns=&#39;where&#39;,values=col_name).to_dict(&#39;series&#39;)
    # print(pandy)
    elif output == &#39;dict&#39;:
        casted_data = pandy.to_dict(&#39;split&#39;)
    elif output == &#39;list&#39; or output == &#39;array&#39;:
        my_list = []
        for keys, values in pandy.items():
            vc = [i for i in values]
            my_list.append(vc)
        casted_data = my_list
        if output == &#39;array&#39;:
            casted_data = np.array(pandy)
    else:
        raise CoaKeyError(&#39;Unknown output.&#39;)
    return casted_data

def saveoutput(**kwargs):
    &#39;&#39;&#39;
        Export pycoas pandas as an output file selected by output argument
        &#39;pandas&#39;: pandas to save
        &#39;saveformat&#39;: excel (default) or csv
        &#39;savename&#39;: None (default pycoaout+ &#39;.xlsx/.csv&#39;)
    &#39;&#39;&#39;
    global _db
    kwargs_test(kwargs, [&#39;pandas&#39;,&#39;saveformat&#39;,&#39;savename&#39;], &#39;Bad args used in the pycoa.saveoutput function.&#39;)
    pandy = kwargs.get(&#39;pandas&#39;, pd.DataFrame())
    saveformat = kwargs.get(&#39;saveformat&#39;, &#39;excel&#39;)
    savename = kwargs.get(&#39;savename&#39;, &#39;&#39;)
    if pandy.empty:
        raise CoaKeyError(&#39;Pandas to save is mandatory there is not default !&#39;)
    else:
        _db.saveoutput(pandas=pandy,saveformat=saveformat,savename=savename)

def merger(**kwargs):
    &#39;&#39;&#39;
    Merge two or more pycoa pandas from get_stats operation
    &#39;coapandas&#39;: list (min 2D) of pandas from stats
    &#39;whichcol&#39;: list variable associate to the coapandas list to be retrieve
    &#39;&#39;&#39;
    global _db
    kwargs_test(kwargs,[&#39;coapandas&#39;, &#39;whichcol&#39;], &#39;Bad args used in the pycoa.merger function.&#39;)
    listpandy = kwargs.get(&#39;coapandas&#39;,[])
    listcol = kwargs.get(&#39;whichcol&#39;,[])
    if len(listpandy)==0 or len(listcol)==0:
       raise CoaKeyError(&#39;List of pandas / List of columns keep  is mandatory there is not default !&#39;)
    else:
       return _db.merger(coapandas = listpandy,whichcol = listcol)

# ----------------------------------------------------------------------
# --- chartsinput_deco(f)
# ------  with wraps
# ----------  wrapper(*args, **kwargs)
#---------------------------------------
# ----------------------------------------------------------------------
def chartsinput_deco(f):
    &#39;&#39;&#39;
        Main decorator it mainly deals with arg testings
    &#39;&#39;&#39;
    @wraps(f)
    def wrapper(*args, **kwargs):
        &#39;&#39;&#39;
            wrapper dealing with arg testing
        &#39;&#39;&#39;
        kwargs_test(kwargs,
                    [&#39;where&#39;, &#39;what&#39;, &#39;which&#39;, &#39;whom&#39;, &#39;when&#39;, &#39;input&#39;, &#39;input_field&#39;,\
                    &#39;title&#39;,&#39;typeofplot&#39;,&#39;typeofhist&#39;,&#39;bins&#39;,&#39;visu&#39;,&#39;tile&#39;,&#39;dateslider&#39;,&#39;maplabel&#39;,&#39;option&#39;,&#39;mode&#39;,&#39;guideline&#39;,&#39;bypop&#39;,
                    &#39;plot_width&#39;,&#39;plot_height&#39;,&#39;textcopyright&#39;,&#39;textcopyrightposition&#39;],
                    &#39;Bad args used in the pycoa function.&#39;)
        input_arg = kwargs.get(&#39;input&#39;, None)
        input_field = kwargs.get(&#39;input_field&#39;)
        where = kwargs.get(&#39;where&#39;, None)
        what = kwargs.get(&#39;what&#39;, None)
        which = kwargs.get(&#39;which&#39;, None)
        when = kwargs.get(&#39;when&#39;, None)
        option = kwargs.get(&#39;option&#39;, None)

        bypop=kwargs.pop(&#39;bypop&#39;,&#39;no&#39;)

        if isinstance(input_arg, pd.DataFrame):
            if bypop != &#39;no&#39;:
                input_arg = normbypop(input_arg,input_field,bypop)

            input_field = kwargs.get(&#39;input_field&#39;, listwhich()[0])
            #if input_field not in input_arg.columns:
            #    raise CoaKeyError(&#34;Cannot find &#34; + str(input_field) + &#34; field in the pandas data. &#34;
            #                                                          &#34;Set a proper input_field key.&#34;)
            if &#39;option&#39; in kwargs:
                raise CoaKeyError(&#34;Cannot use option with input pandas data. &#34;
                                  &#34;Use option within the get() function instead.&#34;)
            kwargs[&#39;input&#39;] = input_arg

        elif input_arg == None:
            kwargs[&#39;input&#39;] = get(**kwargs,output=&#39;pandas&#39;)
            which = kwargs.get(&#39;which&#39;, listwhich()[0])
            what = kwargs.get(&#39;what&#39;, listwhat()[0])
            option = kwargs.get(&#39;option&#39;, None)
        else:
            raise CoaTypeError(&#39;Waiting input as valid pycoa pandas &#39;
                               &#39;dataframe. See help.&#39;)

        if bypop != &#39;no&#39;:
            if what:
                kwargs[&#39;what&#39;]=what+&#39; per &#39;+bypop
                input_field=kwargs[&#39;what&#39;]
            elif which:
                kwargs[&#39;which&#39;]=which+&#39; per &#39;+bypop
                input_field=kwargs[&#39;which&#39;]
            else:
                input_field = input_field+&#39; per &#39;+bypop

        kwargs[&#39;input_field&#39;] = input_field
        return f(**kwargs)

    return wrapper
# ----------------------------------------------------------------------
# --- map(**kwargs) ----------------------------------------------------
# ----------------------------------------------------------------------
@chartsinput_deco
def map(**kwargs):
    &#34;&#34;&#34;
    Create a map according to arguments and options.
    See help(map).
    - 2 types of visu are avalailable so far : bokeh or folium (see listvisu())
    by default visu=&#39;bokeh&#39;
    - In the default case (i.e visu=&#39;bokeh&#39;) available option are :
        - dateslider=True: a date slider is called and displayed on the right part of the map
        - maplabel = text, value are displayed directly on the map
                   = spark, sparkline are displayed directly on the map
                   = tickmap%, colormap tick are in %
    &#34;&#34;&#34;
    visu = kwargs.get(&#39;visu&#39;, listvisu()[0])
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    dateslider = kwargs.get(&#39;dateslider&#39;, None)
    maplabel = kwargs.get(&#39;maplabel&#39;, None)

    if maplabel is not None:
        if not isinstance(maplabel,list):
            maplabel = [maplabel]
        if  not all([a for a in maplabel if a not in [&#39;text&#39;,&#39;spark&#39;,&#39;tickmap%&#39;] ]):
            raise CoaTypeError(&#39;Waiting a correct maplabel value. See help.&#39;)

    sparkline = False
    if dateslider is not None:
        del kwargs[&#39;dateslider&#39;]
        kwargs[&#39;cursor_date&#39;] = dateslider
    if maplabel is not None:
        kwargs[&#39;maplabel&#39;] = []
        if &#39;text&#39; in maplabel:
            kwargs[&#39;maplabel&#39;].append(&#39;text&#39;)
            if &#39;tickmap%&#39; in maplabel:
                kwargs[&#39;maplabel&#39;].append(&#39;tickmap%&#39;)
        elif &#39;spark&#39; in maplabel:
            sparkline = True
        else:
            raise CoaTypeError(&#39;Waiting for a valide label visualisation: text, spark or tickmap%&#39;)

    if visu == &#39;bokeh&#39;:
        if sparkline == False:
            return show(_cocoplot.pycoa_map(input, input_field, **kwargs))
        else:
            return show(_cocoplot.pycoa_sparkmap(input, input_field, **kwargs))
    elif visu == &#39;folium&#39;:
        if dateslider or maplabel:
            raise CoaKeyError(&#39;Not available with folium map, you should considere to use bokeh map visu in this case&#39;)
        return _cocoplot.pycoa_mapfolium(input, input_field, **kwargs)
    else:
        raise CoaTypeError(&#39;Waiting for a valid visualisation. So far: \&#39;bokeh\&#39; or \&#39;folium\&#39;.See help.&#39;)
# ----------------------------------------------------------------------
# --- hist(**kwargs) ---------------------------------------------------
# ----------------------------------------------------------------------
@chartsinput_deco
def hist(**kwargs):
    &#34;&#34;&#34;
    Create histogram according to arguments.
    See help(hist).
    Keyword arguments
    -----------------

    where (mandatory if no input), what, which, whom, when : (see help(get))

    input       --  input data to plot within the pycoa framework (e.g.
                    after some analysis or filtering). Default is None which
                    means that we use the basic raw data through the get
                    function.
                    When the &#39;input&#39; keyword is set, where, what, which,
                    whom when keywords are ignored.
                    input should be given as valid pycoa pandas dataframe.

    input_field --  is the name of the field of the input pandas to plot.
                    Default is &#39;deaths/cumul&#39;, the default output field of
                    the get() function.

    width_height : width and height of the picture .
                If specified should be a list of width and height.
                For instance width_height=[400,500]

    typeofhist  --  &#39;bylocation&#39; (default), &#39;byvalue&#39; or pie

    bins        --  number of bins used, only available for &#39;byvalue&#39; type of
                    histograms.
                    If none provided, a default value will be used.
    &#34;&#34;&#34;
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    dateslider = kwargs.get(&#39;dateslider&#39;, None)
    typeofhist = kwargs.pop(&#39;typeofhist&#39;, &#39;bylocation&#39;)

    if dateslider is not None:
        del kwargs[&#39;dateslider&#39;]
        kwargs[&#39;cursor_date&#39;] = dateslider

    if typeofhist == &#39;bylocation&#39;:
        if &#39;bins&#39; in kwargs:
            raise CoaKeyError(&#34;The bins keyword cannot be set with histograms by location. See help.&#34;)
        fig = _cocoplot.pycoa_horizonhisto(input, input_field, **kwargs)
    elif typeofhist == &#39;byvalue&#39;:
        if dateslider:
            info(&#39;dateslider not implemented for typeofhist=\&#39;byvalue\&#39;.&#39;)
            fig = _cocoplot.pycoa_horizonhisto(input, input_field, **kwargs)
        else:
            fig = _cocoplot.pycoa_histo(input, input_field, **kwargs)
    elif typeofhist == &#39;pie&#39;:
        fig = _cocoplot.pycoa_pie(input, input_field, **kwargs)

    else:
        raise CoaKeyError(&#39;Unknown typeofhist value. Should be bylocation or byvalue.&#39;)
    show(fig)

# ----------------------------------------------------------------------
# --- plot(**kwargs) ---------------------------------------------------
# ----------------------------------------------------------------------
@chartsinput_deco
def plot(**kwargs):
    &#34;&#34;&#34;
    Create a date plot according to arguments. See help(plot).
    Keyword arguments
    -----------------

    where (mandatory), what, which, whom, when : (see help(get))

    input       --  input data to plot within the pycoa framework (e.g.
                    after some analysis or filtering). Default is None which
                    means that we use the basic raw data through the get
                    function.
                    When the &#39;input&#39; keyword is set, where, what, which,
                    whom when keywords are ignored.
                    input should be given as valid pycoa pandas dataframe.

    input_field --  is the name of the field of the input pandas to plot.
                    Default is &#39;deaths/cumul&#39;, the default output field of
                    the get() function.

    width_height : width and height of the picture .
                If specified should be a list of width and height. For instance width_height=[400,500]

    title       --  to force the title of the plot

    typeofplot  -- &#39;date&#39; (default), &#39;menulocation&#39; or &#39;versus&#39;
                   &#39;date&#39;:date plot
                   &#39;menulocation&#39;: date plot with two scroll menu locations.
                                    Usefull to study the behaviour of a variable for two different countries.
                   &#39;versus&#39;: plot variable against an other one.
                             For this type of plot one should used &#39;input&#39; and &#39;input_field&#39; (not fully tested).
                             Moreover dim(input_field) must be 2.

    &#34;&#34;&#34;
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    typeofplot = kwargs.get(&#39;typeofplot&#39;, &#39;date&#39;)

    if &#39;typeofplot&#39; in kwargs:
        typeofplot = kwargs.pop(&#39;typeofplot&#39;)
    if typeofplot == &#39;date&#39;:
        fig = _cocoplot.pycoa_date_plot(input,input_field, **kwargs)
    elif typeofplot == &#39;versus&#39;:
        if input_field is not None and len(input_field) == 2:
            fig = _cocoplot.pycoa_plot(input, input_field,**kwargs)
        else:
            print(&#39;typeofplot is versus but dim(input_field)!=2, versus has not effect ...&#39;)
            fig = _cocoplot.pycoa_date_plot(input, input_field, **kwargs)
    elif typeofplot == &#39;menulocation&#39;:
        if input_field is not None and len(input_field) &gt; 1:
            print(&#39;typeofplot is menulocation but dim(input_field)&gt;1, menulocation has not effect ...&#39;)
        fig = _cocoplot.pycoa_scrollingmenu(input, input_field, **kwargs)
    else:
        raise CoaKeyError(&#39;Unknown typeofplot value. Should be date, versus or menulocation.&#39;)
    show(fig)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coa.front.chartsinput_deco"><code class="name flex">
<span>def <span class="ident">chartsinput_deco</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Main decorator it mainly deals with arg testings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chartsinput_deco(f):
    &#39;&#39;&#39;
        Main decorator it mainly deals with arg testings
    &#39;&#39;&#39;
    @wraps(f)
    def wrapper(*args, **kwargs):
        &#39;&#39;&#39;
            wrapper dealing with arg testing
        &#39;&#39;&#39;
        kwargs_test(kwargs,
                    [&#39;where&#39;, &#39;what&#39;, &#39;which&#39;, &#39;whom&#39;, &#39;when&#39;, &#39;input&#39;, &#39;input_field&#39;,\
                    &#39;title&#39;,&#39;typeofplot&#39;,&#39;typeofhist&#39;,&#39;bins&#39;,&#39;visu&#39;,&#39;tile&#39;,&#39;dateslider&#39;,&#39;maplabel&#39;,&#39;option&#39;,&#39;mode&#39;,&#39;guideline&#39;,&#39;bypop&#39;,
                    &#39;plot_width&#39;,&#39;plot_height&#39;,&#39;textcopyright&#39;,&#39;textcopyrightposition&#39;],
                    &#39;Bad args used in the pycoa function.&#39;)
        input_arg = kwargs.get(&#39;input&#39;, None)
        input_field = kwargs.get(&#39;input_field&#39;)
        where = kwargs.get(&#39;where&#39;, None)
        what = kwargs.get(&#39;what&#39;, None)
        which = kwargs.get(&#39;which&#39;, None)
        when = kwargs.get(&#39;when&#39;, None)
        option = kwargs.get(&#39;option&#39;, None)

        bypop=kwargs.pop(&#39;bypop&#39;,&#39;no&#39;)

        if isinstance(input_arg, pd.DataFrame):
            if bypop != &#39;no&#39;:
                input_arg = normbypop(input_arg,input_field,bypop)

            input_field = kwargs.get(&#39;input_field&#39;, listwhich()[0])
            #if input_field not in input_arg.columns:
            #    raise CoaKeyError(&#34;Cannot find &#34; + str(input_field) + &#34; field in the pandas data. &#34;
            #                                                          &#34;Set a proper input_field key.&#34;)
            if &#39;option&#39; in kwargs:
                raise CoaKeyError(&#34;Cannot use option with input pandas data. &#34;
                                  &#34;Use option within the get() function instead.&#34;)
            kwargs[&#39;input&#39;] = input_arg

        elif input_arg == None:
            kwargs[&#39;input&#39;] = get(**kwargs,output=&#39;pandas&#39;)
            which = kwargs.get(&#39;which&#39;, listwhich()[0])
            what = kwargs.get(&#39;what&#39;, listwhat()[0])
            option = kwargs.get(&#39;option&#39;, None)
        else:
            raise CoaTypeError(&#39;Waiting input as valid pycoa pandas &#39;
                               &#39;dataframe. See help.&#39;)

        if bypop != &#39;no&#39;:
            if what:
                kwargs[&#39;what&#39;]=what+&#39; per &#39;+bypop
                input_field=kwargs[&#39;what&#39;]
            elif which:
                kwargs[&#39;which&#39;]=which+&#39; per &#39;+bypop
                input_field=kwargs[&#39;which&#39;]
            else:
                input_field = input_field+&#39; per &#39;+bypop

        kwargs[&#39;input_field&#39;] = input_field
        return f(**kwargs)

    return wrapper</code></pre>
</details>
</dd>
<dt id="coa.front.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return covid19 data in specified format output (default, by list)
for specified locations ('where' keyword).
The used database is set by the setbase() function but can be
changed on the fly ('whom' keyword)
Keyword Arguments</p>
<hr>
<p>where
&ndash;
a single string of location, or list of (mandatory,
no default value)
which
&ndash;
what sort of data to deliver ( 'death','confirmed',
'recovered' for 'jhu' default database). See listwhich() function
for full list according to the used database.</p>
<p>what
&ndash;
which data are computed, either in cumulative mode
('cumul', default value), or 'daily' (diff with previous day
and 'weekly' (diff with previous week). See
listwhich() for fullist of available
Full list of what keyword with the listwhat() function.</p>
<p>whom
&ndash;
Database specification (overload the setbase()
function). See listwhom() for supported list</p>
<p>when
&ndash;
dates are given under the format dd/mm/yyyy. In the when
option, one can give one date which will be the end of
the data slice. Or one can give two dates separated with
":", which will define the time cut for the output data
btw those two dates.</p>
<p>output &ndash;
output format returned ( pandas (default), array (numpy.array),
dict or list). See listoutput() function.</p>
<p>option &ndash;
pre-computing option.
* nonneg means that negative daily balance is pushed back
to previousdays in order to have a cumulative function which is
monotonous increasing.
* nofillnan means that nan value won't be filled.
* smooth7 will perform a 7 day window average of data
* sumall will return integrated over locations given via the
where keyword. If using double bracket notation, the sumall
option is applied for each bracketed member of the where arg.</p>
<pre><code>        By default : no option.
        See listoption().
</code></pre>
<p>bypop &ndash;
normalize by population (if available for the selected database).
* by default, 'no' normalization
* can normalize by '100', '1k', '100k' or '1M'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(**kwargs):
    &#34;&#34;&#34;Return covid19 data in specified format output (default, by list)
    for specified locations (&#39;where&#39; keyword).
    The used database is set by the setbase() function but can be
    changed on the fly (&#39;whom&#39; keyword)
    Keyword arguments
    -----------------

    where  --   a single string of location, or list of (mandatory,
                no default value)
    which  --   what sort of data to deliver ( &#39;death&#39;,&#39;confirmed&#39;,
                &#39;recovered&#39; for &#39;jhu&#39; default database). See listwhich() function
                for full list according to the used database.

    what   --   which data are computed, either in cumulative mode
                (&#39;cumul&#39;, default value), or &#39;daily&#39; (diff with previous day
                and &#39;weekly&#39; (diff with previous week). See
                listwhich() for fullist of available
                Full list of what keyword with the listwhat() function.

    whom   --   Database specification (overload the setbase()
                function). See listwhom() for supported list

    when   --   dates are given under the format dd/mm/yyyy. In the when
                option, one can give one date which will be the end of
                the data slice. Or one can give two dates separated with
                &#34;:&#34;, which will define the time cut for the output data
                btw those two dates.

    output --   output format returned ( pandas (default), array (numpy.array),
                dict or list). See listoutput() function.

    option --   pre-computing option.
                * nonneg means that negative daily balance is pushed back
                to previousdays in order to have a cumulative function which is
                monotonous increasing.
                * nofillnan means that nan value won&#39;t be filled.
                * smooth7 will perform a 7 day window average of data
                * sumall will return integrated over locations given via the
                where keyword. If using double bracket notation, the sumall
                option is applied for each bracketed member of the where arg.

                By default : no option.
                See listoption().
    bypop --    normalize by population (if available for the selected database).
                * by default, &#39;no&#39; normalization
                * can normalize by &#39;100&#39;, &#39;1k&#39;, &#39;100k&#39; or &#39;1M&#39;
    &#34;&#34;&#34;
    kwargs_test(kwargs, [&#39;where&#39;, &#39;what&#39;, &#39;which&#39;, &#39;whom&#39;, &#39;when&#39;, &#39;output&#39;, &#39;option&#39;, &#39;bins&#39;, &#39;title&#39;,\
                        &#39;visu&#39;, &#39;tile&#39;,&#39;typeofplot&#39;,&#39;dateslider&#39;,&#39;maplabel&#39;,&#39;typeofhist&#39;,&#39;mode&#39;,&#39;guideline&#39;,&#39;bypop&#39;,
                        &#39;plot_width&#39;,&#39;plot_height&#39;,&#39;textcopyright&#39;,&#39;textcopyrightposition&#39;],
                &#39;Bad args used in the pycoa.get() function.&#39;)
    # no dateslider currently

    global _db, _whom, _gi
    where = kwargs.get(&#39;where&#39;, None)
    what = kwargs.get(&#39;what&#39;, listwhat()[0])
    which = kwargs.get(&#39;which&#39;, None)
    whom = kwargs.get(&#39;whom&#39;, None)
    option = kwargs.get(&#39;option&#39;, None)
    when = kwargs.get(&#39;when&#39;, None)
    if &#39;mode&#39; in kwargs:
        kwargs.pop(&#39;mode&#39;)
    option = kwargs.get(&#39;option&#39;, None)
    bypop = kwargs.get(&#39;bypop&#39;,&#39;no&#39;)

    output = kwargs.get(&#39;output&#39;, listoutput()[0])

    if output not in listoutput():
        raise CoaKeyError(&#39;Output option &#39; + output + &#39; not supported. See help().&#39;)

    if whom is None:
        whom = _whom
    if whom != _whom:
        setwhom(whom)

    if not bool([s for s in listwhat() if what.startswith(s)]):
        raise CoaKeyError(&#39;What option &#39; + what + &#39; not supported. &#39;
                                                  &#39;See listwhat() for full list.&#39;)

    if not which:
        which = listwhich()[0]
    elif which not in listwhich():
        raise CoaKeyError(&#39;Which option &#39; + which + &#39; not supported. &#39;
                                                    &#39;See listwhich() for list.&#39;)
    if bypop not in listbypop():
        raise CoaKeyError(&#39;The bypop arg should be selected in &#39;+str(listbypop)+&#39; only.&#39;)

    pandy = _db.get_stats(which=which, location=where, option=option).rename(columns={&#39;location&#39;: &#39;where&#39;})
    when_beg, when_end = extract_dates(when)
    if when_end &gt; pandy[[which,&#39;date&#39;]].date.max():
        when_end = pandy[[which,&#39;date&#39;]].date.max()

    db_first_date = pandy[[which,&#39;date&#39;]].date.min()
    db_last_date = pandy[[which,&#39;date&#39;]].date.max()
    if when_beg &lt; db_first_date:
        when_beg = db_first_date
    if when_end &gt; db_last_date:
        when_end = db_last_date
    # when cut
    if when_beg &gt;  pandy[[which,&#39;date&#39;]].date.max() or when_end &gt;  pandy[[which,&#39;date&#39;]].date.max():
        raise CoaNoData(&#34;No available data after &#34;+str( pandy[[which,&#39;date&#39;]].date.max()))

    pandy = pandy[(pandy.date &gt;= when_beg) &amp; (pandy.date &lt;= when_end)]
    pandy.reset_index()
    pop_field = &#39;&#39;
    # manage pop norm if asked
    if bypop != &#39;no&#39;:
        if what:
            val2norm=what
        else:
            val2norm=which
        pandy = normbypop(pandy,val2norm,bypop)
    # casted_data = None
    if output == &#39;pandas&#39;:
        pandy = pandy.drop_duplicates([&#39;date&#39;,&#39;clustername&#39;])
        pandy = pandy.drop(columns=[&#39;cumul&#39;])
        pandy[&#39;cumul&#39;] = pandy[which]
        casted_data = pandy
    # print(pandy)
    # casted_data = pd.pivot_table(pandy, index=&#39;date&#39;,columns=&#39;where&#39;,values=col_name).to_dict(&#39;series&#39;)
    # print(pandy)
    elif output == &#39;dict&#39;:
        casted_data = pandy.to_dict(&#39;split&#39;)
    elif output == &#39;list&#39; or output == &#39;array&#39;:
        my_list = []
        for keys, values in pandy.items():
            vc = [i for i in values]
            my_list.append(vc)
        casted_data = my_list
        if output == &#39;array&#39;:
            casted_data = np.array(pandy)
    else:
        raise CoaKeyError(&#39;Unknown output.&#39;)
    return casted_data</code></pre>
</details>
</dd>
<dt id="coa.front.getinfo"><code class="name flex">
<span>def <span class="ident">getinfo</span></span>(<span>which)</span>
</code></dt>
<dd>
<div class="desc"><p>Return keyword_definition for the db selected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getinfo(which):
    &#34;&#34;&#34;
        Return keyword_definition for the db selected
    &#34;&#34;&#34;
    #if not which:
        #which = listwhich()[0]
    #    print(&#39;Load default which:&#39;,which)
    #elif which not in listwhich():
    #    raise CoaKeyError(&#39;Which option &#39; + which + &#39; not supported. &#39;
    #                                                &#39;See listwhich() for list.&#39;)
    print(_db.get_keyword_definition(which),&#39;\nurl:&#39;, _db.get_keyword_url(which)[0],&#39;\n(more info &#39;,_db.get_keyword_url(which)[1],&#39;)&#39;)</code></pre>
</details>
</dd>
<dt id="coa.front.getversion"><code class="name flex">
<span>def <span class="ident">getversion</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current running version of pycoa.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getversion():
    &#34;&#34;&#34;Return the current running version of pycoa.
    &#34;&#34;&#34;
    return coa._version.__version__</code></pre>
</details>
</dd>
<dt id="coa.front.getwhom"><code class="name flex">
<span>def <span class="ident">getwhom</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current base which is used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getwhom():
    &#34;&#34;&#34;Return the current base which is used
    &#34;&#34;&#34;
    return _whom</code></pre>
</details>
</dd>
<dt id="coa.front.hist"><code class="name flex">
<span>def <span class="ident">hist</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create histogram according to arguments.
See help(hist).
Keyword Arguments</p>
<hr>
<p>where (mandatory if no input), what, which, whom, when : (see help(get))</p>
<p>input
&ndash;
input data to plot within the pycoa framework (e.g.
after some analysis or filtering). Default is None which
means that we use the basic raw data through the get
function.
When the 'input' keyword is set, where, what, which,
whom when keywords are ignored.
input should be given as valid pycoa pandas dataframe.</p>
<p>input_field &ndash;
is the name of the field of the input pandas to plot.
Default is 'deaths/cumul', the default output field of
the get() function.</p>
<p>width_height : width and height of the picture .
If specified should be a list of width and height.
For instance width_height=[400,500]</p>
<p>typeofhist
&ndash;
'bylocation' (default), 'byvalue' or pie</p>
<p>bins
&ndash;
number of bins used, only available for 'byvalue' type of
histograms.
If none provided, a default value will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@chartsinput_deco
def hist(**kwargs):
    &#34;&#34;&#34;
    Create histogram according to arguments.
    See help(hist).
    Keyword arguments
    -----------------

    where (mandatory if no input), what, which, whom, when : (see help(get))

    input       --  input data to plot within the pycoa framework (e.g.
                    after some analysis or filtering). Default is None which
                    means that we use the basic raw data through the get
                    function.
                    When the &#39;input&#39; keyword is set, where, what, which,
                    whom when keywords are ignored.
                    input should be given as valid pycoa pandas dataframe.

    input_field --  is the name of the field of the input pandas to plot.
                    Default is &#39;deaths/cumul&#39;, the default output field of
                    the get() function.

    width_height : width and height of the picture .
                If specified should be a list of width and height.
                For instance width_height=[400,500]

    typeofhist  --  &#39;bylocation&#39; (default), &#39;byvalue&#39; or pie

    bins        --  number of bins used, only available for &#39;byvalue&#39; type of
                    histograms.
                    If none provided, a default value will be used.
    &#34;&#34;&#34;
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    dateslider = kwargs.get(&#39;dateslider&#39;, None)
    typeofhist = kwargs.pop(&#39;typeofhist&#39;, &#39;bylocation&#39;)

    if dateslider is not None:
        del kwargs[&#39;dateslider&#39;]
        kwargs[&#39;cursor_date&#39;] = dateslider

    if typeofhist == &#39;bylocation&#39;:
        if &#39;bins&#39; in kwargs:
            raise CoaKeyError(&#34;The bins keyword cannot be set with histograms by location. See help.&#34;)
        fig = _cocoplot.pycoa_horizonhisto(input, input_field, **kwargs)
    elif typeofhist == &#39;byvalue&#39;:
        if dateslider:
            info(&#39;dateslider not implemented for typeofhist=\&#39;byvalue\&#39;.&#39;)
            fig = _cocoplot.pycoa_horizonhisto(input, input_field, **kwargs)
        else:
            fig = _cocoplot.pycoa_histo(input, input_field, **kwargs)
    elif typeofhist == &#39;pie&#39;:
        fig = _cocoplot.pycoa_pie(input, input_field, **kwargs)

    else:
        raise CoaKeyError(&#39;Unknown typeofhist value. Should be bylocation or byvalue.&#39;)
    show(fig)</code></pre>
</details>
</dd>
<dt id="coa.front.listbypop"><code class="name flex">
<span>def <span class="ident">listbypop</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of available population normalization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listbypop():
    &#34;&#34;&#34;Get the list of available population normalization
    &#34;&#34;&#34;
    return list(_dict_bypop.keys())</code></pre>
</details>
</dd>
<dt id="coa.front.listoption"><code class="name flex">
<span>def <span class="ident">listoption</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently avalailable option apply to data.
Default is no option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listoption():
    &#34;&#34;&#34;Return the list of currently avalailable option apply to data.
     Default is no option.
    &#34;&#34;&#34;
    return _db.get_available_options()</code></pre>
</details>
</dd>
<dt id="coa.front.listoutput"><code class="name flex">
<span>def <span class="ident">listoutput</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently available output types for the
get() function. The first one is the default output given if
not specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listoutput():
    &#34;&#34;&#34;Return the list of currently available output types for the
    get() function. The first one is the default output given if
    not specified.
    &#34;&#34;&#34;
    return _listoutput</code></pre>
</details>
</dd>
<dt id="coa.front.listtile"><code class="name flex">
<span>def <span class="ident">listtile</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently avalailable tile option for map()
Default is the first one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listtile():
    &#34;&#34;&#34;Return the list of currently avalailable tile option for map()
     Default is the first one.
    &#34;&#34;&#34;
    return _cocoplot.tiles_list()</code></pre>
</details>
</dd>
<dt id="coa.front.listvisu"><code class="name flex">
<span>def <span class="ident">listvisu</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently available visualization for the
map() function. The first one is the default output given if
not specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listvisu():
    &#34;&#34;&#34;Return the list of currently available visualization for the
    map() function. The first one is the default output given if
    not specified.
    &#34;&#34;&#34;
    return _listvisu</code></pre>
</details>
</dd>
<dt id="coa.front.listwhat"><code class="name flex">
<span>def <span class="ident">listwhat</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently avalailable type of series available.
The first one is the default one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listwhat():
    &#34;&#34;&#34;Return the list of currently avalailable type of series available.
     The first one is the default one.
    &#34;&#34;&#34;
    return _listwhat</code></pre>
</details>
</dd>
<dt id="coa.front.listwhere"><code class="name flex">
<span>def <span class="ident">listwhere</span></span>(<span>clustered=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of available regions/subregions managed by the current database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listwhere(clustered = False):
    &#34;&#34;&#34;Get the list of available regions/subregions managed by the current database
    &#34;&#34;&#34;
    def clust():
        r = _db.geo.get_region_list()
        if isinstance(r, list):
            return r
        else:
            return sorted(r[&#39;name_region&#39;].to_list())

    if clustered:
        return clust()
    else:
        if _db.db_world == True:
            r = _db.geo.get_GeoRegion().get_countries_from_region(&#39;world&#39;)
            r = [_db.geo.to_standard(c)[0] for c in r]
        else:
            if get_db_list_dict()[_whom][1] == &#39;subregion&#39;:
                pan = _db.geo.get_subregion_list()
                r = list(pan.name_subregion.unique())
            else:
                r = clust()
        return r</code></pre>
</details>
</dd>
<dt id="coa.front.listwhich"><code class="name flex">
<span>def <span class="ident">listwhich</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get which are the available fields for the current base.
Output is a list of string.
By default, the listwhich()[0] is the default which field in other
functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listwhich():
    &#34;&#34;&#34;Get which are the available fields for the current base.
    Output is a list of string.
    By default, the listwhich()[0] is the default which field in other
    functions.
    &#34;&#34;&#34;
    return _db.get_available_keys_words()</code></pre>
</details>
</dd>
<dt id="coa.front.listwhom"><code class="name flex">
<span>def <span class="ident">listwhom</span></span>(<span>detailed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of currently avalailable databases for covid19
data in PyCoA.
The first one is the default one.</p>
<p>If detailed=True, gives information location of each given database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listwhom(detailed=False):
    &#34;&#34;&#34;Return the list of currently avalailable databases for covid19
     data in PyCoA.
     The first one is the default one.

     If detailed=True, gives information location of each given database.
    &#34;&#34;&#34;
    try:
        if int(detailed):
            df = pd.DataFrame(get_db_list_dict())
            df = df.T.reset_index()
            df.index = df.index+1
            df = df.rename(columns={&#39;index&#39;:&#39;Database&#39;,0: &#34;WW/iso3&#34;,1:&#39;Granularité&#39;,2:&#39;WW/Name&#39;})
            return df
        else:
            return _db.get_available_database()
    except:
        raise CoaKeyError(&#39;Waiting for a boolean !&#39;)</code></pre>
</details>
</dd>
<dt id="coa.front.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a map according to arguments and options.
See help(map).
- 2 types of visu are avalailable so far : bokeh or folium (see listvisu())
by default visu='bokeh'
- In the default case (i.e visu='bokeh') available option are :
- dateslider=True: a date slider is called and displayed on the right part of the map
- maplabel = text, value are displayed directly on the map
= spark, sparkline are displayed directly on the map
= tickmap%, colormap tick are in %</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@chartsinput_deco
def map(**kwargs):
    &#34;&#34;&#34;
    Create a map according to arguments and options.
    See help(map).
    - 2 types of visu are avalailable so far : bokeh or folium (see listvisu())
    by default visu=&#39;bokeh&#39;
    - In the default case (i.e visu=&#39;bokeh&#39;) available option are :
        - dateslider=True: a date slider is called and displayed on the right part of the map
        - maplabel = text, value are displayed directly on the map
                   = spark, sparkline are displayed directly on the map
                   = tickmap%, colormap tick are in %
    &#34;&#34;&#34;
    visu = kwargs.get(&#39;visu&#39;, listvisu()[0])
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    dateslider = kwargs.get(&#39;dateslider&#39;, None)
    maplabel = kwargs.get(&#39;maplabel&#39;, None)

    if maplabel is not None:
        if not isinstance(maplabel,list):
            maplabel = [maplabel]
        if  not all([a for a in maplabel if a not in [&#39;text&#39;,&#39;spark&#39;,&#39;tickmap%&#39;] ]):
            raise CoaTypeError(&#39;Waiting a correct maplabel value. See help.&#39;)

    sparkline = False
    if dateslider is not None:
        del kwargs[&#39;dateslider&#39;]
        kwargs[&#39;cursor_date&#39;] = dateslider
    if maplabel is not None:
        kwargs[&#39;maplabel&#39;] = []
        if &#39;text&#39; in maplabel:
            kwargs[&#39;maplabel&#39;].append(&#39;text&#39;)
            if &#39;tickmap%&#39; in maplabel:
                kwargs[&#39;maplabel&#39;].append(&#39;tickmap%&#39;)
        elif &#39;spark&#39; in maplabel:
            sparkline = True
        else:
            raise CoaTypeError(&#39;Waiting for a valide label visualisation: text, spark or tickmap%&#39;)

    if visu == &#39;bokeh&#39;:
        if sparkline == False:
            return show(_cocoplot.pycoa_map(input, input_field, **kwargs))
        else:
            return show(_cocoplot.pycoa_sparkmap(input, input_field, **kwargs))
    elif visu == &#39;folium&#39;:
        if dateslider or maplabel:
            raise CoaKeyError(&#39;Not available with folium map, you should considere to use bokeh map visu in this case&#39;)
        return _cocoplot.pycoa_mapfolium(input, input_field, **kwargs)
    else:
        raise CoaTypeError(&#39;Waiting for a valid visualisation. So far: \&#39;bokeh\&#39; or \&#39;folium\&#39;.See help.&#39;)</code></pre>
</details>
</dd>
<dt id="coa.front.merger"><code class="name flex">
<span>def <span class="ident">merger</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two or more pycoa pandas from get_stats operation
'coapandas': list (min 2D) of pandas from stats
'whichcol': list variable associate to the coapandas list to be retrieve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merger(**kwargs):
    &#39;&#39;&#39;
    Merge two or more pycoa pandas from get_stats operation
    &#39;coapandas&#39;: list (min 2D) of pandas from stats
    &#39;whichcol&#39;: list variable associate to the coapandas list to be retrieve
    &#39;&#39;&#39;
    global _db
    kwargs_test(kwargs,[&#39;coapandas&#39;, &#39;whichcol&#39;], &#39;Bad args used in the pycoa.merger function.&#39;)
    listpandy = kwargs.get(&#39;coapandas&#39;,[])
    listcol = kwargs.get(&#39;whichcol&#39;,[])
    if len(listpandy)==0 or len(listcol)==0:
       raise CoaKeyError(&#39;List of pandas / List of columns keep  is mandatory there is not default !&#39;)
    else:
       return _db.merger(coapandas = listpandy,whichcol = listcol)</code></pre>
</details>
</dd>
<dt id="coa.front.normbypop"><code class="name flex">
<span>def <span class="ident">normbypop</span></span>(<span>pandy, val2norm, bypop)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pandas with a normalisation column add by population
* can normalize by '100', '1k', '100k' or '1M'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normbypop(pandy, val2norm,bypop):
    &#34;&#34;&#34;
        Return a pandas with a normalisation column add by population
        * can normalize by &#39;100&#39;, &#39;1k&#39;, &#39;100k&#39; or &#39;1M&#39;
    &#34;&#34;&#34;
    global _gi
    if isinstance(pandy[&#39;codelocation&#39;].iloc[0],list):
        pandy = pandy.explode(&#39;codelocation&#39;)

    if _db.db_world == True:
        if not isinstance(_gi,coa.geo.GeoInfo):
            _gi = coge.GeoInfo()
        pop_field=&#39;population&#39;
        pandy = _gi.add_field(input=pandy,field=pop_field,geofield=&#39;codelocation&#39;)
    else:
        if not isinstance(_gi,coa.geo.GeoCountry):
            _gi=None
        else:
            if _gi.get_country() != _db.geo.get_country():
                _gi=None

        if _gi == None :
            _gi = _db.geo
        pop_field=&#39;population_subregion&#39;
        if pop_field not in _gi.get_list_properties():
            raise CoaKeyError(&#39;The population information not available for this country. No normalization possible&#39;)

        pandy=_gi.add_field(input=pandy,field=pop_field,input_key=&#39;codelocation&#39;)

    clust = pandy[&#39;clustername&#39;].unique()
    df = pd.DataFrame()
    for i in clust:
        pandyi = pandy.loc[ pandy[&#39;clustername&#39;] == i ].copy()
        pandyi.loc[:,pop_field] = pandyi.groupby(&#39;codelocation&#39;)[pop_field].first().sum()
        cody = [pandyi.groupby(&#39;codelocation&#39;)[&#39;codelocation&#39;].first().tolist()]*len(pandyi)
        pandyi = pandyi.assign(codelocation=cody)
        if df.empty:
            df = pandyi
        else:
            df = df.append(pandyi)
    df = df.drop_duplicates([&#39;date&#39;,&#39;clustername&#39;])
    pandy = df

    pandy=pandy.copy()
    pandy[pop_field]=pandy[pop_field].replace(0., np.nan)
    pandy.loc[:,val2norm+&#39; per &#39;+bypop]=pandy[val2norm]/pandy[pop_field]*_dict_bypop[bypop]
    return pandy</code></pre>
</details>
</dd>
<dt id="coa.front.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a date plot according to arguments. See help(plot).
Keyword Arguments</p>
<hr>
<p>where (mandatory), what, which, whom, when : (see help(get))</p>
<p>input
&ndash;
input data to plot within the pycoa framework (e.g.
after some analysis or filtering). Default is None which
means that we use the basic raw data through the get
function.
When the 'input' keyword is set, where, what, which,
whom when keywords are ignored.
input should be given as valid pycoa pandas dataframe.</p>
<p>input_field &ndash;
is the name of the field of the input pandas to plot.
Default is 'deaths/cumul', the default output field of
the get() function.</p>
<p>width_height : width and height of the picture .
If specified should be a list of width and height. For instance width_height=[400,500]</p>
<p>title
&ndash;
to force the title of the plot</p>
<p>typeofplot
&ndash; 'date' (default), 'menulocation' or 'versus'
'date':date plot
'menulocation': date plot with two scroll menu locations.
Usefull to study the behaviour of a variable for two different countries.
'versus': plot variable against an other one.
For this type of plot one should used 'input' and 'input_field' (not fully tested).
Moreover dim(input_field) must be 2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@chartsinput_deco
def plot(**kwargs):
    &#34;&#34;&#34;
    Create a date plot according to arguments. See help(plot).
    Keyword arguments
    -----------------

    where (mandatory), what, which, whom, when : (see help(get))

    input       --  input data to plot within the pycoa framework (e.g.
                    after some analysis or filtering). Default is None which
                    means that we use the basic raw data through the get
                    function.
                    When the &#39;input&#39; keyword is set, where, what, which,
                    whom when keywords are ignored.
                    input should be given as valid pycoa pandas dataframe.

    input_field --  is the name of the field of the input pandas to plot.
                    Default is &#39;deaths/cumul&#39;, the default output field of
                    the get() function.

    width_height : width and height of the picture .
                If specified should be a list of width and height. For instance width_height=[400,500]

    title       --  to force the title of the plot

    typeofplot  -- &#39;date&#39; (default), &#39;menulocation&#39; or &#39;versus&#39;
                   &#39;date&#39;:date plot
                   &#39;menulocation&#39;: date plot with two scroll menu locations.
                                    Usefull to study the behaviour of a variable for two different countries.
                   &#39;versus&#39;: plot variable against an other one.
                             For this type of plot one should used &#39;input&#39; and &#39;input_field&#39; (not fully tested).
                             Moreover dim(input_field) must be 2.

    &#34;&#34;&#34;
    input = kwargs.pop(&#39;input&#39;)
    input_field = kwargs.pop(&#39;input_field&#39;)
    typeofplot = kwargs.get(&#39;typeofplot&#39;, &#39;date&#39;)

    if &#39;typeofplot&#39; in kwargs:
        typeofplot = kwargs.pop(&#39;typeofplot&#39;)
    if typeofplot == &#39;date&#39;:
        fig = _cocoplot.pycoa_date_plot(input,input_field, **kwargs)
    elif typeofplot == &#39;versus&#39;:
        if input_field is not None and len(input_field) == 2:
            fig = _cocoplot.pycoa_plot(input, input_field,**kwargs)
        else:
            print(&#39;typeofplot is versus but dim(input_field)!=2, versus has not effect ...&#39;)
            fig = _cocoplot.pycoa_date_plot(input, input_field, **kwargs)
    elif typeofplot == &#39;menulocation&#39;:
        if input_field is not None and len(input_field) &gt; 1:
            print(&#39;typeofplot is menulocation but dim(input_field)&gt;1, menulocation has not effect ...&#39;)
        fig = _cocoplot.pycoa_scrollingmenu(input, input_field, **kwargs)
    else:
        raise CoaKeyError(&#39;Unknown typeofplot value. Should be date, versus or menulocation.&#39;)
    show(fig)</code></pre>
</details>
</dd>
<dt id="coa.front.saveoutput"><code class="name flex">
<span>def <span class="ident">saveoutput</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Export pycoas pandas as an output file selected by output argument
'pandas': pandas to save
'saveformat': excel (default) or csv
'savename': None (default pycoaout+ '.xlsx/.csv')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveoutput(**kwargs):
    &#39;&#39;&#39;
        Export pycoas pandas as an output file selected by output argument
        &#39;pandas&#39;: pandas to save
        &#39;saveformat&#39;: excel (default) or csv
        &#39;savename&#39;: None (default pycoaout+ &#39;.xlsx/.csv&#39;)
    &#39;&#39;&#39;
    global _db
    kwargs_test(kwargs, [&#39;pandas&#39;,&#39;saveformat&#39;,&#39;savename&#39;], &#39;Bad args used in the pycoa.saveoutput function.&#39;)
    pandy = kwargs.get(&#39;pandas&#39;, pd.DataFrame())
    saveformat = kwargs.get(&#39;saveformat&#39;, &#39;excel&#39;)
    savename = kwargs.get(&#39;savename&#39;, &#39;&#39;)
    if pandy.empty:
        raise CoaKeyError(&#39;Pandas to save is mandatory there is not default !&#39;)
    else:
        _db.saveoutput(pandas=pandy,saveformat=saveformat,savename=savename)</code></pre>
</details>
</dd>
<dt id="coa.front.setwhom"><code class="name flex">
<span>def <span class="ident">setwhom</span></span>(<span>base)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the covid19 database used, given as a string.
Please see pycoa.listbase() for the available current list.</p>
<p>By default, the listbase()[0] is the default base used in other
functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setwhom(base):
    &#34;&#34;&#34;Set the covid19 database used, given as a string.
    Please see pycoa.listbase() for the available current list.

    By default, the listbase()[0] is the default base used in other
    functions.
    &#34;&#34;&#34;
    global _whom, _db, _cocoplot
    if base not in listwhom():
        raise CoaDbError(base + &#39; is not a supported database. &#39;
                                &#39;See pycoa.listbase() for the full list.&#39;)
    if True:  # force the init #_whom != base:
        _db, _cocoplot = coco.DataBase.factory(base)
        _whom = base

    return listwhich()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#about">About :</a></li>
<li><a href="#basic-usage">Basic usage</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coa" href="index.html">coa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="coa.front.chartsinput_deco" href="#coa.front.chartsinput_deco">chartsinput_deco</a></code></li>
<li><code><a title="coa.front.get" href="#coa.front.get">get</a></code></li>
<li><code><a title="coa.front.getinfo" href="#coa.front.getinfo">getinfo</a></code></li>
<li><code><a title="coa.front.getversion" href="#coa.front.getversion">getversion</a></code></li>
<li><code><a title="coa.front.getwhom" href="#coa.front.getwhom">getwhom</a></code></li>
<li><code><a title="coa.front.hist" href="#coa.front.hist">hist</a></code></li>
<li><code><a title="coa.front.listbypop" href="#coa.front.listbypop">listbypop</a></code></li>
<li><code><a title="coa.front.listoption" href="#coa.front.listoption">listoption</a></code></li>
<li><code><a title="coa.front.listoutput" href="#coa.front.listoutput">listoutput</a></code></li>
<li><code><a title="coa.front.listtile" href="#coa.front.listtile">listtile</a></code></li>
<li><code><a title="coa.front.listvisu" href="#coa.front.listvisu">listvisu</a></code></li>
<li><code><a title="coa.front.listwhat" href="#coa.front.listwhat">listwhat</a></code></li>
<li><code><a title="coa.front.listwhere" href="#coa.front.listwhere">listwhere</a></code></li>
<li><code><a title="coa.front.listwhich" href="#coa.front.listwhich">listwhich</a></code></li>
<li><code><a title="coa.front.listwhom" href="#coa.front.listwhom">listwhom</a></code></li>
<li><code><a title="coa.front.map" href="#coa.front.map">map</a></code></li>
<li><code><a title="coa.front.merger" href="#coa.front.merger">merger</a></code></li>
<li><code><a title="coa.front.normbypop" href="#coa.front.normbypop">normbypop</a></code></li>
<li><code><a title="coa.front.plot" href="#coa.front.plot">plot</a></code></li>
<li><code><a title="coa.front.saveoutput" href="#coa.front.saveoutput">saveoutput</a></code></li>
<li><code><a title="coa.front.setwhom" href="#coa.front.setwhom">setwhom</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>