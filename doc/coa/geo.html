<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>coa.geo API documentation</title>
<meta name="description" content="Project : PyCoA
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coa.geo</code></h1>
</header>
<section id="section-intro">
<p>Project : PyCoA
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint LICENSE file</p>
<p>Module : coa.geo</p>
<h2 id="about">About :</h2>
<p>Geo classes within the PyCoA framework.</p>
<p>GeoManager class provides translations between naming normalisations
of countries. It's based on the pycountry module.</p>
<p>GeoInfo class allow to add new fields to a pandas DataFrame about
statistical information for countries.</p>
<p>GeoRegion class helps returning list of countries in a specified region</p>
<p>GeoCountry manages information for a single country.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34; Project : PyCoA
Date :    april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint LICENSE file

Module : coa.geo

About :
-------

Geo classes within the PyCoA framework.

GeoManager class provides translations between naming normalisations
of countries. It&#39;s based on the pycountry module.

GeoInfo class allow to add new fields to a pandas DataFrame about
statistical information for countries.

GeoRegion class helps returning list of countries in a specified region

GeoCountry manages information for a single country.
&#34;&#34;&#34;

import inspect  # for debug purpose

import warnings

import pycountry as pc
import pycountry_convert as pcc
import pandas as pd
import geopandas as gpd
import shapely.geometry as sg
import shapely.affinity as sa
import shapely.ops as so
import bs4

from coa.tools import verb,kwargs_test,get_local_from_url,dotdict,tostdstring
from coa.error import *

# ---------------------------------------------------------------------
# --- GeoManager class ------------------------------------------------
# ---------------------------------------------------------------------

class GeoManager():
    &#34;&#34;&#34;GeoManager class definition. No inheritance from any other class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _list_standard=[&#39;iso2&#39;,   # Iso2 standard, default
            &#39;iso3&#39;,           # Iso3 standard
            &#39;name&#39;,           # Standard name ( != Official, caution )
            &#39;num&#39;]            # Numeric standard

    _list_db=[None,&#39;jhu&#39;,&#39;worldometers&#39;,&#39;owid&#39;,&#39;opencovid19national&#39;,&#39;spfnational&#39;] # first is default
    _list_output=[&#39;list&#39;,&#39;dict&#39;,&#39;pandas&#39;] # first is default

    _standard = None # currently used normalisation standard

    def __init__(self,standard=_list_standard[0]):
        &#34;&#34;&#34; __init__ member function, with default definition of
        the used standard. To get the current default standard,
        see get_list_standard()[0].
        &#34;&#34;&#34;
        verb(&#34;Init of GeoManager() from &#34;+str(inspect.stack()[1]))
        self.set_standard(standard)
        self._gr=GeoRegion()

    def get_GeoRegion(self):
        &#34;&#34;&#34; return the GeoRegion local instance
        &#34;&#34;&#34;
        return self._gr

    def get_region_list(self):
        &#34;&#34;&#34; return the list of region via the GeoRegion instance
        &#34;&#34;&#34;
        return self._gr.get_region_list()

    def get_list_standard(self):
        &#34;&#34;&#34; return the list of supported standard name of countries.
        First one is default for the class
        &#34;&#34;&#34;
        return self._list_standard

    def get_list_output(self):
        &#34;&#34;&#34; return supported list of output type. First one is default
        for the class
        &#34;&#34;&#34;
        return self._list_output

    def get_list_db(self):
        &#34;&#34;&#34; return supported list of database name for translation of
        country names to standard.
        &#34;&#34;&#34;
        return self._list_db

    def get_standard(self):
        &#34;&#34;&#34; return current standard use within the GeoManager class
        &#34;&#34;&#34;
        return self._standard

    def set_standard(self,standard):
        &#34;&#34;&#34;
        set the working standard type within the GeoManager class.
        The standard should meet the get_list_standard() requirement
        &#34;&#34;&#34;
        if not isinstance(standard,str):
            raise CoaTypeError(&#39;GeoManager error, the standard argument&#39;
                &#39; must be a string&#39;)
        if standard not in self.get_list_standard():
            raise CoaKeyError(&#39;GeoManager.set_standard error, &#34;&#39;+\
                                    standard+&#39; not managed. Please see &#39;\
                                    &#39;get_list_standard() function&#39;)
        self._standard=standard
        return self.get_standard()

    def to_standard(self, w, **kwargs):
        &#34;&#34;&#34;Given a list of string of locations (countries), returns a
        normalised list according to the used standard (defined
        via the setStandard() or __init__ function. Current default is iso2.

        Arguments
        -----------------
        first arg        --  w, list of string of locations (or single string)
                             to convert to standard one

        output           -- &#39;list&#39; (default), &#39;dict&#39; or &#39;pandas&#39;
        db               -- database name to help conversion.
                            Default : None, meaning best effort to convert.
                            Known database : jhu, wordometer...
                            See get_list_db() for full list of known db for
                            standardization
        interpret_region -- Boolean, default=False. If yes, the output should
                            be only &#39;list&#39;.
        &#34;&#34;&#34;

        kwargs_test(kwargs,[&#39;output&#39;,&#39;db&#39;,&#39;interpret_region&#39;],&#39;Bad args used in the to_standard() function.&#39;)

        output=kwargs.get(&#39;output&#39;,self.get_list_output()[0])
        if output not in self.get_list_output():
            raise CoaKeyError(&#39;Incorrect output type. See get_list_output()&#39;
                &#39; or help.&#39;)

        db=kwargs.get(&#39;db&#39;,self.get_list_db()[0])
        if db not in self.get_list_db():
            raise CoaDbError(&#39;Unknown database &#34;&#39;+db+&#39;&#34; for translation to &#39;
                &#39;standardized location names. See get_list_db() or help.&#39;)

        interpret_region=kwargs.get(&#39;interpret_region&#39;,False)
        if not isinstance(interpret_region,bool):
            raise CoaTypeError(&#39;The interpret_region argument is a boolean, &#39;
                &#39;not a &#39;+str(type(interpret_region)))

        if interpret_region==True and output!=&#39;list&#39;:
            raise CoaKeyError(&#39;The interpret_region True argument is incompatible &#39;
                &#39;with non list output option.&#39;)

        if isinstance(w,str):
            w=[w]
        elif not isinstance(w,list):
            raise CoaTypeError(&#39;Waiting for str, list of str or pandas&#39;
                &#39;as input of get_standard function member of GeoManager&#39;)

        w=[v.title() for v in w] # capitalize first letter of each name

        w0=w.copy()

        if db:
            w=self.first_db_translation(w,db)
        n=[] # will contain standardized name of countries (if possible)

        #for c in w:
        while len(w)&gt;0:
            c=w.pop(0)
            if type(c)==int:
                c=str(c)
            elif type(c)!=str:
                raise CoaTypeError(&#39;Locations should be given as &#39;
                    &#39;strings or integers only&#39;)
            if (c in self._gr.get_region_list()) and interpret_region == True:
                w=self._gr.get_countries_from_region(c)+w
            else:
                if len(c)==0:
                    n1=&#39;&#39; #None
                else:
                    try:
                        n0=pc.countries.lookup(c)
                    except LookupError:
                        try:
                            if c.startswith(&#39;Owid_&#39;):
                                nf=[&#39;owid_*&#39;]
                                n1=&#39;OWID_*&#39;
                            else:
                                nf=pc.countries.search_fuzzy(c)
                            if len(nf)&gt;1:
                                warnings.warn(&#39;Caution. More than one country match the key &#34;&#39;+\
                                c+&#39;&#34; : &#39;+str([ (k.name+&#39;, &#39;) for k in nf])+\
                                &#39;, using first one.\n&#39;)
                            n0=nf[0]
                        except LookupError:
                            raise CoaLookupError(&#39;No country match the key &#34;&#39;+c+&#39;&#34;. Error.&#39;)
                        except Exception as e1:
                            raise CoaNotManagedError(&#39;Not managed error &#39;+type(e1))
                    except Exception as e2:
                        raise CoaNotManagedError(&#39;Not managed error&#39;+type(e1))

                    if n0 != &#39;owid_*&#39;:
                        if self._standard==&#39;iso2&#39;:
                            n1=n0.alpha_2
                        elif self._standard==&#39;iso3&#39;:
                            n1=n0.alpha_3
                        elif self._standard==&#39;name&#39;:
                            n1=n0.name
                        elif self._standard==&#39;num&#39;:
                            n1=n0.numeric
                        else:
                            raise CoaKeyError(&#39;Current standard is &#39;+self._standard+\
                                &#39; which is not managed. Error.&#39;)

                n.append(n1)

        if output==&#39;list&#39;:
            return n
        elif output==&#39;dict&#39;:
            return dict(zip(w0, n))
        elif output==&#39;pandas&#39;:
            return pd.DataFrame({&#39;inputname&#39;:w0,self._standard:n})
        else:
            return None # should not be here

    def first_db_translation(self,w,db):
        &#34;&#34;&#34; This function helps to translate from country name to
        standard for specific databases. It&#39;s the first step
        before final translation.

        One can easily add some database support adding some new rules
        for specific databases
        &#34;&#34;&#34;
        translation_dict={}
        # Caution : keys need to be in title mode, i.e. first letter capitalized
        if db==&#39;jhu&#39;:
            translation_dict.update({\
                &#34;Congo (Brazzaville)&#34;:&#34;Republic of the Congo&#34;,\
                &#34;Congo (Kinshasa)&#34;:&#34;COD&#34;,\
                &#34;Korea, South&#34;:&#34;KOR&#34;,\
                &#34;Taiwan*&#34;:&#34;Taiwan&#34;,\
                &#34;Laos&#34;:&#34;LAO&#34;,\
                &#34;West Bank And Gaza&#34;:&#34;PSE&#34;,\
                &#34;Burma&#34;:&#34;Myanmar&#34;,\
                &#34;Iran&#34;:&#34;IRN&#34;,\
                &#34;Diamond Princess&#34;:&#34;&#34;,\
                &#34;Ms Zaandam&#34;:&#34;&#34;,\
                &#34;Summer Olympics 2020&#34;:&#34;&#34;,\
                &#34;Micronesia&#34;:&#34;FSM&#34;,\
                    })  # last two are names of boats
        elif db==&#39;worldometers&#39;:
            translation_dict.update({\
                &#34;Dr Congo&#34;:&#34;COD&#34;,\
                &#34;Congo&#34;:&#34;COG&#34;,\
                &#34;Iran&#34;:&#34;IRN&#34;,\
                &#34;South Korea&#34;:&#34;KOR&#34;,\
                &#34;North Korea&#34;:&#34;PRK&#34;,\
                &#34;Czech Republic (Czechia)&#34;:&#34;CZE&#34;,\
                &#34;Laos&#34;:&#34;LAO&#34;,\
                &#34;Sao Tome &amp; Principe&#34;:&#34;STP&#34;,\
                &#34;Channel Islands&#34;:&#34;JEY&#34;,\
                &#34;St. Vincent &amp; Grenadines&#34;:&#34;VCT&#34;,\
                &#34;U.S. Virgin Islands&#34;:&#34;VIR&#34;,\
                &#34;Saint Kitts &amp; Nevis&#34;:&#34;KNA&#34;,\
                &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                &#34;Caribbean Netherlands&#34;:&#34;BES&#34;,\
                &#34;Wallis &amp; Futuna&#34;:&#34;WLF&#34;,\
                &#34;Saint Pierre &amp; Miquelon&#34;:&#34;SPM&#34;,\
                &#34;Sint Maarten&#34;:&#34;SXM&#34;,\
                } )
        elif db==&#39;owid&#39;:
            translation_dict.update({\
                    &#34;Bonaire Sint Eustatius And Saba&#34;:&#34;BES&#34;,\
                    &#34;Cape Verde&#34;:&#34;CPV&#34;,\
                    &#34;Democratic Republic Of Congo&#34;:&#34;COD&#34;,\
                    &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                    &#34;Laos&#34;:&#34;LAO&#34;,\
                    &#34;South Korea&#34;:&#34;KOR&#34;,\
                    &#34;Swaziland&#34;:&#34;SWZ&#34;,\
                    &#34;United States Virgin Islands&#34;:&#34;VIR&#34;,\
                    &#34;Iran&#34;:&#34;IRN&#34;,\
                    &#34;Micronesia (Country)&#34;:&#34;FSM&#34;,\
                    &#34;Northern Cyprus&#34;:&#34;CYP&#34;,\
                    &#34;Curacao&#34;:&#34;CUW&#34;,\
                    &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                    &#34;Vatican&#34;:&#34;VAT&#34;
                })
        return [translation_dict.get(k,k) for k in w]

# ---------------------------------------------------------------------
# --- GeoInfo class ---------------------------------------------------
# ---------------------------------------------------------------------

class GeoInfo():
    &#34;&#34;&#34;GeoInfo class definition. No inheritance from any other class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _list_field={\
        &#39;continent_code&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39;,\
        &#39;continent_name&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39; ,\
        &#39;country_name&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39; ,\
        &#39;population&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;area&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;fertility&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;median_age&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;urban_rate&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        #&#39;geometry&#39;:&#39;https://github.com/johan/world.geo.json/&#39;,\
        &#39;geometry&#39;:&#39;http://thematicmapping.org/downloads/world_borders.php and https://github.com/johan/world.geo.json/&#39;,\
        &#39;region_code_list&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;region_name_list&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;capital&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;flag&#39;:&#39;https://github.com/linssen/country-flag-icons/blob/master/countries.json&#39;,\
        }

    _data_geometry = pd.DataFrame()
    _data_population = pd.DataFrame()
    _data_flag = pd.DataFrame()

    def __init__(self,gm=0):
        &#34;&#34;&#34; __init__ member function.
        &#34;&#34;&#34;
        verb(&#34;Init of GeoInfo() from &#34;+str(inspect.stack()[1]))
        if gm != 0:
            self._gm=gm
        else:
            self._gm=GeoManager()

        self._grp=self._gm._gr.get_pandas()

    def get_GeoManager(self):
        &#34;&#34;&#34; return the local instance of used GeoManager()
        &#34;&#34;&#34;
        return self._gm

    def get_list_field(self):
        &#34;&#34;&#34; return the list of supported additionnal fields available
        &#34;&#34;&#34;
        return sorted(list(self._list_field.keys()))

    def get_source(self,field=None):
        &#34;&#34;&#34; return the source of the information provided for a given
        field.
        &#34;&#34;&#34;
        if field==None:
            return self._list_field
        elif field not in self.get_list_field():
            raise CoaKeyError(&#39;The field &#34;&#39;+str(field)+&#39;&#34; is not &#39;
                &#39;a supported field of GeoInfo(). Please see help or &#39;
                &#39;the get_list_field() output.&#39;)
        return field+&#39; : &#39;+self._list_field[field]


    def add_field(self,**kwargs):
        &#34;&#34;&#34; this is the main function of the GeoInfo class. It adds to
        the input pandas dataframe some fields according to
        the geofield field of input.
        The return value is the pandas dataframe.

        Arguments :
        field    -- should be given as a string of list of strings and
                    should be valid fields (see get_list_field() )
                    Mandatory.
        input    -- provide the input pandas dataframe. Mandatory.
        geofield -- provide the field name in the pandas where the
                    location is stored. Default : &#39;location&#39;
        overload -- Allow to overload a field. Boolean value.
                    Default : False
        &#34;&#34;&#34;

        # --- kwargs analysis ---

        kwargs_test(kwargs,[&#39;field&#39;,&#39;input&#39;,&#39;geofield&#39;,&#39;overload&#39;],
            &#39;Bad args used in the add_field() function.&#39;)

        p=kwargs.get(&#39;input&#39;,None) # the panda
        if not isinstance(p,pd.DataFrame):
            raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
                &#39; DataFrame as input. See help.&#39;)
        p=p.copy()

        overload=kwargs.get(&#39;overload&#39;,False)
        if not isinstance(overload,bool):
            raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

        fl=kwargs.get(&#39;field&#39;,None) # field list
        if fl == None:
            raise CoaKeyError(&#39;No field given. See help.&#39;)
        if not isinstance(fl,list):
            fl=[fl]
        if not all(f in self.get_list_field() for f in fl):
            raise CoaKeyError(&#39;All fields are not valid or supported &#39;
                &#39;ones. Please see help of get_list_field()&#39;)

        if not overload and not all(f not in p.columns.tolist() for f in fl):
            raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
                &#39;dataframe columns. You may set overload to True.&#39;)

        geofield=kwargs.get(&#39;geofield&#39;,&#39;location&#39;)

        if not isinstance(geofield,str):
            raise CoaTypeError(&#39;The geofield should be given as a &#39;
                &#39;string.&#39;)
        if geofield not in p.columns.tolist():
            raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
                &#39;not a valid column name of the input pandas dataframe.&#39;)

        self._gm.set_standard(&#39;iso2&#39;)
        countries_iso2=self._gm.to_standard(p[geofield].tolist())
        self._gm.set_standard(&#39;iso3&#39;)
        countries_iso3=self._gm.to_standard(p[geofield].tolist())

        p[&#39;iso2_tmp&#39;]=countries_iso2
        p[&#39;iso3_tmp&#39;]=countries_iso3

        # --- loop over all needed fields ---
        for f in fl:
            if f in p.columns.tolist():
                p=p.drop(f,axis=1)
            # ----------------------------------------------------------
            if f == &#39;continent_code&#39;:
                p[f] = [pcc.country_alpha2_to_continent_code(k) for k in countries_iso2]
            # ----------------------------------------------------------
            elif f == &#39;continent_name&#39;:
                p[f] = [pcc.convert_continent_code_to_continent_name( \
                    pcc.country_alpha2_to_continent_code(k) ) for k in countries_iso2 ]
            # ----------------------------------------------------------
            elif f == &#39;country_name&#39;:
                p[f] = [pcc.country_alpha2_to_country_name(k) for k in countries_iso2]
            # ----------------------------------------------------------
            elif f in [&#39;population&#39;,&#39;area&#39;,&#39;fertility&#39;,&#39;median_age&#39;,&#39;urban_rate&#39;]:
                if self._data_population.empty:

                    field_descr=( (0,&#39;&#39;,&#39;idx&#39;),
                        (1,&#39;Country&#39;,&#39;country&#39;),
                        (2,&#39;Population&#39;,&#39;population&#39;),
                        (6,&#39;Land Area&#39;,&#39;area&#39;),
                        (8,&#39;Fert&#39;,&#39;fertility&#39;),
                        (9,&#39;Med&#39;,&#39;median_age&#39;),
                        (10,&#39;Urban&#39;,&#39;urban_rate&#39;),
                        ) # containts tuples with position in table, name of column, new name of field

                    # get data with cache ok for about 1 month
                    self._data_population = pd.read_html(get_local_from_url(&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,30e5) ) [0].iloc[:,[x[0] for x in field_descr]]

                    # test that field order hasn&#39;t changed in the db
                    if not all (col.startswith(field_descr[i][1]) for i,col in enumerate(self._data_population.columns) ):
                        raise CoaDbError(&#39;The worldometers database changed its field names. &#39;
                            &#39;The GeoInfo should be updated. Please contact developers.&#39;)

                    # change field name
                    self._data_population.columns = [x[2] for x in field_descr]

                    # standardization of country name
                    self._data_population[&#39;iso3_tmp2&#39;]=\
                        self._gm.to_standard(self._data_population[&#39;country&#39;].tolist(),\
                        db=&#39;worldometers&#39;)

                p=p.merge(self._data_population[[&#34;iso3_tmp2&#34;,f]],how=&#39;left&#39;,\
                        left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3_tmp2&#39;,\
                        suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;iso3_tmp2&#39;],axis=1)

            # ----------------------------------------------------------
            elif f in [&#39;region_code_list&#39;,&#39;region_name_list&#39;]:

                if f == &#39;region_code_list&#39;:
                    ff = &#39;region&#39;
                elif f == &#39;region_name_list&#39;:
                    ff = &#39;region_name&#39;

                p[f]=p.merge(self._grp[[&#39;iso3&#39;,ff]],how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;)) \
                    .groupby(&#39;iso3_tmp&#39;)[ff].apply(list).to_list()
            # ----------------------------------------------------------
            elif f in [&#39;capital&#39;]:
                p[f]=p.merge(self._grp[[&#39;iso3&#39;,f]].drop_duplicates(), \
                    how=&#39;left&#39;,left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;))[f]

            # ----------------------------------------------------------
            elif f == &#39;geometry&#39;:
                if self._data_geometry.empty:
                    #geojsondatafile = &#39;https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json&#39;
                    #self._data_geometry = gpd.read_file(get_local_from_url(geojsondatafile,0,&#39;.json&#39;))[[&#34;id&#34;,&#34;geometry&#34;]]
                    world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip&#39; # too much simplified version ?
                    # world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip&#39; # too precize version ?
                    self._data_geometry = gpd.read_file(&#39;zip://&#39;+get_local_from_url(world_geometry_url_zipfile,0,&#39;.zip&#39;))[[&#39;ISO3&#39;,&#39;geometry&#39;]]
                    self._data_geometry.columns=[&#34;id_tmp&#34;,&#34;geometry&#34;]

                    # About some countries not properly managed by this database (south and north soudan)
                    self._data_geometry=self._data_geometry.append({&#39;id_tmp&#39;:&#39;SSD&#39;,&#39;geometry&#39;:None},ignore_index=True) # adding the SSD row
                    for newc in [&#39;SSD&#39;,&#39;SDN&#39;]:
                        newgeo=gpd.read_file(get_local_from_url(&#39;https://github.com/johan/world.geo.json/raw/master/countries/&#39;+newc+&#39;.geo.json&#39;))
                        poly=newgeo[newgeo.id==newc].geometry.values[0]
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                    # About countries that we artificially put on the east of the map
                    for newc in [&#39;RUS&#39;,&#39;FJI&#39;,&#39;NZL&#39;,&#39;WSM&#39;]:
                        poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                        poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x,y) if x&gt;=0 else (x+360,y) for x,y in p.exterior.coords]) for p in poly]))
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                    # About countries that we artificially put on the west of the map
                    for newc in [&#39;USA&#39;]:
                        poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                        poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x-360,y) if x&gt;=0 else (x,y) for x,y in p.exterior.coords]) for p in poly]))
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                p=p.merge(self._data_geometry,how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;id_tmp&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;id_tmp&#39;],axis=1)

            # -----------------------------------------------------------
            elif f == &#39;flag&#39;:
                if self._data_flag.empty:
                    self._data_flag = pd.read_json(get_local_from_url(&#39;https://github.com/linssen/country-flag-icons/raw/master/countries.json&#39;,0))
                    self._data_flag[&#39;flag_url&#39;]=&#39;http:&#39;+self._data_flag[&#39;file_url&#39;]

                p=p.merge(self._data_flag[[&#39;alpha3&#39;,&#39;flag_url&#39;]],how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;alpha3&#39;).drop([&#39;alpha3&#39;],axis=1)

        return p.drop([&#39;iso2_tmp&#39;,&#39;iso3_tmp&#39;],axis=1,errors=&#39;ignore&#39;)

# ---------------------------------------------------------------------
# --- GeoRegion class -------------------------------------------------
# ---------------------------------------------------------------------

class GeoRegion():
    &#34;&#34;&#34;GeoRegion class definition. Does not inheritate from any other
    class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _source_dict={&#34;UN_M49&#34;:&#34;https://en.wikipedia.org/w/index.php?title=UN_M49&amp;oldid=986603718&#34;, # pointing the previous correct ref . https://en.wikipedia.org/wiki/UN_M49&#34;,\
        &#34;GeoScheme&#34;:&#34;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#34;, #pointing the previous correct ref. https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#34;,
        &#34;European Union&#34;:&#34;https://europa.eu/european-union/about-eu/countries/member-countries_en&#34;,
        &#34;G7&#34;:&#34;https://en.wikipedia.org/wiki/Group_of_Seven&#34;,
        &#34;G8&#34;:&#34;https://en.wikipedia.org/wiki/Group_of_Eight&#34;,
        &#34;G20&#34;:&#34;https://en.wikipedia.org/wiki/G20&#34;,
        &#34;G77&#34;:&#34;https://www.g77.org/doc/members.html&#34;,
        &#34;OECD&#34;:&#34;https://en.wikipedia.org/wiki/OECD&#34;,
        &#34;Commonwealth&#34;:&#34;https://en.wikipedia.org/wiki/Member_states_of_the_Commonwealth_of_Nations&#34;,
        }

    _region_dict={}
    _p_gs = pd.DataFrame()

    def __init__(self,):
        &#34;&#34;&#34; __init__ member function.
        &#34;&#34;&#34;
        #if &#39;XK&#39; in self._country_list:
        #    del self._country_list[&#39;XK&#39;] # creates bugs in pycountry and is currently a contested country as country


        # --- get the UN M49 information and organize the data in the _region_dict

        verb(&#34;Init of GeoRegion() from &#34;+str(inspect.stack()[1]))

        p_m49=pd.read_html(get_local_from_url(self._source_dict[&#34;UN_M49&#34;],0))[1]

        p_m49.columns=[&#39;code&#39;,&#39;region_name&#39;]
        p_m49[&#39;region_name&#39;]=[r.split(&#39;(&#39;)[0].rstrip().title() for r in p_m49.region_name]  # suppress information in parenthesis in region name
        p_m49.set_index(&#39;code&#39;)

        self._region_dict.update(p_m49.to_dict(&#39;split&#39;)[&#39;data&#39;])
        self._region_dict.update({  &#34;UE&#34;:&#34;European Union&#34;,
                                    &#34;G7&#34;:&#34;G7&#34;,
                                    &#34;G8&#34;:&#34;G8&#34;,
                                    &#34;G20&#34;:&#34;G20&#34;,
                                    &#34;OECD&#34;:&#34;Oecd&#34;,
                                    &#34;G77&#34;:&#34;G77&#34;,
                                    &#34;CW&#34;:&#34;Commonwealth&#34;
                                    })  # add UE for other analysis

        # --- filling cw information
        p_cw=pd.read_html(get_local_from_url(&#39;https://en.wikipedia.org/wiki/Member_states_of_the_Commonwealth_of_Nations&#39;))
        self._cw=[w.split(&#39;[&#39;)[0] for w in p_cw[0][&#39;Country&#39;].to_list()]   # removing wikipedia notes

        # --- get the UnitedNation GeoScheme and organize the data
        p_gs=pd.read_html(get_local_from_url(self._source_dict[&#34;GeoScheme&#34;],0))[0]
        p_gs.columns=[&#39;country&#39;,&#39;capital&#39;,&#39;iso2&#39;,&#39;iso3&#39;,&#39;num&#39;,&#39;m49&#39;]

        idx=[]
        reg=[]
        cap=[]

        for index, row in p_gs.iterrows():
            if row.iso3 != &#39;–&#39; : # meaning a non standard iso in wikipedia UN GeoScheme
                for r in row.m49.replace(&#34; &#34;,&#34;&#34;).split(&#39;&lt;&#39;):
                    idx.append(row.iso3)
                    reg.append(int(r))
                    cap.append(row.capital)
        self._p_gs=pd.DataFrame({&#39;iso3&#39;:idx,&#39;capital&#39;:cap,&#39;region&#39;:reg})
        self._p_gs=self._p_gs.merge(p_m49,how=&#39;left&#39;,left_on=&#39;region&#39;,\
                            right_on=&#39;code&#39;).drop([&#34;code&#34;],axis=1)

    def get_source(self):
        return self._source_dict

    def get_region_list(self):
        return list(self._region_dict.values())

    def is_region(self,region):
        &#34;&#34;&#34; it returns either False or the correctly named region name
        &#34;&#34;&#34;
        if type(region) != str:
            raise CoaKeyError(&#34;The given region is not a str type.&#34;)

        region=region.title()  # if not properly capitalized

        if region not in self.get_region_list():
            return False
        else :
            return region

    def get_countries_from_region(self,region):
        &#34;&#34;&#34; it returns a list of countries for the given region name.
        The standard used is iso3. To convert to another standard,
        use the GeoManager class.
        &#34;&#34;&#34;
        r = self.is_region(region)
        if not r:
            raise CoaKeyError(&#39;The given region &#34;&#39;+str(region)+&#39;&#34; is unknown.&#39;)
        region=r

        clist=[]

        if region==&#39;European Union&#39;:
            clist=[&#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
                        &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
                        &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
                        &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
        elif region==&#39;G7&#39;:
            clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;]
        elif region==&#39;G8&#39;:
            clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;,&#39;RUS&#39;]
        elif region==&#39;G20&#39;:
            clist=[&#39;ZAF&#39;,&#39;SAU&#39;,&#39;ARG&#39;,&#39;AUS&#39;,&#39;BRA&#39;,&#39;CAN&#39;,&#39;CHN&#39;,&#39;KOR&#39;,&#39;USA&#39;,\
                &#39;IND&#39;,&#39;IDN&#39;,&#39;JAP&#39;,&#39;MEX&#39;,&#39;GBR&#39;,&#39;RUS&#39;,&#39;TUR&#39;,\
                &#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
                &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
                &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
                &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
        elif region==&#39;Oecd&#39;: # OCDE in french
            clist=[&#39;DEU&#39;,&#39;AUS&#39;,&#39;AUT&#39;,&#39;BEL&#39;,&#39;CAN&#39;,&#39;CHL&#39;,&#39;COL&#39;,&#39;KOR&#39;,&#39;DNK&#39;,\
                &#39;ESP&#39;,&#39;EST&#39;,&#39;USA&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ISL&#39;,&#39;ISR&#39;,\
                &#39;ITA&#39;,&#39;JAP&#39;,&#39;LVA&#39;,&#39;LTU&#39;,&#39;LUX&#39;,&#39;MEX&#39;,&#39;NOR&#39;,&#39;NZL&#39;,&#39;NLD&#39;,&#39;POL&#39;,\
                &#39;PRT&#39;,&#39;SVK&#39;,&#39;SVN&#39;,&#39;SWE&#39;,&#39;CHE&#39;,&#39;GBR&#39;,&#39;CZE&#39;,&#39;TUR&#39;]
        elif region==&#39;G77&#39;:
            clist=[&#39;AFG&#39;,&#39;DZA&#39;,&#39;AGO&#39;,&#39;ATG&#39;,&#39;ARG&#39;,&#39;AZE&#39;,&#39;BHS&#39;,&#39;BHR&#39;,&#39;BGD&#39;,&#39;BRB&#39;,&#39;BLZ&#39;,
                &#39;BEN&#39;,&#39;BTN&#39;,&#39;BOL&#39;,&#39;BWA&#39;,&#39;BRA&#39;,&#39;BRN&#39;,&#39;BFA&#39;,&#39;BDI&#39;,&#39;CPV&#39;,&#39;KHM&#39;,&#39;CMR&#39;,
                &#39;CAF&#39;,&#39;TCD&#39;,&#39;CHL&#39;,&#39;CHN&#39;,&#39;COL&#39;,&#39;COM&#39;,&#39;COG&#39;,&#39;CRI&#39;,&#39;CIV&#39;,&#39;CUB&#39;,&#39;PRK&#39;,
                &#39;COD&#39;,&#39;DJI&#39;,&#39;DMA&#39;,&#39;DOM&#39;,&#39;ECU&#39;,&#39;EGY&#39;,&#39;SLV&#39;,&#39;GNQ&#39;,&#39;ERI&#39;,&#39;SWZ&#39;,&#39;ETH&#39;,
                &#39;FJI&#39;,&#39;GAB&#39;,&#39;GMB&#39;,&#39;GHA&#39;,&#39;GRD&#39;,&#39;GTM&#39;,&#39;GIN&#39;,&#39;GNB&#39;,&#39;GUY&#39;,&#39;HTI&#39;,&#39;HND&#39;,
                &#39;IND&#39;,&#39;IDN&#39;,&#39;IRN&#39;,&#39;IRQ&#39;,&#39;JAM&#39;,&#39;JOR&#39;,&#39;KEN&#39;,&#39;KIR&#39;,&#39;KWT&#39;,&#39;LAO&#39;,&#39;LBN&#39;,
                &#39;LSO&#39;,&#39;LBR&#39;,&#39;LBY&#39;,&#39;MDG&#39;,&#39;MWI&#39;,&#39;MYS&#39;,&#39;MDV&#39;,&#39;MLI&#39;,&#39;MHL&#39;,&#39;MRT&#39;,&#39;MUS&#39;,
                &#39;FSM&#39;,&#39;MNG&#39;,&#39;MAR&#39;,&#39;MOZ&#39;,&#39;MMR&#39;,&#39;NAM&#39;,&#39;NRU&#39;,&#39;NPL&#39;,&#39;NIC&#39;,&#39;NER&#39;,&#39;NGA&#39;,
                &#39;OMN&#39;,&#39;PAK&#39;,&#39;PAN&#39;,&#39;PNG&#39;,&#39;PRY&#39;,&#39;PER&#39;,&#39;PHL&#39;,&#39;QAT&#39;,&#39;RWA&#39;,&#39;KNA&#39;,&#39;LCA&#39;,
                &#39;VCT&#39;,&#39;WSM&#39;,&#39;STP&#39;,&#39;SAU&#39;,&#39;SEN&#39;,&#39;SYC&#39;,&#39;SLE&#39;,&#39;SGP&#39;,&#39;SLB&#39;,&#39;SOM&#39;,&#39;ZAF&#39;,
                &#39;SSD&#39;,&#39;LKA&#39;,&#39;PSE&#39;,&#39;SDN&#39;,&#39;SUR&#39;,&#39;SYR&#39;,&#39;TJK&#39;,&#39;THA&#39;,&#39;TLS&#39;,&#39;TGO&#39;,&#39;TON&#39;,
                &#39;TTO&#39;,&#39;TUN&#39;,&#39;TKM&#39;,&#39;UGA&#39;,&#39;ARE&#39;,&#39;TZA&#39;,&#39;URY&#39;,&#39;VUT&#39;,&#39;VEN&#39;,&#39;VNM&#39;,&#39;YEM&#39;,
                &#39;ZMB&#39;,&#39;ZWE&#39;]
        elif region==&#39;Commonwealth&#39;:
            clist=self._cw
        else:
            clist=self._p_gs[self._p_gs[&#39;region_name&#39;]==region][&#39;iso3&#39;].to_list()

        return sorted(clist)

    def get_pandas(self):
        return self._p_gs


# ---------------------------------------------------------------------
# --- GeoCountryclass -------------------------------------------------
# ---------------------------------------------------------------------

class GeoCountry():
    &#34;&#34;&#34;GeoCountry class definition.
    This class provides functions for specific countries and their states / departments / regions,
    and their geo properties (geometry, population if available, etc.)

    The list of supported countries is given by get_list_countries() function. &#34;&#34;&#34;

    # Assuming zip file here
    _country_info_dict = {&#39;FRA&#39;:&#39;https://data.opendatasoft.com/explore/dataset/georef-france-departement@public/download/?format=geojson&amp;timezone=Europe/Berlin&amp;lang=fr&#39;,\
                    #previously https://github.com/coa-project/coadata/raw/main/coastore/public.opendatasoft.com_912711563.zip&#39;,\
                    &#39;USA&#39;:&#39;https://alicia.data.socrata.com/api/geospatial/jhnu-yfrj?method=export&amp;format=Original&#39;,\
                    &#39;ITA&#39;:&#39;https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_provinces.geojson&#39;,\
                    &#39;IND&#39;:&#39;https://raw.githubusercontent.com/deldersveld/topojson/master/countries/india/india-states.json&#39;,\
                    &#39;DEU&#39;:&#39;https://github.com/jgehrcke/covid-19-germany-gae/raw/master/geodata/DE-counties.geojson&#39;,\
                    &#39;ESP&#39;:&#39;https://public.opendatasoft.com/explore/dataset/provincias-espanolas/download/?format=shp&amp;timezone=Europe/Berlin&amp;lang=en&#39;,\
                    # missing some counties &#39;GBR&#39;:&#39;https://opendata.arcgis.com/datasets/69dc11c7386943b4ad8893c45648b1e1_0.zip?geometry=%7B%22xmin%22%3A-44.36%2C%22ymin%22%3A51.099%2C%22xmax%22%3A39.487%2C%22ymax%22%3A59.78%2C%22type%22%3A%22extent%22%2C%22spatialReference%22%3A%7B%22wkid%22%3A4326%7D%7D&amp;outSR=%7B%22latestWkid%22%3A27700%2C%22wkid%22%3A27700%7D&#39;,\
                    &#39;GBR&#39;:&#39;https://github.com/coa-project/coadata/raw/main/coastore/opendata.arcgis.com_3256063640&#39;,\
                    # previously (but broken) : https://opendata.arcgis.com/datasets/3a4fa2ce68f642e399b4de07643eeed3_0.geojson&#39;,\
                    &#39;BEL&#39;:&#39;https://public.opendatasoft.com/explore/dataset/arrondissements-belges-2019/download/?format=shp&amp;timezone=Europe/Berlin&amp;lang=en&#39;,\
                    &#39;PRT&#39;:&#39;https://github.com/coa-project/coadata/raw/main/coastore/concelhos.zip&#39;,\
                    # (simplification of &#39;https://github.com/coa-project/coadata/raw/main&#39;https://dados.gov.pt/en/datasets/r/59368d37-cbdb-426a-9472-5a04cf30fbe4&#39;,\
                    &#39;MYS&#39;:&#39;https://stacks.stanford.edu/file/druid:zd362bc5680/data.zip&#39;,\
                    &#39;CHL&#39;:&#39;http://geonode.meteochile.gob.cl/geoserver/wfs?format_options=charset%3AUTF-8&amp;typename=geonode%3Adivision_comunal_geo_ide_1&amp;outputFormat=SHAPE-ZIP&amp;version=1.0.0&amp;service=WFS&amp;request=GetFeature&#39;,\
                    }

    _source_dict = {&#39;FRA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;FRA&#39;],\
                    &#39;Subregion Flags&#39;:&#39;http://sticker-departement.com/&#39;,\
                    &#39;Region Flags&#39;:&#39;https://fr.wikipedia.org/w/index.php?title=R%C3%A9gion_fran%C3%A7aise&amp;oldid=177269957&#39;,\
                    &#39;Population&#39;:&#39;https://www.insee.fr/fr/statistiques/4989753?sommaire=4989761&#39;},\
                    &#39;USA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;USA&#39;],\
                    &#39;Subregion informations&#39;:&#39;https://en.wikipedia.org/wiki/List_of_states_and_territories_of_the_United_States&#39;},\
                    &#39;ITA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;ITA&#39;]},\
                    &#39;IND&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;IND&#39;]},\
                    &#39;DEU&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;DEU&#39;]},\
                    &#39;ESP&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;ESP&#39;]},\
                    &#39;GBR&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;GBR&#39;],&#39;Regions&#39;:&#39;http://geoportal1-ons.opendata.arcgis.com/datasets/0c3a9643cc7c4015bb80751aad1d2594_0.csv&#39;},\
                    &#39;BEL&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;BEL&#39;]},\
                    &#39;PRT&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;PRT&#39;]},\
                    #,&#39;District&#39;:&#39;https://raw.githubusercontent.com/JoaoFOliveira/portuguese-municipalities/master/municipalities.json&#39;},\
                    &#39;MYS&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;MYS&#39;]},\
                    &#39;CHL&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;CHL&#39;]},\
                    }

    def __init__(self,country=None,**kwargs):

        &#34;&#34;&#34; __init__ member function.
        Must give as arg the country to deal with, as a valid ISO3 string.

        Various args :
         - dense_geometry (boolean). If True , the geometry of subregions and
           region is changed in order to have dense overall geometry.
           Default False.
         - main_area (boolean). If True, only the geometry of the main area of
           the country is taken into account.
        &#34;&#34;&#34;
        self._country=country
        if country == None:
            return None

        if not country in self.get_list_countries():
            raise CoaKeyError(&#34;Country &#34;+str(country)+&#34; not supported. Please see get_list_countries() and help. &#34;)

        kwargs_test(kwargs,[&#39;dense_geometry&#39;,&#39;main_area&#39;],&#39;Vad args used in this init of GeoCountry object. See help.&#39;)

        dense_geometry=kwargs.get(&#34;dense_geometry&#34;,False)
        main_area=kwargs.get(&#34;main_area&#34;,False)

        if not isinstance(dense_geometry,bool) or not isinstance(main_area,bool):
            raise CoaKeyError(&#34;GeoCountry kwargs are boolean. See help.&#34;)

        self._country_data_region=None
        self._country_data_subregion=None
        self._municipality_region=None
        url=self._country_info_dict[country]
        # country by country, adapt the read file informations

        # --- &#39;FRA&#39; case ---------------------------------------------------------------------------------------
        if self._country==&#39;FRA&#39;:
            #self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;))
            self._country_data = gpd.read_file(get_local_from_url(url,0))

            # adding a flag for subregion (departements)
            self._country_data[&#39;flag_subregion&#39;]=self._source_dict[&#39;FRA&#39;][&#39;Subregion Flags&#39;]+&#39;img/dept/sticker_plaque_immat_&#39;+\
                self._country_data[&#39;dep_code&#39;]+&#39;_&#39;+\
                [n.lower() for n in self._country_data[&#39;dep_name&#39;]]+&#39;_moto.png&#39; # picture of a sticker for motobikes, not so bad...

            # Reading information to get region flags and correct names of regions
            f_reg_flag=open(get_local_from_url(self._source_dict[&#39;FRA&#39;][&#39;Region Flags&#39;],0), &#39;r&#39;, encoding=&#34;utf8&#34;)

            content_reg_flag = f_reg_flag.read()
            f_reg_flag.close()
            soup_reg_flag = bs4.BeautifulSoup(content_reg_flag,&#39;lxml&#39;)
            for img in soup_reg_flag.find_all(&#39;img&#39;):  # need to convert &lt;img tags to src content for pandas_read
                src=img.get(&#39;src&#39;)
                if src[0] == &#39;/&#39;:
                    src=&#39;http:&#39;+src
                img.replace_with(src)

            tabs_reg_flag=pd.read_html(str(soup_reg_flag)) # pandas read the modified html
            metropole=tabs_reg_flag[5][[&#34;Logo&#34;,&#34;Dénomination&#34;,&#34;Code INSEE[5]&#34;]]  # getting 5th table, and only usefull columns
            ultramarin=tabs_reg_flag[6][[&#34;Logo&#34;,&#34;Dénomination&#34;,&#34;Code INSEE[5]&#34;]] # getting 6th table
            p_reg_flag=pd.concat([metropole,ultramarin]).rename(columns={&#34;Code INSEE[5]&#34;:&#34;code_region&#34;,\
                                                                        &#34;Logo&#34;:&#34;flag_region&#34;,\
                                                                        &#34;Dénomination&#34;:&#34;name_region&#34;})

            p_reg_flag=p_reg_flag[pd.notnull(p_reg_flag[&#34;code_region&#34;])]  # select only valid rows
            p_reg_flag[&#34;name_region&#34;]=[ n.split(&#39;[&#39;)[0] for n in p_reg_flag[&#34;name_region&#34;] ] # remove footnote [k] index from wikipedia
            p_reg_flag[&#34;code_region&#34;]=[ str(int(c)).zfill(2) for c in p_reg_flag[&#34;code_region&#34;] ] # convert to str for merge the code, adding 1 leading 0 if needed

            self._country_data=self._country_data.merge(p_reg_flag,how=&#39;left&#39;,\
                    left_on=&#39;reg_code&#39;,right_on=&#39;code_region&#39;) # merging with flag and correct names
            # standardize name for region, subregion
            self._country_data.rename(columns={\
                &#39;dep_code&#39;:&#39;code_subregion&#39;,\
                &#39;dep_name&#39;:&#39;name_subregion&#39;,\
                #&#39;nom_chf&#39;:&#39;town_subregion&#39;,\
                },inplace=True)

            # adding population information (departements)
            pop_fra = pd.read_html(get_local_from_url(self._source_dict[&#39;FRA&#39;][&#39;Population&#39;]))[0]
            pop_fra[&#39;population_subregion&#39;]=pop_fra[&#39;Population municipale&#39;].str.replace(r&#34;[ \xa0]&#34;,&#34;&#34;).astype(int)
            # En l&#39;absence de Mayotte dans ce document, car le recensement n&#39;a pas eu lieu en phase, ajout à la main
            # En référence à la page pour Mayotte : https://www.insee.fr/fr/statistiques/3291775?sommaire=2120838
            mayotte_df=pd.DataFrame([{&#39;Code département&#39;:&#39;976&#39;,&#39;population_subregion&#39;:256518}])
            pop_fra=pop_fra.append(mayotte_df)
            # Pour les collectivités d&#39;Outremer : https://www.insee.fr/fr/statistiques/4989739?sommaire=4989761
            com_df=pd.DataFrame([{&#39;Code département&#39;:&#39;980&#39;,&#39;population_subregion&#39;:(5985+10124+34065+281674+12067)}])
            pop_fra=pop_fra.append(com_df).reset_index()
            geo_com=self._country_data[self._country_data.code_subregion.isin([&#39;975&#39;,&#39;977&#39;,&#39;978&#39;,&#39;986&#39;,&#39;987&#39;])][[&#39;geometry&#39;]]
            geo_com[&#39;smthing&#39;]=0
            geo_com=geo_com.dissolve(by=&#39;smthing&#39;)[&#39;geometry&#39;]
            self._country_data=self._country_data.append(
                pd.DataFrame([{&#39;code_subregion&#39;:&#39;980&#39;,&#39;name_subregion&#39;:&#39;Collectivités d\&#39;outre-mer&#39;,&#39;code_region&#39;:&#39;09&#39;,&#39;name_region&#39;:&#39;Collectivités d\&#39;outre-mer&#39;,&#39;geometry&#39;:geo_com.values[0]}])).reset_index()
            # Merging
            self._country_data=self._country_data.merge(pop_fra,left_on=&#39;code_subregion&#39;,right_on=&#39;Code département&#39;)
            self._country_data=self._country_data[[&#39;geometry&#39;,&#39;code_subregion&#39;,&#39;name_subregion&#39;,&#39;flag_subregion&#39;,&#39;code_region&#39;,&#39;name_region&#39;,&#39;population_subregion&#39;]]
            #.drop([&#39;id_geofla&#39;,&#39;code_reg&#39;,&#39;nom_reg&#39;,&#39;x_chf_lieu&#39;,&#39;y_chf_lieu&#39;,&#39;x_centroid&#39;,&#39;y_centroid&#39;,&#39;Code département&#39;,&#39;Nom du département&#39;,&#39;Population municipale&#39;],axis=1,inplace=True) # removing some column without interest
            # moving artificially (if needed) outre-mer area to be near to metropole for map representations
            list_translation={&#34;Guadeloupe&#34;:(63,23),
                                 &#34;Martinique&#34;:(63,23),
                                 &#34;Guyane&#34;:(50,35),
                                 &#34;Réunion&#34;:(-51,60),
                                 &#34;Mayotte&#34;:(-38,51.5)}

            if dense_geometry == True :
                # Moving DROM-COM near hexagon
                tmp = []
                for index, poi in self._country_data.iterrows():
                    x=0
                    y=0
                    w=self._country_data.loc[index,&#34;name_subregion&#34;]
                    if w in list_translation.keys():
                        x=list_translation[w][0]
                        y=list_translation[w][1]
                    g = sa.translate(self._country_data.loc[index, &#39;geometry&#39;], xoff=x, yoff=y)
                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

                # Add Ile de France zoom
                idf_translation=(-6.5,-5)
                idf_scale=5
                idf_center=(-4,44)
                tmp = []
                for index, poi in self._country_data.iterrows():
                    g=self._country_data.loc[index, &#39;geometry&#39;]
                    if self._country_data.loc[index,&#39;code_subregion&#39;] in [&#39;75&#39;,&#39;92&#39;,&#39;93&#39;,&#39;94&#39;]:
                        g2=sa.scale(sa.translate(g,xoff=idf_translation[0],yoff=idf_translation[1]),\
                                                xfact=idf_scale,yfact=idf_scale,origin=idf_center)
                        g=so.unary_union([g,g2])
                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

            if main_area == True:
                self._country_data = self._country_data[~self._country_data[&#39;name_subregion&#39;].isin(list_translation.keys())]

        # --- &#39;USA&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;USA&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;)) # under the hypothesis this is a zip file
            self._country_data.rename(columns={\
                &#39;STATE_NAME&#39;:&#39;name_subregion&#39;,\
                &#39;STATE_ABBR&#39;:&#39;code_subregion&#39;,\
                &#39;SUB_REGION&#39;:&#39;code_region&#39;},\
                inplace=True)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;code_region&#39;]
            self._country_data.drop([&#39;DRAWSEQ&#39;,&#39;STATE_FIPS&#39;],axis=1,inplace=True)

            # Adding informations from wikipedia
            f_us=open(get_local_from_url(self._source_dict[&#39;USA&#39;][&#39;Subregion informations&#39;],0), &#39;r&#39;)
            content_us = f_us.read()
            f_us.close()
            soup_us = bs4.BeautifulSoup(content_us,&#39;lxml&#39;)
            for img in soup_us.find_all(&#39;img&#39;):  # need to convert &lt;img tags to src content for pandas_read
                src=img.get(&#39;src&#39;)
                if src[0] == &#39;/&#39;:
                    src=&#39;http:&#39;+src
                img.replace_with(src)

            h_us=pd.read_html(str(soup_us)) # pandas read the modified html
            h_us=h_us[1][h_us[1].columns[[0,1,2,5,7]]]
            h_us.columns=[&#39;flag_subregion&#39;,&#39;code_subregion&#39;,&#39;town_subregion&#39;,&#39;population_subregion&#39;,&#39;area_subregion&#39;]
            h_us[&#39;flag_subregion&#39;] = [ h.split(&#39;\xa0&#39;)[0] for h in h_us[&#39;flag_subregion&#39;] ]
            self._country_data=self._country_data.merge(h_us,how=&#39;left&#39;,on=&#39;code_subregion&#39;)

            list_translation={&#34;AK&#34;:(40,-40),&#34;HI&#34;:(60,0)}
            list_scale={&#34;AK&#34;:0.4,&#34;HI&#34;:1}
            list_center={&#34;AK&#34;:(-120,25),&#34;HI&#34;:(-130,25)}

            if dense_geometry == True:
                tmp = []
                for index, poi in self._country_data.iterrows():
                    x=0
                    y=0
                    w=self._country_data.loc[index,&#34;code_subregion&#34;]
                    if w in list_translation.keys():
                        x=list_translation[w][0]
                        y=list_translation[w][1]
                        g=sa.scale(sa.translate(self._country_data.loc[index, &#39;geometry&#39;],xoff=x,yoff=y),\
                                                xfact=list_scale[w],yfact=list_scale[w],origin=list_center[w])
                    else:
                        g=self._country_data.loc[index, &#39;geometry&#39;]

                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

            if main_area == True:
                self._country_data=self._country_data[~self._country_data[&#39;code_subregion&#39;].isin(list_translation.keys())]

        # --- &#39;ITA&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;ITA&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;prov_name&#39;:&#39;name_subregion&#39;,\
                &#39;prov_acr&#39;:&#39;code_subregion&#39;,\
                &#39;reg_name&#39;:&#39;name_region&#39;,\
                &#39;reg_istat_code&#39;:&#39;code_region&#39;,\
                },
                inplace=True)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;name_region&#39;].replace({
            &#39;Valle d\&#39;Aosta/Vallée d\&#39;Aoste&#39;:&#39;Valle d\&#39;Aosta&#39;,
            &#39;Trentino-Alto Adige/Südtirol&#39;:&#39;Trentino-Alto Adige&#39;, &#39;Friuli-Venezia Giulia&#39;:&#39;Friuli Venezia Giulia&#39;})
            self._country_data.drop([&#39;prov_istat_code_num&#39;,&#39;reg_istat_code_num&#39;,&#39;prov_istat_code&#39;],axis=1,inplace=True)

        # --- &#39;IND&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;IND&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;NAME_1&#39;:&#39;name_subregion&#39;,\
                &#39;VARNAME_1&#39;:&#39;variationname&#39;,\
                &#39;HASC_1&#39;:&#39;code_subregion&#39;,\
                },
                inplace=True)
            self._country_data[&#39;name_subregion&#39;]= self._country_data[&#39;name_subregion&#39;].replace(&#39;Orissa&#39;,&#39;Odisha&#39;)
            variationname=self._country_data[&#39;variationname&#39;].to_list()
            name_subregion=self._country_data[&#39;name_subregion&#39;].to_list()
            alllocationvariation=[ i+&#39;|&#39;+j if j != &#39;&#39; else i for i,j in zip(name_subregion,variationname)]
            self._country_data[&#39;variation_name_subregion&#39;] = self._country_data[&#39;name_subregion&#39;].\
                    replace(name_subregion,alllocationvariation)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;name_subregion&#39;]
            self._country_data[&#39;code_region&#39;] = self._country_data[&#39;code_subregion&#39;]
            self._country_data.drop([&#39;ISO&#39;,&#39;NAME_0&#39;,&#39;ID_1&#39;,&#39;TYPE_1&#39;,&#39;ENGTYPE_1&#39;,&#39;id&#39;],axis=1,inplace=True)

        # --- &#39;DEU&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;DEU&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;GEN&#39;:&#39;name_subregion&#39;,\
                &#39;AGS&#39;:&#39;code_subregion&#39;,\
                },
                inplace=True)
            # See https://www.ioer-monitor.de/en/methodology/glossary/o/official-municipality-key-ags/ for decoding information of region code
            self._country_data[&#39;code_region&#39;] = (self._country_data.code_subregion.astype(int)//1000).astype(str).str.zfill(2)
            h_deu=pd.read_html(get_local_from_url(&#39;https://de.zxc.wiki/wiki/Amtlicher_Gemeindeschl%C3%BCssel&#39;,0))[3]
            h_deu[&#39;id&#39;]=h_deu[&#39;#&#39;].str.slice(stop=2)
            h_deu[&#39;name_region&#39;]=h_deu[&#39;country&#39;]
            self._country_data=self._country_data.merge(h_deu,how=&#39;left&#39;,left_on=&#39;code_region&#39;,right_on=&#39;id&#39;)
            self._country_data[&#39;code_subregion&#39;]=self._country_data.code_subregion.astype(int).astype(str)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
            disso = self._country_data[[&#39;name_subregion&#39;,&#39;geometry&#39;]].dissolve(by=&#39;name_subregion&#39;, aggfunc=&#39;sum&#39;).reset_index()
            # aggregate geometry with the same subregion name # some code subregion is lost somehow
            self._country_data = self._country_data.drop_duplicates(subset = [&#39;name_subregion&#39;])
            self._country_data = pd.merge(self._country_data.drop(columns=[&#39;geometry&#39;]),disso, on=&#39;name_subregion&#39;)

        # --- &#39;ESP&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;ESP&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;) # this is shapefile file
            self._country_data.rename(columns={\
                &#39;ccaa&#39;:&#39;name_region&#39;,\
                &#39;cod_ccaa&#39;:&#39;code_region&#39;,\
                &#39;provincia&#39;:&#39;name_subregion&#39;,\
                &#39;codigo&#39;:&#39;code_subregion&#39;},inplace=True)
            self._country_data.drop([&#39;texto&#39;],axis=1,inplace=True)

        # --- &#39;GBR&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;GBR&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0))
            reg_england=pd.read_csv(get_local_from_url(self._source_dict[&#39;GBR&#39;][&#39;Regions&#39;],0))
            reg_adding_dict={
                &#39;E07000245&#39;:(&#39;E12000006&#39;,&#39;East of England&#39;), # West Suffolk in East of England
                &#39;E07000244&#39;:(&#39;E12000006&#39;,&#39;East of England&#39;), # East Suffolk in East of England
                &#39;E06000059&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Dorset in South West
                &#39;E06000058&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Bournemouth, Christchurch and Poole in South West
                &#39;E07000246&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Somerset West and Taunton in South West
            }
            for k,v in reg_adding_dict.items():
                reg_england=reg_england.append({&#39;LAD18CD&#39;:k,&#39;RGN18CD&#39;:v[0],&#39;RGN18NM&#39;:v[1]},ignore_index=True)

            self._country_data=self._country_data.merge(reg_england,how=&#39;left&#39;,left_on=&#39;lad19cd&#39;,right_on=&#39;LAD18CD&#39;)
            self._country_data.rename(columns={\
                &#39;lad19nm&#39;:&#39;name_subregion&#39;,\
                &#39;lad19cd&#39;:&#39;code_subregion&#39;,\
                &#39;RGN18CD&#39;:&#39;code_region&#39;,\
                &#39;RGN18NM&#39;:&#39;name_region&#39;,\
                },inplace=True)
            self._country_data.loc[self._country_data.code_region.isnull(),&#39;code_region&#39;] = \
                self._country_data[self._country_data.code_region.isnull()].code_subregion.str.slice(stop=1)
            dict_region={\
                &#39;E&#39;:&#39;England&#39;,\
                &#39;W&#39;:&#39;Wales&#39;,\
                &#39;S&#39;:&#39;Scotland&#39;,\
                &#39;N&#39;:&#39;Northern Ireland&#39;\
                }
            self._country_data.loc[self._country_data.code_region.isin(list(dict_region.keys())),&#39;name_region&#39;] = \
                [dict_region[x] for x in self._country_data.code_region if x in list(dict_region.keys())]
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;geometry&#39;,&#39;code_region&#39;,&#39;name_region&#39;]]
            # modifying projection
            self._country_data[&#39;geometry&#39;]=self._country_data.geometry.to_crs(&#39;epsg:4326&#39;)
        # --- &#39;BEL&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;BEL&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;) # this is shapefile file
            self._country_data.rename(columns={\
                &#39;nom_arrondi&#39;:&#39;name_subregion&#39;,\
                &#39;niscode&#39;:&#39;code_subregion&#39;,\
                &#39;prov_code&#39;:&#39;code_region&#39;},inplace=True)
            p=[]
            for index,row in self._country_data.iterrows():
                if row.prov_name_f is not None:
                    p0=row.prov_name_f
                elif row.prov_name_n is not None:
                    p0=row.prov_name_n
                else:
                    p0=row.region
                p.append(p0)
            self._country_data[&#39;name_region&#39;]=p
            self._country_data.loc[self._country_data.code_region.isnull(),&#39;code_region&#39;]=&#39;00000&#39;
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
            self._country_data[&#39;geometry&#39;]=self._country_data.geometry.to_crs(&#39;epsg:4326&#39;)
        # --- &#39;PRT&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;PRT&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;)
            #self._district=pd.read_json(self._source_dict[&#39;PRT&#39;][&#39;District&#39;])[[&#39;name&#39;,&#39;district&#39;]].dropna()

            self._country_data.rename(columns={\
                &#39;NAME_2&#39;:&#39;name_subregion&#39;,\
                &#39;NAME_1&#39;:&#39;name_region&#39;,\
                &#39;HASC_2&#39;:&#39;code_subregion&#39;},inplace=True)
            self._country_data[&#39;code_region&#39;]=self._country_data.code_subregion.str.slice(stop=5)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
        # --- &#39;MYS&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;MYS&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;)).dissolve(by=&#39;nam&#39;).reset_index()
            self._country_data[&#39;name_subregion&#39;]=[n.title() for n in self._country_data.nam]
            self._country_data[&#39;code_subregion&#39;]=self._country_data.name_subregion
            self._country_data[&#39;code_region&#39;]=&#39;MYS&#39;
            self._country_data[&#39;name_region&#39;]=&#39;Malaysia&#39;
            self._country_data[&#39;code_subregion&#39;]=self._country_data.code_subregion
            # to help the join procedure with current covid data, some translation
            dict_subregion={\
                &#39;Wilayah Persekutuan Labuan&#39;:&#39;W.P. Labuan&#39;,\
                &#39;Wilayah Persekutuan&#39;:&#39;W.P. Kuala Lumpur&#39;,\
                }
            self._country_data.loc[self._country_data.code_subregion.isin(list(dict_subregion.keys())),&#39;code_subregion&#39;] = \
                [dict_subregion[x] for x in self._country_data.code_subregion if x in list(dict_subregion.keys())]
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
        # --- &#39;CHL&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;CHL&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;)
            self._country_data.rename(columns={\
                &#39;NOM_REG&#39;:&#39;name_region&#39;,\
                &#39;NOM_COM&#39;:&#39;name_subregion&#39;},inplace=True)
            self._country_data[&#39;code_subregion&#39;]=[str(c).zfill(5) for c in self._country_data.COD_COMUNA]
            self._country_data[&#39;code_region&#39;]=self._country_data.code_subregion.str.slice(stop=2)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]

    # def get_region_from_municipality(self,lname):
    #     &#34;&#34;&#34;  Return region list from a municipality list
    #     &#34;&#34;&#34;
    #     if not isinstance(lname, list):
    #         lname=[lname]
    #     return self._municipality_region.loc[self._municipality_region.name.isin(lname)][&#39;district&#39;].to_list()

    def get_source(self):
        &#34;&#34;&#34; Return informations about URL sources
        &#34;&#34;&#34;
        if self.get_country() != None:
            return self._source_dict[self.get_country()]
        else:
            return self._source_dict

    def get_country(self):
        &#34;&#34;&#34; Return the current country used.
        &#34;&#34;&#34;
        return self._country

    def get_list_countries(self):
        &#34;&#34;&#34; This function returns back the list of supported countries
        &#34;&#34;&#34;
        return sorted(list(self._country_info_dict.keys()))

    def is_init(self):
        &#34;&#34;&#34;Test if the country is initialized. Return True if it is. False if not.
        &#34;&#34;&#34;
        if self.get_country() != None:
            return True
        else:
            return False

    def test_is_init(self):
        &#34;&#34;&#34;Test if the country is initialized. If not, raise a CoaDbError.
        &#34;&#34;&#34;
        if self.is_init():
            return True
        else:
            raise CoaDbError(&#34;The country is not set. Use a constructor with non empty country string.&#34;)

    def get_region_list(self):
        &#34;&#34;&#34; Return the list of available regions with code, name and geometry
        &#34;&#34;&#34;
        cols=[c for c in self.get_list_properties() if &#39;_region&#39; in c]
        cols.append(&#39;geometry&#39;)
        return self.get_data(True)[cols]

    def is_region(self,r):
        &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
        &#34;&#34;&#34;
        r=tostdstring(r)
        for i in self.get_region_list().name_region.to_list():
            if tostdstring(i) == r:
                return i
        return False

    def get_subregion_list(self):
        &#34;&#34;&#34; Return the list of available subregions with code, name and geometry
        &#34;&#34;&#34;
        cols=[c for c in self.get_list_properties() if &#39;_subregion&#39; in c ]
        cols.append(&#39;geometry&#39;)
        return self.get_data()[cols]

    def is_subregion(self,r):
        &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
        &#34;&#34;&#34;
        r2=tostdstring(r)
        for i in self.get_subregion_list().name_subregion.to_list():
            if tostdstring(i) == r2:
                return i
        a=self.get_subregion_list()[self.get_subregion_list().code_subregion==r].name_subregion.values
        if a.size == 1:
            return a[0]
        return False

    def get_subregions_from_region(self,**kwargs):
        &#34;&#34;&#34; Return the list of subregions within a specified region.
        Should give either the code or the name of the region as strings in kwarg : code=# or name=#
        Output default is &#39;code&#39; of subregions. Can be changer with output=&#39;name&#39;.
        &#34;&#34;&#34;
        kwargs_test(kwargs,[&#39;name&#39;,&#39;code&#39;,&#39;output&#39;],&#39;Should give either name or code of region. Output can be changed with the output option.&#39;)
        code=kwargs.get(&#34;code&#34;,None)
        name=kwargs.get(&#34;name&#34;,None)
        out=kwargs.get(&#34;output&#34;,&#39;code&#39;)
        if not (code == None) ^ (name == None):
            raise CoaKeyError(&#34;Should give either code or name of region, not both.&#34;)
        if not out in [&#39;code&#39;,&#39;name&#39;]:
            raise CoaKeyError(&#34;Should set output either as &#39;code&#39; or &#39;name&#39; for subregions.&#34;)

        if name != None:
            if not isinstance(name,str):
                raise CoaTypeError(&#34;Name should be given as string.&#34;)
            if not name in self.get_region_list()[&#39;name_region&#39;].to_list():
                raise CoaWhereError (&#34;The region &#34;+name+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
            cut=(self.get_data(True)[&#39;name_region&#39;]==name)

        if code != None:
            if not isinstance(code,str):
                raise CoaTypeError(&#34;Name should be given as string.&#34;)
            if not code in self.get_region_list()[&#39;code_region&#39;].to_list():
                raise CoaWhereError(&#34;The region &#34;+code+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
            cut=(self.get_data(True)[&#39;code_region&#39;]==code)

        return self.get_data(True)[cut][out+&#39;_subregion&#39;].iloc[0]#to_list()

    def get_subregions_from_list_of_region_names(self,l,output=&#39;code&#39;):
        &#34;&#34;&#34; Return the list of subregions according to list of region names given.
        The output argument (&#39;code&#39; as default) is given to the get_subregions_from_region function.
        &#34;&#34;&#34;
        if not isinstance(l,list):
            raise CoaTypeError(&#34;Should provide list as argument&#34;)
        s=[]
        for r in l:
            s=s+self.get_subregions_from_region(name=r,output=output)
        return s

    def get_list_properties(self):
        &#34;&#34;&#34;Return the list of available properties for the current country
        &#34;&#34;&#34;
        if self.test_is_init():
            return sorted(self._country_data.columns.to_list())

    def get_data(self,region_version=False):
        &#34;&#34;&#34;Return the whole geopandas data.
        If region_version = True (not default), the pandas output is region based focalized.
        &#34;&#34;&#34;
        if self.test_is_init():
            if region_version:
                if not isinstance(self._country_data_region,pd.DataFrame): # i.e. is None
                    col_reg=[c for c in self._country_data.columns.tolist() if &#39;_region&#39; in c]
                    col=col_reg.copy()
                    col.append(&#39;geometry&#39;) # to merge the geometry of subregions
                    for p in self.get_list_properties():
                        if (&#39;_subregion&#39; in p) and pd.api.types.is_numeric_dtype(self._country_data[p]):
                            col.append(p)
                    if not &#39;code_subregion&#39; in col:
                        col.append(&#39;code_subregion&#39;) # to get the list of subregion in region
                    if not &#39;name_subregion&#39; in col:
                        col.append(&#39;name_subregion&#39;) # to get the list of subregion name in region

                    pr=self._country_data[col].copy()

                    # Country specific management
                    if self.get_country()==&#39;FRA&#39;: # manage pseudo &#39;FRA&#39; regions &#39;Métropole&#39; and &#39;Outre-mer&#39;
                        metropole_cut=pr.code_region.astype(int)&gt;=10
                        pr_metropole=pr[metropole_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;999&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;Métropole&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;
                        pr_outremer=pr[~metropole_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;000&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Outre-mer&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;ESP&#39; : # manage pseudo &#39;ESP&#39; regions within and outside continent
                        islands_cut=pr.code_region.astype(int).isin([&#39;05&#39;])
                        pr_metropole=pr[~islands_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;99&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;España peninsular&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                        pr_outremer=pr[islands_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;00&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Islas españolas&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;PRT&#39; : # manage pseudo &#39;PRT&#39; regions within and outside continent
                        islands_cut=pr.code_region.isin([&#39;PT.AC&#39;,&#39;PT.MA&#39;])
                        pr_metropole=pr[~islands_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;PT.99&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;Portugal continental&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                        pr_outremer=pr[islands_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;PT.00&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Ilhas portuguesas&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;USA&#39;:
                        usa_col=pr.columns.tolist()
                        #usa_col.remove(&#39;population_subregion&#39;) # Remove numeric column, if not, the dissolve does not work properly
                        #usa_col.remove(&#39;area_subregion&#39;) # idem
                        pr=pr[usa_col]

                    pr[&#39;code_subregion&#39;]=pr.code_subregion.apply(lambda x: [x])
                    pr[&#39;name_subregion&#39;]=pr.name_subregion.apply(lambda x: [x])
                    self._country_data_region=pr.dissolve(by=col_reg,aggfunc=(lambda x: x.sum())).sort_values(by=&#39;code_region&#39;).reset_index()
                    for x in [&#39;population&#39;,&#39;area&#39;]:
                        if x+&#39;_subregion&#39; in self._country_data_region.columns:
                            self._country_data_region.rename(columns={x+&#39;_subregion&#39;:x+&#39;_region&#39;},inplace=True)

                return self._country_data_region
            else:
                if not isinstance(self._country_data_subregion,pd.DataFrame): #i.e. is None
                    self._country_data_subregion=self._country_data.sort_values(by=&#39;code_subregion&#39;)
                return self._country_data_subregion

    def add_field(self,**kwargs):
        &#34;&#34;&#34;Return a the data pandas.Dataframe with an additionnal column with property prop.

        Arguments :
        input        : pandas.Dataframe object. Mandatory.
        field        : field of properties to add. Should be within the get_list_prop() list. Mandatory.
        input_key    : input geo key of the input pandas dataframe. Default  &#39;where&#39;
        geofield     : internal geo field to make the merge. Default &#39;code_subregion&#39;
        region_merging : Boolean value. Default False, except if the geofield contains &#39;_region&#39;.
                       If True, the merge between input dans GeoCountry data is done within the
                       region version of the data, not the subregion data which is the default
                       behavious.
        overload   : Allow to overload a field. Boolean value. Default : False
        &#34;&#34;&#34;

        # Test of args
        kwargs_test(kwargs,[&#39;input&#39;,&#39;field&#39;,&#39;input_key&#39;,&#39;geofield&#39;,&#39;geotype&#39;,&#39;overload&#39;],
            &#39;Bad args used in the add_field() function.&#39;)

        # Testing input
        data=kwargs.get(&#39;input&#39;,None) # the panda
        if not isinstance(data,pd.DataFrame):
            raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
                &#39; DataFrame as input. See help.&#39;)
        data=data.copy()

        # Testing input_key
        input_key=kwargs.get(&#39;input_key&#39;,&#39;where&#39;)
        if not isinstance(input_key,str):
            raise CoaTypeError(&#39;The input_key should be given as a string.&#39;)
        if input_key not in data.columns.tolist():
            raise CoaKeyError(&#39;The input_key &#34;&#39;+input_key+&#39;&#34; given is &#39;
                &#39;not a valid column name of the input pandas dataframe.&#39;)

        # Testing geofield
        geofield=kwargs.get(&#39;geofield&#39;,&#39;code_subregion&#39;)
        if not isinstance(geofield,str):
            raise CoaTypeError(&#39;The geofield should be given as a string.&#39;)
        if geofield not in self._country_data.columns.tolist():
            raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
                &#39;not a valid column name of the available data. &#39;
                &#39;See get_list_properties() for valid fields.&#39;)

        region_merging=kwargs.get(&#39;region_merging&#39;,None)
        if region_merging == None:
            if &#39;_region&#39; in geofield:
                region_merging=True
            else:
                region_merging=False

        if not isinstance(region_merging,bool):
            raise CoaKeyError(&#39;The region_mergin key should be boolean. See help.&#39;)

        # Testing fields
        prop=kwargs.get(&#39;field&#39;,None) # field list
        if prop == None:
            raise CoaKeyError(&#39;No field given. See help.&#39;)
        if not isinstance(prop,list):
            prop=[prop] # make the prop input a list if needed

        if not all(isinstance(p, str) for p in prop):
            raise CoaTypeError(&#34;Each property should be a string whereas &#34;+str(prop)+&#34; is not a list of string.&#34;)

        if not all(p in self.get_list_properties() for p in prop):
            raise CoaKeyError(&#34;The property &#34;+prop+&#34; is not available for country &#34;+self.get_country()+&#34;.&#34;)

        # Testing overload
        overload=kwargs.get(&#39;overload&#39;,False)
        if not isinstance(overload,bool):
            raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

        if not overload and not all(p not in data.columns.tolist() for p in prop):
            raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
                &#39;dataframe columns. You may set overload to True.&#39;)

        # Is the oject properly initialized ?
        self.test_is_init()

        # Now let&#39;s go for merging
        prop.append(&#39;code_subregion&#39;)
        return data.merge(self.get_data(region_merging)[prop],how=&#39;left&#39;,left_on=input_key,\
                            right_on=geofield)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coa.geo.GeoCountry"><code class="flex name class">
<span>class <span class="ident">GeoCountry</span></span>
<span>(</span><span>country=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>GeoCountry class definition.
This class provides functions for specific countries and their states / departments / regions,
and their geo properties (geometry, population if available, etc.)</p>
<p>The list of supported countries is given by get_list_countries() function. </p>
<p><strong>init</strong> member function.
Must give as arg the country to deal with, as a valid ISO3 string.</p>
<p>Various args :
- dense_geometry (boolean). If True , the geometry of subregions and
region is changed in order to have dense overall geometry.
Default False.
- main_area (boolean). If True, only the geometry of the main area of
the country is taken into account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoCountry():
    &#34;&#34;&#34;GeoCountry class definition.
    This class provides functions for specific countries and their states / departments / regions,
    and their geo properties (geometry, population if available, etc.)

    The list of supported countries is given by get_list_countries() function. &#34;&#34;&#34;

    # Assuming zip file here
    _country_info_dict = {&#39;FRA&#39;:&#39;https://data.opendatasoft.com/explore/dataset/georef-france-departement@public/download/?format=geojson&amp;timezone=Europe/Berlin&amp;lang=fr&#39;,\
                    #previously https://github.com/coa-project/coadata/raw/main/coastore/public.opendatasoft.com_912711563.zip&#39;,\
                    &#39;USA&#39;:&#39;https://alicia.data.socrata.com/api/geospatial/jhnu-yfrj?method=export&amp;format=Original&#39;,\
                    &#39;ITA&#39;:&#39;https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_provinces.geojson&#39;,\
                    &#39;IND&#39;:&#39;https://raw.githubusercontent.com/deldersveld/topojson/master/countries/india/india-states.json&#39;,\
                    &#39;DEU&#39;:&#39;https://github.com/jgehrcke/covid-19-germany-gae/raw/master/geodata/DE-counties.geojson&#39;,\
                    &#39;ESP&#39;:&#39;https://public.opendatasoft.com/explore/dataset/provincias-espanolas/download/?format=shp&amp;timezone=Europe/Berlin&amp;lang=en&#39;,\
                    # missing some counties &#39;GBR&#39;:&#39;https://opendata.arcgis.com/datasets/69dc11c7386943b4ad8893c45648b1e1_0.zip?geometry=%7B%22xmin%22%3A-44.36%2C%22ymin%22%3A51.099%2C%22xmax%22%3A39.487%2C%22ymax%22%3A59.78%2C%22type%22%3A%22extent%22%2C%22spatialReference%22%3A%7B%22wkid%22%3A4326%7D%7D&amp;outSR=%7B%22latestWkid%22%3A27700%2C%22wkid%22%3A27700%7D&#39;,\
                    &#39;GBR&#39;:&#39;https://github.com/coa-project/coadata/raw/main/coastore/opendata.arcgis.com_3256063640&#39;,\
                    # previously (but broken) : https://opendata.arcgis.com/datasets/3a4fa2ce68f642e399b4de07643eeed3_0.geojson&#39;,\
                    &#39;BEL&#39;:&#39;https://public.opendatasoft.com/explore/dataset/arrondissements-belges-2019/download/?format=shp&amp;timezone=Europe/Berlin&amp;lang=en&#39;,\
                    &#39;PRT&#39;:&#39;https://github.com/coa-project/coadata/raw/main/coastore/concelhos.zip&#39;,\
                    # (simplification of &#39;https://github.com/coa-project/coadata/raw/main&#39;https://dados.gov.pt/en/datasets/r/59368d37-cbdb-426a-9472-5a04cf30fbe4&#39;,\
                    &#39;MYS&#39;:&#39;https://stacks.stanford.edu/file/druid:zd362bc5680/data.zip&#39;,\
                    &#39;CHL&#39;:&#39;http://geonode.meteochile.gob.cl/geoserver/wfs?format_options=charset%3AUTF-8&amp;typename=geonode%3Adivision_comunal_geo_ide_1&amp;outputFormat=SHAPE-ZIP&amp;version=1.0.0&amp;service=WFS&amp;request=GetFeature&#39;,\
                    }

    _source_dict = {&#39;FRA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;FRA&#39;],\
                    &#39;Subregion Flags&#39;:&#39;http://sticker-departement.com/&#39;,\
                    &#39;Region Flags&#39;:&#39;https://fr.wikipedia.org/w/index.php?title=R%C3%A9gion_fran%C3%A7aise&amp;oldid=177269957&#39;,\
                    &#39;Population&#39;:&#39;https://www.insee.fr/fr/statistiques/4989753?sommaire=4989761&#39;},\
                    &#39;USA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;USA&#39;],\
                    &#39;Subregion informations&#39;:&#39;https://en.wikipedia.org/wiki/List_of_states_and_territories_of_the_United_States&#39;},\
                    &#39;ITA&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;ITA&#39;]},\
                    &#39;IND&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;IND&#39;]},\
                    &#39;DEU&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;DEU&#39;]},\
                    &#39;ESP&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;ESP&#39;]},\
                    &#39;GBR&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;GBR&#39;],&#39;Regions&#39;:&#39;http://geoportal1-ons.opendata.arcgis.com/datasets/0c3a9643cc7c4015bb80751aad1d2594_0.csv&#39;},\
                    &#39;BEL&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;BEL&#39;]},\
                    &#39;PRT&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;PRT&#39;]},\
                    #,&#39;District&#39;:&#39;https://raw.githubusercontent.com/JoaoFOliveira/portuguese-municipalities/master/municipalities.json&#39;},\
                    &#39;MYS&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;MYS&#39;]},\
                    &#39;CHL&#39;:{&#39;Basics&#39;:_country_info_dict[&#39;CHL&#39;]},\
                    }

    def __init__(self,country=None,**kwargs):

        &#34;&#34;&#34; __init__ member function.
        Must give as arg the country to deal with, as a valid ISO3 string.

        Various args :
         - dense_geometry (boolean). If True , the geometry of subregions and
           region is changed in order to have dense overall geometry.
           Default False.
         - main_area (boolean). If True, only the geometry of the main area of
           the country is taken into account.
        &#34;&#34;&#34;
        self._country=country
        if country == None:
            return None

        if not country in self.get_list_countries():
            raise CoaKeyError(&#34;Country &#34;+str(country)+&#34; not supported. Please see get_list_countries() and help. &#34;)

        kwargs_test(kwargs,[&#39;dense_geometry&#39;,&#39;main_area&#39;],&#39;Vad args used in this init of GeoCountry object. See help.&#39;)

        dense_geometry=kwargs.get(&#34;dense_geometry&#34;,False)
        main_area=kwargs.get(&#34;main_area&#34;,False)

        if not isinstance(dense_geometry,bool) or not isinstance(main_area,bool):
            raise CoaKeyError(&#34;GeoCountry kwargs are boolean. See help.&#34;)

        self._country_data_region=None
        self._country_data_subregion=None
        self._municipality_region=None
        url=self._country_info_dict[country]
        # country by country, adapt the read file informations

        # --- &#39;FRA&#39; case ---------------------------------------------------------------------------------------
        if self._country==&#39;FRA&#39;:
            #self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;))
            self._country_data = gpd.read_file(get_local_from_url(url,0))

            # adding a flag for subregion (departements)
            self._country_data[&#39;flag_subregion&#39;]=self._source_dict[&#39;FRA&#39;][&#39;Subregion Flags&#39;]+&#39;img/dept/sticker_plaque_immat_&#39;+\
                self._country_data[&#39;dep_code&#39;]+&#39;_&#39;+\
                [n.lower() for n in self._country_data[&#39;dep_name&#39;]]+&#39;_moto.png&#39; # picture of a sticker for motobikes, not so bad...

            # Reading information to get region flags and correct names of regions
            f_reg_flag=open(get_local_from_url(self._source_dict[&#39;FRA&#39;][&#39;Region Flags&#39;],0), &#39;r&#39;, encoding=&#34;utf8&#34;)

            content_reg_flag = f_reg_flag.read()
            f_reg_flag.close()
            soup_reg_flag = bs4.BeautifulSoup(content_reg_flag,&#39;lxml&#39;)
            for img in soup_reg_flag.find_all(&#39;img&#39;):  # need to convert &lt;img tags to src content for pandas_read
                src=img.get(&#39;src&#39;)
                if src[0] == &#39;/&#39;:
                    src=&#39;http:&#39;+src
                img.replace_with(src)

            tabs_reg_flag=pd.read_html(str(soup_reg_flag)) # pandas read the modified html
            metropole=tabs_reg_flag[5][[&#34;Logo&#34;,&#34;Dénomination&#34;,&#34;Code INSEE[5]&#34;]]  # getting 5th table, and only usefull columns
            ultramarin=tabs_reg_flag[6][[&#34;Logo&#34;,&#34;Dénomination&#34;,&#34;Code INSEE[5]&#34;]] # getting 6th table
            p_reg_flag=pd.concat([metropole,ultramarin]).rename(columns={&#34;Code INSEE[5]&#34;:&#34;code_region&#34;,\
                                                                        &#34;Logo&#34;:&#34;flag_region&#34;,\
                                                                        &#34;Dénomination&#34;:&#34;name_region&#34;})

            p_reg_flag=p_reg_flag[pd.notnull(p_reg_flag[&#34;code_region&#34;])]  # select only valid rows
            p_reg_flag[&#34;name_region&#34;]=[ n.split(&#39;[&#39;)[0] for n in p_reg_flag[&#34;name_region&#34;] ] # remove footnote [k] index from wikipedia
            p_reg_flag[&#34;code_region&#34;]=[ str(int(c)).zfill(2) for c in p_reg_flag[&#34;code_region&#34;] ] # convert to str for merge the code, adding 1 leading 0 if needed

            self._country_data=self._country_data.merge(p_reg_flag,how=&#39;left&#39;,\
                    left_on=&#39;reg_code&#39;,right_on=&#39;code_region&#39;) # merging with flag and correct names
            # standardize name for region, subregion
            self._country_data.rename(columns={\
                &#39;dep_code&#39;:&#39;code_subregion&#39;,\
                &#39;dep_name&#39;:&#39;name_subregion&#39;,\
                #&#39;nom_chf&#39;:&#39;town_subregion&#39;,\
                },inplace=True)

            # adding population information (departements)
            pop_fra = pd.read_html(get_local_from_url(self._source_dict[&#39;FRA&#39;][&#39;Population&#39;]))[0]
            pop_fra[&#39;population_subregion&#39;]=pop_fra[&#39;Population municipale&#39;].str.replace(r&#34;[ \xa0]&#34;,&#34;&#34;).astype(int)
            # En l&#39;absence de Mayotte dans ce document, car le recensement n&#39;a pas eu lieu en phase, ajout à la main
            # En référence à la page pour Mayotte : https://www.insee.fr/fr/statistiques/3291775?sommaire=2120838
            mayotte_df=pd.DataFrame([{&#39;Code département&#39;:&#39;976&#39;,&#39;population_subregion&#39;:256518}])
            pop_fra=pop_fra.append(mayotte_df)
            # Pour les collectivités d&#39;Outremer : https://www.insee.fr/fr/statistiques/4989739?sommaire=4989761
            com_df=pd.DataFrame([{&#39;Code département&#39;:&#39;980&#39;,&#39;population_subregion&#39;:(5985+10124+34065+281674+12067)}])
            pop_fra=pop_fra.append(com_df).reset_index()
            geo_com=self._country_data[self._country_data.code_subregion.isin([&#39;975&#39;,&#39;977&#39;,&#39;978&#39;,&#39;986&#39;,&#39;987&#39;])][[&#39;geometry&#39;]]
            geo_com[&#39;smthing&#39;]=0
            geo_com=geo_com.dissolve(by=&#39;smthing&#39;)[&#39;geometry&#39;]
            self._country_data=self._country_data.append(
                pd.DataFrame([{&#39;code_subregion&#39;:&#39;980&#39;,&#39;name_subregion&#39;:&#39;Collectivités d\&#39;outre-mer&#39;,&#39;code_region&#39;:&#39;09&#39;,&#39;name_region&#39;:&#39;Collectivités d\&#39;outre-mer&#39;,&#39;geometry&#39;:geo_com.values[0]}])).reset_index()
            # Merging
            self._country_data=self._country_data.merge(pop_fra,left_on=&#39;code_subregion&#39;,right_on=&#39;Code département&#39;)
            self._country_data=self._country_data[[&#39;geometry&#39;,&#39;code_subregion&#39;,&#39;name_subregion&#39;,&#39;flag_subregion&#39;,&#39;code_region&#39;,&#39;name_region&#39;,&#39;population_subregion&#39;]]
            #.drop([&#39;id_geofla&#39;,&#39;code_reg&#39;,&#39;nom_reg&#39;,&#39;x_chf_lieu&#39;,&#39;y_chf_lieu&#39;,&#39;x_centroid&#39;,&#39;y_centroid&#39;,&#39;Code département&#39;,&#39;Nom du département&#39;,&#39;Population municipale&#39;],axis=1,inplace=True) # removing some column without interest
            # moving artificially (if needed) outre-mer area to be near to metropole for map representations
            list_translation={&#34;Guadeloupe&#34;:(63,23),
                                 &#34;Martinique&#34;:(63,23),
                                 &#34;Guyane&#34;:(50,35),
                                 &#34;Réunion&#34;:(-51,60),
                                 &#34;Mayotte&#34;:(-38,51.5)}

            if dense_geometry == True :
                # Moving DROM-COM near hexagon
                tmp = []
                for index, poi in self._country_data.iterrows():
                    x=0
                    y=0
                    w=self._country_data.loc[index,&#34;name_subregion&#34;]
                    if w in list_translation.keys():
                        x=list_translation[w][0]
                        y=list_translation[w][1]
                    g = sa.translate(self._country_data.loc[index, &#39;geometry&#39;], xoff=x, yoff=y)
                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

                # Add Ile de France zoom
                idf_translation=(-6.5,-5)
                idf_scale=5
                idf_center=(-4,44)
                tmp = []
                for index, poi in self._country_data.iterrows():
                    g=self._country_data.loc[index, &#39;geometry&#39;]
                    if self._country_data.loc[index,&#39;code_subregion&#39;] in [&#39;75&#39;,&#39;92&#39;,&#39;93&#39;,&#39;94&#39;]:
                        g2=sa.scale(sa.translate(g,xoff=idf_translation[0],yoff=idf_translation[1]),\
                                                xfact=idf_scale,yfact=idf_scale,origin=idf_center)
                        g=so.unary_union([g,g2])
                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

            if main_area == True:
                self._country_data = self._country_data[~self._country_data[&#39;name_subregion&#39;].isin(list_translation.keys())]

        # --- &#39;USA&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;USA&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;)) # under the hypothesis this is a zip file
            self._country_data.rename(columns={\
                &#39;STATE_NAME&#39;:&#39;name_subregion&#39;,\
                &#39;STATE_ABBR&#39;:&#39;code_subregion&#39;,\
                &#39;SUB_REGION&#39;:&#39;code_region&#39;},\
                inplace=True)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;code_region&#39;]
            self._country_data.drop([&#39;DRAWSEQ&#39;,&#39;STATE_FIPS&#39;],axis=1,inplace=True)

            # Adding informations from wikipedia
            f_us=open(get_local_from_url(self._source_dict[&#39;USA&#39;][&#39;Subregion informations&#39;],0), &#39;r&#39;)
            content_us = f_us.read()
            f_us.close()
            soup_us = bs4.BeautifulSoup(content_us,&#39;lxml&#39;)
            for img in soup_us.find_all(&#39;img&#39;):  # need to convert &lt;img tags to src content for pandas_read
                src=img.get(&#39;src&#39;)
                if src[0] == &#39;/&#39;:
                    src=&#39;http:&#39;+src
                img.replace_with(src)

            h_us=pd.read_html(str(soup_us)) # pandas read the modified html
            h_us=h_us[1][h_us[1].columns[[0,1,2,5,7]]]
            h_us.columns=[&#39;flag_subregion&#39;,&#39;code_subregion&#39;,&#39;town_subregion&#39;,&#39;population_subregion&#39;,&#39;area_subregion&#39;]
            h_us[&#39;flag_subregion&#39;] = [ h.split(&#39;\xa0&#39;)[0] for h in h_us[&#39;flag_subregion&#39;] ]
            self._country_data=self._country_data.merge(h_us,how=&#39;left&#39;,on=&#39;code_subregion&#39;)

            list_translation={&#34;AK&#34;:(40,-40),&#34;HI&#34;:(60,0)}
            list_scale={&#34;AK&#34;:0.4,&#34;HI&#34;:1}
            list_center={&#34;AK&#34;:(-120,25),&#34;HI&#34;:(-130,25)}

            if dense_geometry == True:
                tmp = []
                for index, poi in self._country_data.iterrows():
                    x=0
                    y=0
                    w=self._country_data.loc[index,&#34;code_subregion&#34;]
                    if w in list_translation.keys():
                        x=list_translation[w][0]
                        y=list_translation[w][1]
                        g=sa.scale(sa.translate(self._country_data.loc[index, &#39;geometry&#39;],xoff=x,yoff=y),\
                                                xfact=list_scale[w],yfact=list_scale[w],origin=list_center[w])
                    else:
                        g=self._country_data.loc[index, &#39;geometry&#39;]

                    tmp.append(g)
                self._country_data[&#39;geometry&#39;]=tmp

            if main_area == True:
                self._country_data=self._country_data[~self._country_data[&#39;code_subregion&#39;].isin(list_translation.keys())]

        # --- &#39;ITA&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;ITA&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;prov_name&#39;:&#39;name_subregion&#39;,\
                &#39;prov_acr&#39;:&#39;code_subregion&#39;,\
                &#39;reg_name&#39;:&#39;name_region&#39;,\
                &#39;reg_istat_code&#39;:&#39;code_region&#39;,\
                },
                inplace=True)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;name_region&#39;].replace({
            &#39;Valle d\&#39;Aosta/Vallée d\&#39;Aoste&#39;:&#39;Valle d\&#39;Aosta&#39;,
            &#39;Trentino-Alto Adige/Südtirol&#39;:&#39;Trentino-Alto Adige&#39;, &#39;Friuli-Venezia Giulia&#39;:&#39;Friuli Venezia Giulia&#39;})
            self._country_data.drop([&#39;prov_istat_code_num&#39;,&#39;reg_istat_code_num&#39;,&#39;prov_istat_code&#39;],axis=1,inplace=True)

        # --- &#39;IND&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;IND&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;NAME_1&#39;:&#39;name_subregion&#39;,\
                &#39;VARNAME_1&#39;:&#39;variationname&#39;,\
                &#39;HASC_1&#39;:&#39;code_subregion&#39;,\
                },
                inplace=True)
            self._country_data[&#39;name_subregion&#39;]= self._country_data[&#39;name_subregion&#39;].replace(&#39;Orissa&#39;,&#39;Odisha&#39;)
            variationname=self._country_data[&#39;variationname&#39;].to_list()
            name_subregion=self._country_data[&#39;name_subregion&#39;].to_list()
            alllocationvariation=[ i+&#39;|&#39;+j if j != &#39;&#39; else i for i,j in zip(name_subregion,variationname)]
            self._country_data[&#39;variation_name_subregion&#39;] = self._country_data[&#39;name_subregion&#39;].\
                    replace(name_subregion,alllocationvariation)
            self._country_data[&#39;name_region&#39;] = self._country_data[&#39;name_subregion&#39;]
            self._country_data[&#39;code_region&#39;] = self._country_data[&#39;code_subregion&#39;]
            self._country_data.drop([&#39;ISO&#39;,&#39;NAME_0&#39;,&#39;ID_1&#39;,&#39;TYPE_1&#39;,&#39;ENGTYPE_1&#39;,&#39;id&#39;],axis=1,inplace=True)

        # --- &#39;DEU&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;DEU&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0)) # this is a geojson file
            self._country_data.rename(columns={\
                &#39;GEN&#39;:&#39;name_subregion&#39;,\
                &#39;AGS&#39;:&#39;code_subregion&#39;,\
                },
                inplace=True)
            # See https://www.ioer-monitor.de/en/methodology/glossary/o/official-municipality-key-ags/ for decoding information of region code
            self._country_data[&#39;code_region&#39;] = (self._country_data.code_subregion.astype(int)//1000).astype(str).str.zfill(2)
            h_deu=pd.read_html(get_local_from_url(&#39;https://de.zxc.wiki/wiki/Amtlicher_Gemeindeschl%C3%BCssel&#39;,0))[3]
            h_deu[&#39;id&#39;]=h_deu[&#39;#&#39;].str.slice(stop=2)
            h_deu[&#39;name_region&#39;]=h_deu[&#39;country&#39;]
            self._country_data=self._country_data.merge(h_deu,how=&#39;left&#39;,left_on=&#39;code_region&#39;,right_on=&#39;id&#39;)
            self._country_data[&#39;code_subregion&#39;]=self._country_data.code_subregion.astype(int).astype(str)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
            disso = self._country_data[[&#39;name_subregion&#39;,&#39;geometry&#39;]].dissolve(by=&#39;name_subregion&#39;, aggfunc=&#39;sum&#39;).reset_index()
            # aggregate geometry with the same subregion name # some code subregion is lost somehow
            self._country_data = self._country_data.drop_duplicates(subset = [&#39;name_subregion&#39;])
            self._country_data = pd.merge(self._country_data.drop(columns=[&#39;geometry&#39;]),disso, on=&#39;name_subregion&#39;)

        # --- &#39;ESP&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;ESP&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;) # this is shapefile file
            self._country_data.rename(columns={\
                &#39;ccaa&#39;:&#39;name_region&#39;,\
                &#39;cod_ccaa&#39;:&#39;code_region&#39;,\
                &#39;provincia&#39;:&#39;name_subregion&#39;,\
                &#39;codigo&#39;:&#39;code_subregion&#39;},inplace=True)
            self._country_data.drop([&#39;texto&#39;],axis=1,inplace=True)

        # --- &#39;GBR&#39; case ---------------------------------------------------------------------------------------
        elif self._country == &#39;GBR&#39;:
            self._country_data = gpd.read_file(get_local_from_url(url,0))
            reg_england=pd.read_csv(get_local_from_url(self._source_dict[&#39;GBR&#39;][&#39;Regions&#39;],0))
            reg_adding_dict={
                &#39;E07000245&#39;:(&#39;E12000006&#39;,&#39;East of England&#39;), # West Suffolk in East of England
                &#39;E07000244&#39;:(&#39;E12000006&#39;,&#39;East of England&#39;), # East Suffolk in East of England
                &#39;E06000059&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Dorset in South West
                &#39;E06000058&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Bournemouth, Christchurch and Poole in South West
                &#39;E07000246&#39;:(&#39;E12000009&#39;,&#39;South West&#39;), # Somerset West and Taunton in South West
            }
            for k,v in reg_adding_dict.items():
                reg_england=reg_england.append({&#39;LAD18CD&#39;:k,&#39;RGN18CD&#39;:v[0],&#39;RGN18NM&#39;:v[1]},ignore_index=True)

            self._country_data=self._country_data.merge(reg_england,how=&#39;left&#39;,left_on=&#39;lad19cd&#39;,right_on=&#39;LAD18CD&#39;)
            self._country_data.rename(columns={\
                &#39;lad19nm&#39;:&#39;name_subregion&#39;,\
                &#39;lad19cd&#39;:&#39;code_subregion&#39;,\
                &#39;RGN18CD&#39;:&#39;code_region&#39;,\
                &#39;RGN18NM&#39;:&#39;name_region&#39;,\
                },inplace=True)
            self._country_data.loc[self._country_data.code_region.isnull(),&#39;code_region&#39;] = \
                self._country_data[self._country_data.code_region.isnull()].code_subregion.str.slice(stop=1)
            dict_region={\
                &#39;E&#39;:&#39;England&#39;,\
                &#39;W&#39;:&#39;Wales&#39;,\
                &#39;S&#39;:&#39;Scotland&#39;,\
                &#39;N&#39;:&#39;Northern Ireland&#39;\
                }
            self._country_data.loc[self._country_data.code_region.isin(list(dict_region.keys())),&#39;name_region&#39;] = \
                [dict_region[x] for x in self._country_data.code_region if x in list(dict_region.keys())]
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;geometry&#39;,&#39;code_region&#39;,&#39;name_region&#39;]]
            # modifying projection
            self._country_data[&#39;geometry&#39;]=self._country_data.geometry.to_crs(&#39;epsg:4326&#39;)
        # --- &#39;BEL&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;BEL&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;) # this is shapefile file
            self._country_data.rename(columns={\
                &#39;nom_arrondi&#39;:&#39;name_subregion&#39;,\
                &#39;niscode&#39;:&#39;code_subregion&#39;,\
                &#39;prov_code&#39;:&#39;code_region&#39;},inplace=True)
            p=[]
            for index,row in self._country_data.iterrows():
                if row.prov_name_f is not None:
                    p0=row.prov_name_f
                elif row.prov_name_n is not None:
                    p0=row.prov_name_n
                else:
                    p0=row.region
                p.append(p0)
            self._country_data[&#39;name_region&#39;]=p
            self._country_data.loc[self._country_data.code_region.isnull(),&#39;code_region&#39;]=&#39;00000&#39;
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
            self._country_data[&#39;geometry&#39;]=self._country_data.geometry.to_crs(&#39;epsg:4326&#39;)
        # --- &#39;PRT&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;PRT&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;)
            #self._district=pd.read_json(self._source_dict[&#39;PRT&#39;][&#39;District&#39;])[[&#39;name&#39;,&#39;district&#39;]].dropna()

            self._country_data.rename(columns={\
                &#39;NAME_2&#39;:&#39;name_subregion&#39;,\
                &#39;NAME_1&#39;:&#39;name_region&#39;,\
                &#39;HASC_2&#39;:&#39;code_subregion&#39;},inplace=True)
            self._country_data[&#39;code_region&#39;]=self._country_data.code_subregion.str.slice(stop=5)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
        # --- &#39;MYS&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;MYS&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;)).dissolve(by=&#39;nam&#39;).reset_index()
            self._country_data[&#39;name_subregion&#39;]=[n.title() for n in self._country_data.nam]
            self._country_data[&#39;code_subregion&#39;]=self._country_data.name_subregion
            self._country_data[&#39;code_region&#39;]=&#39;MYS&#39;
            self._country_data[&#39;name_region&#39;]=&#39;Malaysia&#39;
            self._country_data[&#39;code_subregion&#39;]=self._country_data.code_subregion
            # to help the join procedure with current covid data, some translation
            dict_subregion={\
                &#39;Wilayah Persekutuan Labuan&#39;:&#39;W.P. Labuan&#39;,\
                &#39;Wilayah Persekutuan&#39;:&#39;W.P. Kuala Lumpur&#39;,\
                }
            self._country_data.loc[self._country_data.code_subregion.isin(list(dict_subregion.keys())),&#39;code_subregion&#39;] = \
                [dict_subregion[x] for x in self._country_data.code_subregion if x in list(dict_subregion.keys())]
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]
        # --- &#39;CHL&#39; case --------------------------------------------------------------------------------------------
        elif self._country == &#39;CHL&#39;:
            self._country_data = gpd.read_file(&#39;zip://&#39;+get_local_from_url(url,0,&#39;.zip&#39;),encoding=&#39;utf-8&#39;)
            self._country_data.rename(columns={\
                &#39;NOM_REG&#39;:&#39;name_region&#39;,\
                &#39;NOM_COM&#39;:&#39;name_subregion&#39;},inplace=True)
            self._country_data[&#39;code_subregion&#39;]=[str(c).zfill(5) for c in self._country_data.COD_COMUNA]
            self._country_data[&#39;code_region&#39;]=self._country_data.code_subregion.str.slice(stop=2)
            self._country_data=self._country_data[[&#39;name_subregion&#39;,&#39;code_subregion&#39;,&#39;name_region&#39;,&#39;code_region&#39;,&#39;geometry&#39;]]

    # def get_region_from_municipality(self,lname):
    #     &#34;&#34;&#34;  Return region list from a municipality list
    #     &#34;&#34;&#34;
    #     if not isinstance(lname, list):
    #         lname=[lname]
    #     return self._municipality_region.loc[self._municipality_region.name.isin(lname)][&#39;district&#39;].to_list()

    def get_source(self):
        &#34;&#34;&#34; Return informations about URL sources
        &#34;&#34;&#34;
        if self.get_country() != None:
            return self._source_dict[self.get_country()]
        else:
            return self._source_dict

    def get_country(self):
        &#34;&#34;&#34; Return the current country used.
        &#34;&#34;&#34;
        return self._country

    def get_list_countries(self):
        &#34;&#34;&#34; This function returns back the list of supported countries
        &#34;&#34;&#34;
        return sorted(list(self._country_info_dict.keys()))

    def is_init(self):
        &#34;&#34;&#34;Test if the country is initialized. Return True if it is. False if not.
        &#34;&#34;&#34;
        if self.get_country() != None:
            return True
        else:
            return False

    def test_is_init(self):
        &#34;&#34;&#34;Test if the country is initialized. If not, raise a CoaDbError.
        &#34;&#34;&#34;
        if self.is_init():
            return True
        else:
            raise CoaDbError(&#34;The country is not set. Use a constructor with non empty country string.&#34;)

    def get_region_list(self):
        &#34;&#34;&#34; Return the list of available regions with code, name and geometry
        &#34;&#34;&#34;
        cols=[c for c in self.get_list_properties() if &#39;_region&#39; in c]
        cols.append(&#39;geometry&#39;)
        return self.get_data(True)[cols]

    def is_region(self,r):
        &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
        &#34;&#34;&#34;
        r=tostdstring(r)
        for i in self.get_region_list().name_region.to_list():
            if tostdstring(i) == r:
                return i
        return False

    def get_subregion_list(self):
        &#34;&#34;&#34; Return the list of available subregions with code, name and geometry
        &#34;&#34;&#34;
        cols=[c for c in self.get_list_properties() if &#39;_subregion&#39; in c ]
        cols.append(&#39;geometry&#39;)
        return self.get_data()[cols]

    def is_subregion(self,r):
        &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
        &#34;&#34;&#34;
        r2=tostdstring(r)
        for i in self.get_subregion_list().name_subregion.to_list():
            if tostdstring(i) == r2:
                return i
        a=self.get_subregion_list()[self.get_subregion_list().code_subregion==r].name_subregion.values
        if a.size == 1:
            return a[0]
        return False

    def get_subregions_from_region(self,**kwargs):
        &#34;&#34;&#34; Return the list of subregions within a specified region.
        Should give either the code or the name of the region as strings in kwarg : code=# or name=#
        Output default is &#39;code&#39; of subregions. Can be changer with output=&#39;name&#39;.
        &#34;&#34;&#34;
        kwargs_test(kwargs,[&#39;name&#39;,&#39;code&#39;,&#39;output&#39;],&#39;Should give either name or code of region. Output can be changed with the output option.&#39;)
        code=kwargs.get(&#34;code&#34;,None)
        name=kwargs.get(&#34;name&#34;,None)
        out=kwargs.get(&#34;output&#34;,&#39;code&#39;)
        if not (code == None) ^ (name == None):
            raise CoaKeyError(&#34;Should give either code or name of region, not both.&#34;)
        if not out in [&#39;code&#39;,&#39;name&#39;]:
            raise CoaKeyError(&#34;Should set output either as &#39;code&#39; or &#39;name&#39; for subregions.&#34;)

        if name != None:
            if not isinstance(name,str):
                raise CoaTypeError(&#34;Name should be given as string.&#34;)
            if not name in self.get_region_list()[&#39;name_region&#39;].to_list():
                raise CoaWhereError (&#34;The region &#34;+name+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
            cut=(self.get_data(True)[&#39;name_region&#39;]==name)

        if code != None:
            if not isinstance(code,str):
                raise CoaTypeError(&#34;Name should be given as string.&#34;)
            if not code in self.get_region_list()[&#39;code_region&#39;].to_list():
                raise CoaWhereError(&#34;The region &#34;+code+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
            cut=(self.get_data(True)[&#39;code_region&#39;]==code)

        return self.get_data(True)[cut][out+&#39;_subregion&#39;].iloc[0]#to_list()

    def get_subregions_from_list_of_region_names(self,l,output=&#39;code&#39;):
        &#34;&#34;&#34; Return the list of subregions according to list of region names given.
        The output argument (&#39;code&#39; as default) is given to the get_subregions_from_region function.
        &#34;&#34;&#34;
        if not isinstance(l,list):
            raise CoaTypeError(&#34;Should provide list as argument&#34;)
        s=[]
        for r in l:
            s=s+self.get_subregions_from_region(name=r,output=output)
        return s

    def get_list_properties(self):
        &#34;&#34;&#34;Return the list of available properties for the current country
        &#34;&#34;&#34;
        if self.test_is_init():
            return sorted(self._country_data.columns.to_list())

    def get_data(self,region_version=False):
        &#34;&#34;&#34;Return the whole geopandas data.
        If region_version = True (not default), the pandas output is region based focalized.
        &#34;&#34;&#34;
        if self.test_is_init():
            if region_version:
                if not isinstance(self._country_data_region,pd.DataFrame): # i.e. is None
                    col_reg=[c for c in self._country_data.columns.tolist() if &#39;_region&#39; in c]
                    col=col_reg.copy()
                    col.append(&#39;geometry&#39;) # to merge the geometry of subregions
                    for p in self.get_list_properties():
                        if (&#39;_subregion&#39; in p) and pd.api.types.is_numeric_dtype(self._country_data[p]):
                            col.append(p)
                    if not &#39;code_subregion&#39; in col:
                        col.append(&#39;code_subregion&#39;) # to get the list of subregion in region
                    if not &#39;name_subregion&#39; in col:
                        col.append(&#39;name_subregion&#39;) # to get the list of subregion name in region

                    pr=self._country_data[col].copy()

                    # Country specific management
                    if self.get_country()==&#39;FRA&#39;: # manage pseudo &#39;FRA&#39; regions &#39;Métropole&#39; and &#39;Outre-mer&#39;
                        metropole_cut=pr.code_region.astype(int)&gt;=10
                        pr_metropole=pr[metropole_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;999&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;Métropole&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;
                        pr_outremer=pr[~metropole_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;000&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Outre-mer&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;ESP&#39; : # manage pseudo &#39;ESP&#39; regions within and outside continent
                        islands_cut=pr.code_region.astype(int).isin([&#39;05&#39;])
                        pr_metropole=pr[~islands_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;99&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;España peninsular&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                        pr_outremer=pr[islands_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;00&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Islas españolas&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;PRT&#39; : # manage pseudo &#39;PRT&#39; regions within and outside continent
                        islands_cut=pr.code_region.isin([&#39;PT.AC&#39;,&#39;PT.MA&#39;])
                        pr_metropole=pr[~islands_cut].copy()
                        pr_metropole[&#39;code_region&#39;]=&#39;PT.99&#39;
                        pr_metropole[&#39;name_region&#39;]=&#39;Portugal continental&#39;
                        pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                        pr_outremer=pr[islands_cut].copy()
                        pr_outremer[&#39;code_region&#39;]=&#39;PT.00&#39;
                        pr_outremer[&#39;name_region&#39;]=&#39;Ilhas portuguesas&#39;
                        pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                        pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                    elif self.get_country()==&#39;USA&#39;:
                        usa_col=pr.columns.tolist()
                        #usa_col.remove(&#39;population_subregion&#39;) # Remove numeric column, if not, the dissolve does not work properly
                        #usa_col.remove(&#39;area_subregion&#39;) # idem
                        pr=pr[usa_col]

                    pr[&#39;code_subregion&#39;]=pr.code_subregion.apply(lambda x: [x])
                    pr[&#39;name_subregion&#39;]=pr.name_subregion.apply(lambda x: [x])
                    self._country_data_region=pr.dissolve(by=col_reg,aggfunc=(lambda x: x.sum())).sort_values(by=&#39;code_region&#39;).reset_index()
                    for x in [&#39;population&#39;,&#39;area&#39;]:
                        if x+&#39;_subregion&#39; in self._country_data_region.columns:
                            self._country_data_region.rename(columns={x+&#39;_subregion&#39;:x+&#39;_region&#39;},inplace=True)

                return self._country_data_region
            else:
                if not isinstance(self._country_data_subregion,pd.DataFrame): #i.e. is None
                    self._country_data_subregion=self._country_data.sort_values(by=&#39;code_subregion&#39;)
                return self._country_data_subregion

    def add_field(self,**kwargs):
        &#34;&#34;&#34;Return a the data pandas.Dataframe with an additionnal column with property prop.

        Arguments :
        input        : pandas.Dataframe object. Mandatory.
        field        : field of properties to add. Should be within the get_list_prop() list. Mandatory.
        input_key    : input geo key of the input pandas dataframe. Default  &#39;where&#39;
        geofield     : internal geo field to make the merge. Default &#39;code_subregion&#39;
        region_merging : Boolean value. Default False, except if the geofield contains &#39;_region&#39;.
                       If True, the merge between input dans GeoCountry data is done within the
                       region version of the data, not the subregion data which is the default
                       behavious.
        overload   : Allow to overload a field. Boolean value. Default : False
        &#34;&#34;&#34;

        # Test of args
        kwargs_test(kwargs,[&#39;input&#39;,&#39;field&#39;,&#39;input_key&#39;,&#39;geofield&#39;,&#39;geotype&#39;,&#39;overload&#39;],
            &#39;Bad args used in the add_field() function.&#39;)

        # Testing input
        data=kwargs.get(&#39;input&#39;,None) # the panda
        if not isinstance(data,pd.DataFrame):
            raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
                &#39; DataFrame as input. See help.&#39;)
        data=data.copy()

        # Testing input_key
        input_key=kwargs.get(&#39;input_key&#39;,&#39;where&#39;)
        if not isinstance(input_key,str):
            raise CoaTypeError(&#39;The input_key should be given as a string.&#39;)
        if input_key not in data.columns.tolist():
            raise CoaKeyError(&#39;The input_key &#34;&#39;+input_key+&#39;&#34; given is &#39;
                &#39;not a valid column name of the input pandas dataframe.&#39;)

        # Testing geofield
        geofield=kwargs.get(&#39;geofield&#39;,&#39;code_subregion&#39;)
        if not isinstance(geofield,str):
            raise CoaTypeError(&#39;The geofield should be given as a string.&#39;)
        if geofield not in self._country_data.columns.tolist():
            raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
                &#39;not a valid column name of the available data. &#39;
                &#39;See get_list_properties() for valid fields.&#39;)

        region_merging=kwargs.get(&#39;region_merging&#39;,None)
        if region_merging == None:
            if &#39;_region&#39; in geofield:
                region_merging=True
            else:
                region_merging=False

        if not isinstance(region_merging,bool):
            raise CoaKeyError(&#39;The region_mergin key should be boolean. See help.&#39;)

        # Testing fields
        prop=kwargs.get(&#39;field&#39;,None) # field list
        if prop == None:
            raise CoaKeyError(&#39;No field given. See help.&#39;)
        if not isinstance(prop,list):
            prop=[prop] # make the prop input a list if needed

        if not all(isinstance(p, str) for p in prop):
            raise CoaTypeError(&#34;Each property should be a string whereas &#34;+str(prop)+&#34; is not a list of string.&#34;)

        if not all(p in self.get_list_properties() for p in prop):
            raise CoaKeyError(&#34;The property &#34;+prop+&#34; is not available for country &#34;+self.get_country()+&#34;.&#34;)

        # Testing overload
        overload=kwargs.get(&#39;overload&#39;,False)
        if not isinstance(overload,bool):
            raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

        if not overload and not all(p not in data.columns.tolist() for p in prop):
            raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
                &#39;dataframe columns. You may set overload to True.&#39;)

        # Is the oject properly initialized ?
        self.test_is_init()

        # Now let&#39;s go for merging
        prop.append(&#39;code_subregion&#39;)
        return data.merge(self.get_data(region_merging)[prop],how=&#39;left&#39;,left_on=input_key,\
                            right_on=geofield)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coa.geo.GeoCountry.add_field"><code class="name flex">
<span>def <span class="ident">add_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a the data pandas.Dataframe with an additionnal column with property prop.</p>
<p>Arguments :
input
: pandas.Dataframe object. Mandatory.
field
: field of properties to add. Should be within the get_list_prop() list. Mandatory.
input_key
: input geo key of the input pandas dataframe. Default
'where'
geofield
: internal geo field to make the merge. Default 'code_subregion'
region_merging : Boolean value. Default False, except if the geofield contains '_region'.
If True, the merge between input dans GeoCountry data is done within the
region version of the data, not the subregion data which is the default
behavious.
overload
: Allow to overload a field. Boolean value. Default : False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_field(self,**kwargs):
    &#34;&#34;&#34;Return a the data pandas.Dataframe with an additionnal column with property prop.

    Arguments :
    input        : pandas.Dataframe object. Mandatory.
    field        : field of properties to add. Should be within the get_list_prop() list. Mandatory.
    input_key    : input geo key of the input pandas dataframe. Default  &#39;where&#39;
    geofield     : internal geo field to make the merge. Default &#39;code_subregion&#39;
    region_merging : Boolean value. Default False, except if the geofield contains &#39;_region&#39;.
                   If True, the merge between input dans GeoCountry data is done within the
                   region version of the data, not the subregion data which is the default
                   behavious.
    overload   : Allow to overload a field. Boolean value. Default : False
    &#34;&#34;&#34;

    # Test of args
    kwargs_test(kwargs,[&#39;input&#39;,&#39;field&#39;,&#39;input_key&#39;,&#39;geofield&#39;,&#39;geotype&#39;,&#39;overload&#39;],
        &#39;Bad args used in the add_field() function.&#39;)

    # Testing input
    data=kwargs.get(&#39;input&#39;,None) # the panda
    if not isinstance(data,pd.DataFrame):
        raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
            &#39; DataFrame as input. See help.&#39;)
    data=data.copy()

    # Testing input_key
    input_key=kwargs.get(&#39;input_key&#39;,&#39;where&#39;)
    if not isinstance(input_key,str):
        raise CoaTypeError(&#39;The input_key should be given as a string.&#39;)
    if input_key not in data.columns.tolist():
        raise CoaKeyError(&#39;The input_key &#34;&#39;+input_key+&#39;&#34; given is &#39;
            &#39;not a valid column name of the input pandas dataframe.&#39;)

    # Testing geofield
    geofield=kwargs.get(&#39;geofield&#39;,&#39;code_subregion&#39;)
    if not isinstance(geofield,str):
        raise CoaTypeError(&#39;The geofield should be given as a string.&#39;)
    if geofield not in self._country_data.columns.tolist():
        raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
            &#39;not a valid column name of the available data. &#39;
            &#39;See get_list_properties() for valid fields.&#39;)

    region_merging=kwargs.get(&#39;region_merging&#39;,None)
    if region_merging == None:
        if &#39;_region&#39; in geofield:
            region_merging=True
        else:
            region_merging=False

    if not isinstance(region_merging,bool):
        raise CoaKeyError(&#39;The region_mergin key should be boolean. See help.&#39;)

    # Testing fields
    prop=kwargs.get(&#39;field&#39;,None) # field list
    if prop == None:
        raise CoaKeyError(&#39;No field given. See help.&#39;)
    if not isinstance(prop,list):
        prop=[prop] # make the prop input a list if needed

    if not all(isinstance(p, str) for p in prop):
        raise CoaTypeError(&#34;Each property should be a string whereas &#34;+str(prop)+&#34; is not a list of string.&#34;)

    if not all(p in self.get_list_properties() for p in prop):
        raise CoaKeyError(&#34;The property &#34;+prop+&#34; is not available for country &#34;+self.get_country()+&#34;.&#34;)

    # Testing overload
    overload=kwargs.get(&#39;overload&#39;,False)
    if not isinstance(overload,bool):
        raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

    if not overload and not all(p not in data.columns.tolist() for p in prop):
        raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
            &#39;dataframe columns. You may set overload to True.&#39;)

    # Is the oject properly initialized ?
    self.test_is_init()

    # Now let&#39;s go for merging
    prop.append(&#39;code_subregion&#39;)
    return data.merge(self.get_data(region_merging)[prop],how=&#39;left&#39;,left_on=input_key,\
                        right_on=geofield)</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_country"><code class="name flex">
<span>def <span class="ident">get_country</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current country used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_country(self):
    &#34;&#34;&#34; Return the current country used.
    &#34;&#34;&#34;
    return self._country</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, region_version=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the whole geopandas data.
If region_version = True (not default), the pandas output is region based focalized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self,region_version=False):
    &#34;&#34;&#34;Return the whole geopandas data.
    If region_version = True (not default), the pandas output is region based focalized.
    &#34;&#34;&#34;
    if self.test_is_init():
        if region_version:
            if not isinstance(self._country_data_region,pd.DataFrame): # i.e. is None
                col_reg=[c for c in self._country_data.columns.tolist() if &#39;_region&#39; in c]
                col=col_reg.copy()
                col.append(&#39;geometry&#39;) # to merge the geometry of subregions
                for p in self.get_list_properties():
                    if (&#39;_subregion&#39; in p) and pd.api.types.is_numeric_dtype(self._country_data[p]):
                        col.append(p)
                if not &#39;code_subregion&#39; in col:
                    col.append(&#39;code_subregion&#39;) # to get the list of subregion in region
                if not &#39;name_subregion&#39; in col:
                    col.append(&#39;name_subregion&#39;) # to get the list of subregion name in region

                pr=self._country_data[col].copy()

                # Country specific management
                if self.get_country()==&#39;FRA&#39;: # manage pseudo &#39;FRA&#39; regions &#39;Métropole&#39; and &#39;Outre-mer&#39;
                    metropole_cut=pr.code_region.astype(int)&gt;=10
                    pr_metropole=pr[metropole_cut].copy()
                    pr_metropole[&#39;code_region&#39;]=&#39;999&#39;
                    pr_metropole[&#39;name_region&#39;]=&#39;Métropole&#39;
                    pr_metropole[&#39;flag_region&#39;]=&#39;&#39;
                    pr_outremer=pr[~metropole_cut].copy()
                    pr_outremer[&#39;code_region&#39;]=&#39;000&#39;
                    pr_outremer[&#39;name_region&#39;]=&#39;Outre-mer&#39;
                    pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                    pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                elif self.get_country()==&#39;ESP&#39; : # manage pseudo &#39;ESP&#39; regions within and outside continent
                    islands_cut=pr.code_region.astype(int).isin([&#39;05&#39;])
                    pr_metropole=pr[~islands_cut].copy()
                    pr_metropole[&#39;code_region&#39;]=&#39;99&#39;
                    pr_metropole[&#39;name_region&#39;]=&#39;España peninsular&#39;
                    pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                    pr_outremer=pr[islands_cut].copy()
                    pr_outremer[&#39;code_region&#39;]=&#39;00&#39;
                    pr_outremer[&#39;name_region&#39;]=&#39;Islas españolas&#39;
                    pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                    pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                elif self.get_country()==&#39;PRT&#39; : # manage pseudo &#39;PRT&#39; regions within and outside continent
                    islands_cut=pr.code_region.isin([&#39;PT.AC&#39;,&#39;PT.MA&#39;])
                    pr_metropole=pr[~islands_cut].copy()
                    pr_metropole[&#39;code_region&#39;]=&#39;PT.99&#39;
                    pr_metropole[&#39;name_region&#39;]=&#39;Portugal continental&#39;
                    pr_metropole[&#39;flag_region&#39;]=&#39;&#39;

                    pr_outremer=pr[islands_cut].copy()
                    pr_outremer[&#39;code_region&#39;]=&#39;PT.00&#39;
                    pr_outremer[&#39;name_region&#39;]=&#39;Ilhas portuguesas&#39;
                    pr_outremer[&#39;flag_region&#39;]=&#39;&#39;

                    pr=pr.append(pr_metropole,ignore_index=True).append(pr_outremer,ignore_index=True)

                elif self.get_country()==&#39;USA&#39;:
                    usa_col=pr.columns.tolist()
                    #usa_col.remove(&#39;population_subregion&#39;) # Remove numeric column, if not, the dissolve does not work properly
                    #usa_col.remove(&#39;area_subregion&#39;) # idem
                    pr=pr[usa_col]

                pr[&#39;code_subregion&#39;]=pr.code_subregion.apply(lambda x: [x])
                pr[&#39;name_subregion&#39;]=pr.name_subregion.apply(lambda x: [x])
                self._country_data_region=pr.dissolve(by=col_reg,aggfunc=(lambda x: x.sum())).sort_values(by=&#39;code_region&#39;).reset_index()
                for x in [&#39;population&#39;,&#39;area&#39;]:
                    if x+&#39;_subregion&#39; in self._country_data_region.columns:
                        self._country_data_region.rename(columns={x+&#39;_subregion&#39;:x+&#39;_region&#39;},inplace=True)

            return self._country_data_region
        else:
            if not isinstance(self._country_data_subregion,pd.DataFrame): #i.e. is None
                self._country_data_subregion=self._country_data.sort_values(by=&#39;code_subregion&#39;)
            return self._country_data_subregion</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_list_countries"><code class="name flex">
<span>def <span class="ident">get_list_countries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns back the list of supported countries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_countries(self):
    &#34;&#34;&#34; This function returns back the list of supported countries
    &#34;&#34;&#34;
    return sorted(list(self._country_info_dict.keys()))</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_list_properties"><code class="name flex">
<span>def <span class="ident">get_list_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of available properties for the current country</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_properties(self):
    &#34;&#34;&#34;Return the list of available properties for the current country
    &#34;&#34;&#34;
    if self.test_is_init():
        return sorted(self._country_data.columns.to_list())</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_region_list"><code class="name flex">
<span>def <span class="ident">get_region_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of available regions with code, name and geometry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_region_list(self):
    &#34;&#34;&#34; Return the list of available regions with code, name and geometry
    &#34;&#34;&#34;
    cols=[c for c in self.get_list_properties() if &#39;_region&#39; in c]
    cols.append(&#39;geometry&#39;)
    return self.get_data(True)[cols]</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_source"><code class="name flex">
<span>def <span class="ident">get_source</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return informations about URL sources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source(self):
    &#34;&#34;&#34; Return informations about URL sources
    &#34;&#34;&#34;
    if self.get_country() != None:
        return self._source_dict[self.get_country()]
    else:
        return self._source_dict</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_subregion_list"><code class="name flex">
<span>def <span class="ident">get_subregion_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of available subregions with code, name and geometry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subregion_list(self):
    &#34;&#34;&#34; Return the list of available subregions with code, name and geometry
    &#34;&#34;&#34;
    cols=[c for c in self.get_list_properties() if &#39;_subregion&#39; in c ]
    cols.append(&#39;geometry&#39;)
    return self.get_data()[cols]</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_subregions_from_list_of_region_names"><code class="name flex">
<span>def <span class="ident">get_subregions_from_list_of_region_names</span></span>(<span>self, l, output='code')</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of subregions according to list of region names given.
The output argument ('code' as default) is given to the get_subregions_from_region function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subregions_from_list_of_region_names(self,l,output=&#39;code&#39;):
    &#34;&#34;&#34; Return the list of subregions according to list of region names given.
    The output argument (&#39;code&#39; as default) is given to the get_subregions_from_region function.
    &#34;&#34;&#34;
    if not isinstance(l,list):
        raise CoaTypeError(&#34;Should provide list as argument&#34;)
    s=[]
    for r in l:
        s=s+self.get_subregions_from_region(name=r,output=output)
    return s</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.get_subregions_from_region"><code class="name flex">
<span>def <span class="ident">get_subregions_from_region</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of subregions within a specified region.
Should give either the code or the name of the region as strings in kwarg : code=# or name=#
Output default is 'code' of subregions. Can be changer with output='name'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subregions_from_region(self,**kwargs):
    &#34;&#34;&#34; Return the list of subregions within a specified region.
    Should give either the code or the name of the region as strings in kwarg : code=# or name=#
    Output default is &#39;code&#39; of subregions. Can be changer with output=&#39;name&#39;.
    &#34;&#34;&#34;
    kwargs_test(kwargs,[&#39;name&#39;,&#39;code&#39;,&#39;output&#39;],&#39;Should give either name or code of region. Output can be changed with the output option.&#39;)
    code=kwargs.get(&#34;code&#34;,None)
    name=kwargs.get(&#34;name&#34;,None)
    out=kwargs.get(&#34;output&#34;,&#39;code&#39;)
    if not (code == None) ^ (name == None):
        raise CoaKeyError(&#34;Should give either code or name of region, not both.&#34;)
    if not out in [&#39;code&#39;,&#39;name&#39;]:
        raise CoaKeyError(&#34;Should set output either as &#39;code&#39; or &#39;name&#39; for subregions.&#34;)

    if name != None:
        if not isinstance(name,str):
            raise CoaTypeError(&#34;Name should be given as string.&#34;)
        if not name in self.get_region_list()[&#39;name_region&#39;].to_list():
            raise CoaWhereError (&#34;The region &#34;+name+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
        cut=(self.get_data(True)[&#39;name_region&#39;]==name)

    if code != None:
        if not isinstance(code,str):
            raise CoaTypeError(&#34;Name should be given as string.&#34;)
        if not code in self.get_region_list()[&#39;code_region&#39;].to_list():
            raise CoaWhereError(&#34;The region &#34;+code+&#34; does not exist for country &#34;+self.get_country()+&#34;. See get_region_list().&#34;)
        cut=(self.get_data(True)[&#39;code_region&#39;]==code)

    return self.get_data(True)[cut][out+&#39;_subregion&#39;].iloc[0]#to_list()</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.is_init"><code class="name flex">
<span>def <span class="ident">is_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the country is initialized. Return True if it is. False if not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_init(self):
    &#34;&#34;&#34;Test if the country is initialized. Return True if it is. False if not.
    &#34;&#34;&#34;
    if self.get_country() != None:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.is_region"><code class="name flex">
<span>def <span class="ident">is_region</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Return False if r is a not a known region, return the correctly capitalized name if ok</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_region(self,r):
    &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
    &#34;&#34;&#34;
    r=tostdstring(r)
    for i in self.get_region_list().name_region.to_list():
        if tostdstring(i) == r:
            return i
    return False</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.is_subregion"><code class="name flex">
<span>def <span class="ident">is_subregion</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Return False if r is a not a known region, return the correctly capitalized name if ok</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_subregion(self,r):
    &#34;&#34;&#34; Return False if r is a not a known region, return the correctly capitalized name if ok
    &#34;&#34;&#34;
    r2=tostdstring(r)
    for i in self.get_subregion_list().name_subregion.to_list():
        if tostdstring(i) == r2:
            return i
    a=self.get_subregion_list()[self.get_subregion_list().code_subregion==r].name_subregion.values
    if a.size == 1:
        return a[0]
    return False</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoCountry.test_is_init"><code class="name flex">
<span>def <span class="ident">test_is_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test if the country is initialized. If not, raise a CoaDbError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_init(self):
    &#34;&#34;&#34;Test if the country is initialized. If not, raise a CoaDbError.
    &#34;&#34;&#34;
    if self.is_init():
        return True
    else:
        raise CoaDbError(&#34;The country is not set. Use a constructor with non empty country string.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="coa.geo.GeoInfo"><code class="flex name class">
<span>class <span class="ident">GeoInfo</span></span>
<span>(</span><span>gm=0)</span>
</code></dt>
<dd>
<div class="desc"><p>GeoInfo class definition. No inheritance from any other class.</p>
<p>It should raise only CoaError and derived exceptions in case
of errors (see pycoa.error)</p>
<p><strong>init</strong> member function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoInfo():
    &#34;&#34;&#34;GeoInfo class definition. No inheritance from any other class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _list_field={\
        &#39;continent_code&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39;,\
        &#39;continent_name&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39; ,\
        &#39;country_name&#39;:&#39;pycountry_convert (https://pypi.org/project/pycountry-convert/)&#39; ,\
        &#39;population&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;area&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;fertility&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;median_age&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        &#39;urban_rate&#39;:&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,\
        #&#39;geometry&#39;:&#39;https://github.com/johan/world.geo.json/&#39;,\
        &#39;geometry&#39;:&#39;http://thematicmapping.org/downloads/world_borders.php and https://github.com/johan/world.geo.json/&#39;,\
        &#39;region_code_list&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;region_name_list&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;capital&#39;:&#39;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#39;,\
        #https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#39;,\
        &#39;flag&#39;:&#39;https://github.com/linssen/country-flag-icons/blob/master/countries.json&#39;,\
        }

    _data_geometry = pd.DataFrame()
    _data_population = pd.DataFrame()
    _data_flag = pd.DataFrame()

    def __init__(self,gm=0):
        &#34;&#34;&#34; __init__ member function.
        &#34;&#34;&#34;
        verb(&#34;Init of GeoInfo() from &#34;+str(inspect.stack()[1]))
        if gm != 0:
            self._gm=gm
        else:
            self._gm=GeoManager()

        self._grp=self._gm._gr.get_pandas()

    def get_GeoManager(self):
        &#34;&#34;&#34; return the local instance of used GeoManager()
        &#34;&#34;&#34;
        return self._gm

    def get_list_field(self):
        &#34;&#34;&#34; return the list of supported additionnal fields available
        &#34;&#34;&#34;
        return sorted(list(self._list_field.keys()))

    def get_source(self,field=None):
        &#34;&#34;&#34; return the source of the information provided for a given
        field.
        &#34;&#34;&#34;
        if field==None:
            return self._list_field
        elif field not in self.get_list_field():
            raise CoaKeyError(&#39;The field &#34;&#39;+str(field)+&#39;&#34; is not &#39;
                &#39;a supported field of GeoInfo(). Please see help or &#39;
                &#39;the get_list_field() output.&#39;)
        return field+&#39; : &#39;+self._list_field[field]


    def add_field(self,**kwargs):
        &#34;&#34;&#34; this is the main function of the GeoInfo class. It adds to
        the input pandas dataframe some fields according to
        the geofield field of input.
        The return value is the pandas dataframe.

        Arguments :
        field    -- should be given as a string of list of strings and
                    should be valid fields (see get_list_field() )
                    Mandatory.
        input    -- provide the input pandas dataframe. Mandatory.
        geofield -- provide the field name in the pandas where the
                    location is stored. Default : &#39;location&#39;
        overload -- Allow to overload a field. Boolean value.
                    Default : False
        &#34;&#34;&#34;

        # --- kwargs analysis ---

        kwargs_test(kwargs,[&#39;field&#39;,&#39;input&#39;,&#39;geofield&#39;,&#39;overload&#39;],
            &#39;Bad args used in the add_field() function.&#39;)

        p=kwargs.get(&#39;input&#39;,None) # the panda
        if not isinstance(p,pd.DataFrame):
            raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
                &#39; DataFrame as input. See help.&#39;)
        p=p.copy()

        overload=kwargs.get(&#39;overload&#39;,False)
        if not isinstance(overload,bool):
            raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

        fl=kwargs.get(&#39;field&#39;,None) # field list
        if fl == None:
            raise CoaKeyError(&#39;No field given. See help.&#39;)
        if not isinstance(fl,list):
            fl=[fl]
        if not all(f in self.get_list_field() for f in fl):
            raise CoaKeyError(&#39;All fields are not valid or supported &#39;
                &#39;ones. Please see help of get_list_field()&#39;)

        if not overload and not all(f not in p.columns.tolist() for f in fl):
            raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
                &#39;dataframe columns. You may set overload to True.&#39;)

        geofield=kwargs.get(&#39;geofield&#39;,&#39;location&#39;)

        if not isinstance(geofield,str):
            raise CoaTypeError(&#39;The geofield should be given as a &#39;
                &#39;string.&#39;)
        if geofield not in p.columns.tolist():
            raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
                &#39;not a valid column name of the input pandas dataframe.&#39;)

        self._gm.set_standard(&#39;iso2&#39;)
        countries_iso2=self._gm.to_standard(p[geofield].tolist())
        self._gm.set_standard(&#39;iso3&#39;)
        countries_iso3=self._gm.to_standard(p[geofield].tolist())

        p[&#39;iso2_tmp&#39;]=countries_iso2
        p[&#39;iso3_tmp&#39;]=countries_iso3

        # --- loop over all needed fields ---
        for f in fl:
            if f in p.columns.tolist():
                p=p.drop(f,axis=1)
            # ----------------------------------------------------------
            if f == &#39;continent_code&#39;:
                p[f] = [pcc.country_alpha2_to_continent_code(k) for k in countries_iso2]
            # ----------------------------------------------------------
            elif f == &#39;continent_name&#39;:
                p[f] = [pcc.convert_continent_code_to_continent_name( \
                    pcc.country_alpha2_to_continent_code(k) ) for k in countries_iso2 ]
            # ----------------------------------------------------------
            elif f == &#39;country_name&#39;:
                p[f] = [pcc.country_alpha2_to_country_name(k) for k in countries_iso2]
            # ----------------------------------------------------------
            elif f in [&#39;population&#39;,&#39;area&#39;,&#39;fertility&#39;,&#39;median_age&#39;,&#39;urban_rate&#39;]:
                if self._data_population.empty:

                    field_descr=( (0,&#39;&#39;,&#39;idx&#39;),
                        (1,&#39;Country&#39;,&#39;country&#39;),
                        (2,&#39;Population&#39;,&#39;population&#39;),
                        (6,&#39;Land Area&#39;,&#39;area&#39;),
                        (8,&#39;Fert&#39;,&#39;fertility&#39;),
                        (9,&#39;Med&#39;,&#39;median_age&#39;),
                        (10,&#39;Urban&#39;,&#39;urban_rate&#39;),
                        ) # containts tuples with position in table, name of column, new name of field

                    # get data with cache ok for about 1 month
                    self._data_population = pd.read_html(get_local_from_url(&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,30e5) ) [0].iloc[:,[x[0] for x in field_descr]]

                    # test that field order hasn&#39;t changed in the db
                    if not all (col.startswith(field_descr[i][1]) for i,col in enumerate(self._data_population.columns) ):
                        raise CoaDbError(&#39;The worldometers database changed its field names. &#39;
                            &#39;The GeoInfo should be updated. Please contact developers.&#39;)

                    # change field name
                    self._data_population.columns = [x[2] for x in field_descr]

                    # standardization of country name
                    self._data_population[&#39;iso3_tmp2&#39;]=\
                        self._gm.to_standard(self._data_population[&#39;country&#39;].tolist(),\
                        db=&#39;worldometers&#39;)

                p=p.merge(self._data_population[[&#34;iso3_tmp2&#34;,f]],how=&#39;left&#39;,\
                        left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3_tmp2&#39;,\
                        suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;iso3_tmp2&#39;],axis=1)

            # ----------------------------------------------------------
            elif f in [&#39;region_code_list&#39;,&#39;region_name_list&#39;]:

                if f == &#39;region_code_list&#39;:
                    ff = &#39;region&#39;
                elif f == &#39;region_name_list&#39;:
                    ff = &#39;region_name&#39;

                p[f]=p.merge(self._grp[[&#39;iso3&#39;,ff]],how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;)) \
                    .groupby(&#39;iso3_tmp&#39;)[ff].apply(list).to_list()
            # ----------------------------------------------------------
            elif f in [&#39;capital&#39;]:
                p[f]=p.merge(self._grp[[&#39;iso3&#39;,f]].drop_duplicates(), \
                    how=&#39;left&#39;,left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;))[f]

            # ----------------------------------------------------------
            elif f == &#39;geometry&#39;:
                if self._data_geometry.empty:
                    #geojsondatafile = &#39;https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json&#39;
                    #self._data_geometry = gpd.read_file(get_local_from_url(geojsondatafile,0,&#39;.json&#39;))[[&#34;id&#34;,&#34;geometry&#34;]]
                    world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip&#39; # too much simplified version ?
                    # world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip&#39; # too precize version ?
                    self._data_geometry = gpd.read_file(&#39;zip://&#39;+get_local_from_url(world_geometry_url_zipfile,0,&#39;.zip&#39;))[[&#39;ISO3&#39;,&#39;geometry&#39;]]
                    self._data_geometry.columns=[&#34;id_tmp&#34;,&#34;geometry&#34;]

                    # About some countries not properly managed by this database (south and north soudan)
                    self._data_geometry=self._data_geometry.append({&#39;id_tmp&#39;:&#39;SSD&#39;,&#39;geometry&#39;:None},ignore_index=True) # adding the SSD row
                    for newc in [&#39;SSD&#39;,&#39;SDN&#39;]:
                        newgeo=gpd.read_file(get_local_from_url(&#39;https://github.com/johan/world.geo.json/raw/master/countries/&#39;+newc+&#39;.geo.json&#39;))
                        poly=newgeo[newgeo.id==newc].geometry.values[0]
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                    # About countries that we artificially put on the east of the map
                    for newc in [&#39;RUS&#39;,&#39;FJI&#39;,&#39;NZL&#39;,&#39;WSM&#39;]:
                        poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                        poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x,y) if x&gt;=0 else (x+360,y) for x,y in p.exterior.coords]) for p in poly]))
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                    # About countries that we artificially put on the west of the map
                    for newc in [&#39;USA&#39;]:
                        poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                        poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x-360,y) if x&gt;=0 else (x,y) for x,y in p.exterior.coords]) for p in poly]))
                        self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                p=p.merge(self._data_geometry,how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;id_tmp&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;id_tmp&#39;],axis=1)

            # -----------------------------------------------------------
            elif f == &#39;flag&#39;:
                if self._data_flag.empty:
                    self._data_flag = pd.read_json(get_local_from_url(&#39;https://github.com/linssen/country-flag-icons/raw/master/countries.json&#39;,0))
                    self._data_flag[&#39;flag_url&#39;]=&#39;http:&#39;+self._data_flag[&#39;file_url&#39;]

                p=p.merge(self._data_flag[[&#39;alpha3&#39;,&#39;flag_url&#39;]],how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;alpha3&#39;).drop([&#39;alpha3&#39;],axis=1)

        return p.drop([&#39;iso2_tmp&#39;,&#39;iso3_tmp&#39;],axis=1,errors=&#39;ignore&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coa.geo.GeoInfo.add_field"><code class="name flex">
<span>def <span class="ident">add_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>this is the main function of the GeoInfo class. It adds to
the input pandas dataframe some fields according to
the geofield field of input.
The return value is the pandas dataframe.</p>
<p>Arguments :
field
&ndash; should be given as a string of list of strings and
should be valid fields (see get_list_field() )
Mandatory.
input
&ndash; provide the input pandas dataframe. Mandatory.
geofield &ndash; provide the field name in the pandas where the
location is stored. Default : 'location'
overload &ndash; Allow to overload a field. Boolean value.
Default : False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_field(self,**kwargs):
    &#34;&#34;&#34; this is the main function of the GeoInfo class. It adds to
    the input pandas dataframe some fields according to
    the geofield field of input.
    The return value is the pandas dataframe.

    Arguments :
    field    -- should be given as a string of list of strings and
                should be valid fields (see get_list_field() )
                Mandatory.
    input    -- provide the input pandas dataframe. Mandatory.
    geofield -- provide the field name in the pandas where the
                location is stored. Default : &#39;location&#39;
    overload -- Allow to overload a field. Boolean value.
                Default : False
    &#34;&#34;&#34;

    # --- kwargs analysis ---

    kwargs_test(kwargs,[&#39;field&#39;,&#39;input&#39;,&#39;geofield&#39;,&#39;overload&#39;],
        &#39;Bad args used in the add_field() function.&#39;)

    p=kwargs.get(&#39;input&#39;,None) # the panda
    if not isinstance(p,pd.DataFrame):
        raise CoaTypeError(&#39;You should provide a valid input pandas&#39;
            &#39; DataFrame as input. See help.&#39;)
    p=p.copy()

    overload=kwargs.get(&#39;overload&#39;,False)
    if not isinstance(overload,bool):
        raise CoaTypeError(&#39;The overload option should be a boolean.&#39;)

    fl=kwargs.get(&#39;field&#39;,None) # field list
    if fl == None:
        raise CoaKeyError(&#39;No field given. See help.&#39;)
    if not isinstance(fl,list):
        fl=[fl]
    if not all(f in self.get_list_field() for f in fl):
        raise CoaKeyError(&#39;All fields are not valid or supported &#39;
            &#39;ones. Please see help of get_list_field()&#39;)

    if not overload and not all(f not in p.columns.tolist() for f in fl):
        raise CoaKeyError(&#39;Some fields already exist in you panda &#39;
            &#39;dataframe columns. You may set overload to True.&#39;)

    geofield=kwargs.get(&#39;geofield&#39;,&#39;location&#39;)

    if not isinstance(geofield,str):
        raise CoaTypeError(&#39;The geofield should be given as a &#39;
            &#39;string.&#39;)
    if geofield not in p.columns.tolist():
        raise CoaKeyError(&#39;The geofield &#34;&#39;+geofield+&#39;&#34; given is &#39;
            &#39;not a valid column name of the input pandas dataframe.&#39;)

    self._gm.set_standard(&#39;iso2&#39;)
    countries_iso2=self._gm.to_standard(p[geofield].tolist())
    self._gm.set_standard(&#39;iso3&#39;)
    countries_iso3=self._gm.to_standard(p[geofield].tolist())

    p[&#39;iso2_tmp&#39;]=countries_iso2
    p[&#39;iso3_tmp&#39;]=countries_iso3

    # --- loop over all needed fields ---
    for f in fl:
        if f in p.columns.tolist():
            p=p.drop(f,axis=1)
        # ----------------------------------------------------------
        if f == &#39;continent_code&#39;:
            p[f] = [pcc.country_alpha2_to_continent_code(k) for k in countries_iso2]
        # ----------------------------------------------------------
        elif f == &#39;continent_name&#39;:
            p[f] = [pcc.convert_continent_code_to_continent_name( \
                pcc.country_alpha2_to_continent_code(k) ) for k in countries_iso2 ]
        # ----------------------------------------------------------
        elif f == &#39;country_name&#39;:
            p[f] = [pcc.country_alpha2_to_country_name(k) for k in countries_iso2]
        # ----------------------------------------------------------
        elif f in [&#39;population&#39;,&#39;area&#39;,&#39;fertility&#39;,&#39;median_age&#39;,&#39;urban_rate&#39;]:
            if self._data_population.empty:

                field_descr=( (0,&#39;&#39;,&#39;idx&#39;),
                    (1,&#39;Country&#39;,&#39;country&#39;),
                    (2,&#39;Population&#39;,&#39;population&#39;),
                    (6,&#39;Land Area&#39;,&#39;area&#39;),
                    (8,&#39;Fert&#39;,&#39;fertility&#39;),
                    (9,&#39;Med&#39;,&#39;median_age&#39;),
                    (10,&#39;Urban&#39;,&#39;urban_rate&#39;),
                    ) # containts tuples with position in table, name of column, new name of field

                # get data with cache ok for about 1 month
                self._data_population = pd.read_html(get_local_from_url(&#39;https://www.worldometers.info/world-population/population-by-country/&#39;,30e5) ) [0].iloc[:,[x[0] for x in field_descr]]

                # test that field order hasn&#39;t changed in the db
                if not all (col.startswith(field_descr[i][1]) for i,col in enumerate(self._data_population.columns) ):
                    raise CoaDbError(&#39;The worldometers database changed its field names. &#39;
                        &#39;The GeoInfo should be updated. Please contact developers.&#39;)

                # change field name
                self._data_population.columns = [x[2] for x in field_descr]

                # standardization of country name
                self._data_population[&#39;iso3_tmp2&#39;]=\
                    self._gm.to_standard(self._data_population[&#39;country&#39;].tolist(),\
                    db=&#39;worldometers&#39;)

            p=p.merge(self._data_population[[&#34;iso3_tmp2&#34;,f]],how=&#39;left&#39;,\
                    left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3_tmp2&#39;,\
                    suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;iso3_tmp2&#39;],axis=1)

        # ----------------------------------------------------------
        elif f in [&#39;region_code_list&#39;,&#39;region_name_list&#39;]:

            if f == &#39;region_code_list&#39;:
                ff = &#39;region&#39;
            elif f == &#39;region_name_list&#39;:
                ff = &#39;region_name&#39;

            p[f]=p.merge(self._grp[[&#39;iso3&#39;,ff]],how=&#39;left&#39;,\
                left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                suffixes=(&#39;&#39;,&#39;_tmp&#39;)) \
                .groupby(&#39;iso3_tmp&#39;)[ff].apply(list).to_list()
        # ----------------------------------------------------------
        elif f in [&#39;capital&#39;]:
            p[f]=p.merge(self._grp[[&#39;iso3&#39;,f]].drop_duplicates(), \
                how=&#39;left&#39;,left_on=&#39;iso3_tmp&#39;,right_on=&#39;iso3&#39;,\
                suffixes=(&#39;&#39;,&#39;_tmp&#39;))[f]

        # ----------------------------------------------------------
        elif f == &#39;geometry&#39;:
            if self._data_geometry.empty:
                #geojsondatafile = &#39;https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json&#39;
                #self._data_geometry = gpd.read_file(get_local_from_url(geojsondatafile,0,&#39;.json&#39;))[[&#34;id&#34;,&#34;geometry&#34;]]
                world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip&#39; # too much simplified version ?
                # world_geometry_url_zipfile=&#39;http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip&#39; # too precize version ?
                self._data_geometry = gpd.read_file(&#39;zip://&#39;+get_local_from_url(world_geometry_url_zipfile,0,&#39;.zip&#39;))[[&#39;ISO3&#39;,&#39;geometry&#39;]]
                self._data_geometry.columns=[&#34;id_tmp&#34;,&#34;geometry&#34;]

                # About some countries not properly managed by this database (south and north soudan)
                self._data_geometry=self._data_geometry.append({&#39;id_tmp&#39;:&#39;SSD&#39;,&#39;geometry&#39;:None},ignore_index=True) # adding the SSD row
                for newc in [&#39;SSD&#39;,&#39;SDN&#39;]:
                    newgeo=gpd.read_file(get_local_from_url(&#39;https://github.com/johan/world.geo.json/raw/master/countries/&#39;+newc+&#39;.geo.json&#39;))
                    poly=newgeo[newgeo.id==newc].geometry.values[0]
                    self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                # About countries that we artificially put on the east of the map
                for newc in [&#39;RUS&#39;,&#39;FJI&#39;,&#39;NZL&#39;,&#39;WSM&#39;]:
                    poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                    poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x,y) if x&gt;=0 else (x+360,y) for x,y in p.exterior.coords]) for p in poly]))
                    self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

                # About countries that we artificially put on the west of the map
                for newc in [&#39;USA&#39;]:
                    poly=self._data_geometry[self._data_geometry.id_tmp==newc].geometry.values[0]
                    poly=so.unary_union(sg.MultiPolygon([sg.Polygon([(x-360,y) if x&gt;=0 else (x,y) for x,y in p.exterior.coords]) for p in poly]))
                    self._data_geometry.loc[self._data_geometry.id_tmp==newc,&#39;geometry&#39;]=gpd.GeoSeries(poly).values

            p=p.merge(self._data_geometry,how=&#39;left&#39;,\
                left_on=&#39;iso3_tmp&#39;,right_on=&#39;id_tmp&#39;,\
                suffixes=(&#39;&#39;,&#39;_tmp&#39;)).drop([&#39;id_tmp&#39;],axis=1)

        # -----------------------------------------------------------
        elif f == &#39;flag&#39;:
            if self._data_flag.empty:
                self._data_flag = pd.read_json(get_local_from_url(&#39;https://github.com/linssen/country-flag-icons/raw/master/countries.json&#39;,0))
                self._data_flag[&#39;flag_url&#39;]=&#39;http:&#39;+self._data_flag[&#39;file_url&#39;]

            p=p.merge(self._data_flag[[&#39;alpha3&#39;,&#39;flag_url&#39;]],how=&#39;left&#39;,\
                left_on=&#39;iso3_tmp&#39;,right_on=&#39;alpha3&#39;).drop([&#39;alpha3&#39;],axis=1)

    return p.drop([&#39;iso2_tmp&#39;,&#39;iso3_tmp&#39;],axis=1,errors=&#39;ignore&#39;)</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoInfo.get_GeoManager"><code class="name flex">
<span>def <span class="ident">get_GeoManager</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the local instance of used GeoManager()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_GeoManager(self):
    &#34;&#34;&#34; return the local instance of used GeoManager()
    &#34;&#34;&#34;
    return self._gm</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoInfo.get_list_field"><code class="name flex">
<span>def <span class="ident">get_list_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the list of supported additionnal fields available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_field(self):
    &#34;&#34;&#34; return the list of supported additionnal fields available
    &#34;&#34;&#34;
    return sorted(list(self._list_field.keys()))</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoInfo.get_source"><code class="name flex">
<span>def <span class="ident">get_source</span></span>(<span>self, field=None)</span>
</code></dt>
<dd>
<div class="desc"><p>return the source of the information provided for a given
field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source(self,field=None):
    &#34;&#34;&#34; return the source of the information provided for a given
    field.
    &#34;&#34;&#34;
    if field==None:
        return self._list_field
    elif field not in self.get_list_field():
        raise CoaKeyError(&#39;The field &#34;&#39;+str(field)+&#39;&#34; is not &#39;
            &#39;a supported field of GeoInfo(). Please see help or &#39;
            &#39;the get_list_field() output.&#39;)
    return field+&#39; : &#39;+self._list_field[field]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="coa.geo.GeoManager"><code class="flex name class">
<span>class <span class="ident">GeoManager</span></span>
<span>(</span><span>standard='iso2')</span>
</code></dt>
<dd>
<div class="desc"><p>GeoManager class definition. No inheritance from any other class.</p>
<p>It should raise only CoaError and derived exceptions in case
of errors (see pycoa.error)</p>
<p><strong>init</strong> member function, with default definition of
the used standard. To get the current default standard,
see get_list_standard()[0].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoManager():
    &#34;&#34;&#34;GeoManager class definition. No inheritance from any other class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _list_standard=[&#39;iso2&#39;,   # Iso2 standard, default
            &#39;iso3&#39;,           # Iso3 standard
            &#39;name&#39;,           # Standard name ( != Official, caution )
            &#39;num&#39;]            # Numeric standard

    _list_db=[None,&#39;jhu&#39;,&#39;worldometers&#39;,&#39;owid&#39;,&#39;opencovid19national&#39;,&#39;spfnational&#39;] # first is default
    _list_output=[&#39;list&#39;,&#39;dict&#39;,&#39;pandas&#39;] # first is default

    _standard = None # currently used normalisation standard

    def __init__(self,standard=_list_standard[0]):
        &#34;&#34;&#34; __init__ member function, with default definition of
        the used standard. To get the current default standard,
        see get_list_standard()[0].
        &#34;&#34;&#34;
        verb(&#34;Init of GeoManager() from &#34;+str(inspect.stack()[1]))
        self.set_standard(standard)
        self._gr=GeoRegion()

    def get_GeoRegion(self):
        &#34;&#34;&#34; return the GeoRegion local instance
        &#34;&#34;&#34;
        return self._gr

    def get_region_list(self):
        &#34;&#34;&#34; return the list of region via the GeoRegion instance
        &#34;&#34;&#34;
        return self._gr.get_region_list()

    def get_list_standard(self):
        &#34;&#34;&#34; return the list of supported standard name of countries.
        First one is default for the class
        &#34;&#34;&#34;
        return self._list_standard

    def get_list_output(self):
        &#34;&#34;&#34; return supported list of output type. First one is default
        for the class
        &#34;&#34;&#34;
        return self._list_output

    def get_list_db(self):
        &#34;&#34;&#34; return supported list of database name for translation of
        country names to standard.
        &#34;&#34;&#34;
        return self._list_db

    def get_standard(self):
        &#34;&#34;&#34; return current standard use within the GeoManager class
        &#34;&#34;&#34;
        return self._standard

    def set_standard(self,standard):
        &#34;&#34;&#34;
        set the working standard type within the GeoManager class.
        The standard should meet the get_list_standard() requirement
        &#34;&#34;&#34;
        if not isinstance(standard,str):
            raise CoaTypeError(&#39;GeoManager error, the standard argument&#39;
                &#39; must be a string&#39;)
        if standard not in self.get_list_standard():
            raise CoaKeyError(&#39;GeoManager.set_standard error, &#34;&#39;+\
                                    standard+&#39; not managed. Please see &#39;\
                                    &#39;get_list_standard() function&#39;)
        self._standard=standard
        return self.get_standard()

    def to_standard(self, w, **kwargs):
        &#34;&#34;&#34;Given a list of string of locations (countries), returns a
        normalised list according to the used standard (defined
        via the setStandard() or __init__ function. Current default is iso2.

        Arguments
        -----------------
        first arg        --  w, list of string of locations (or single string)
                             to convert to standard one

        output           -- &#39;list&#39; (default), &#39;dict&#39; or &#39;pandas&#39;
        db               -- database name to help conversion.
                            Default : None, meaning best effort to convert.
                            Known database : jhu, wordometer...
                            See get_list_db() for full list of known db for
                            standardization
        interpret_region -- Boolean, default=False. If yes, the output should
                            be only &#39;list&#39;.
        &#34;&#34;&#34;

        kwargs_test(kwargs,[&#39;output&#39;,&#39;db&#39;,&#39;interpret_region&#39;],&#39;Bad args used in the to_standard() function.&#39;)

        output=kwargs.get(&#39;output&#39;,self.get_list_output()[0])
        if output not in self.get_list_output():
            raise CoaKeyError(&#39;Incorrect output type. See get_list_output()&#39;
                &#39; or help.&#39;)

        db=kwargs.get(&#39;db&#39;,self.get_list_db()[0])
        if db not in self.get_list_db():
            raise CoaDbError(&#39;Unknown database &#34;&#39;+db+&#39;&#34; for translation to &#39;
                &#39;standardized location names. See get_list_db() or help.&#39;)

        interpret_region=kwargs.get(&#39;interpret_region&#39;,False)
        if not isinstance(interpret_region,bool):
            raise CoaTypeError(&#39;The interpret_region argument is a boolean, &#39;
                &#39;not a &#39;+str(type(interpret_region)))

        if interpret_region==True and output!=&#39;list&#39;:
            raise CoaKeyError(&#39;The interpret_region True argument is incompatible &#39;
                &#39;with non list output option.&#39;)

        if isinstance(w,str):
            w=[w]
        elif not isinstance(w,list):
            raise CoaTypeError(&#39;Waiting for str, list of str or pandas&#39;
                &#39;as input of get_standard function member of GeoManager&#39;)

        w=[v.title() for v in w] # capitalize first letter of each name

        w0=w.copy()

        if db:
            w=self.first_db_translation(w,db)
        n=[] # will contain standardized name of countries (if possible)

        #for c in w:
        while len(w)&gt;0:
            c=w.pop(0)
            if type(c)==int:
                c=str(c)
            elif type(c)!=str:
                raise CoaTypeError(&#39;Locations should be given as &#39;
                    &#39;strings or integers only&#39;)
            if (c in self._gr.get_region_list()) and interpret_region == True:
                w=self._gr.get_countries_from_region(c)+w
            else:
                if len(c)==0:
                    n1=&#39;&#39; #None
                else:
                    try:
                        n0=pc.countries.lookup(c)
                    except LookupError:
                        try:
                            if c.startswith(&#39;Owid_&#39;):
                                nf=[&#39;owid_*&#39;]
                                n1=&#39;OWID_*&#39;
                            else:
                                nf=pc.countries.search_fuzzy(c)
                            if len(nf)&gt;1:
                                warnings.warn(&#39;Caution. More than one country match the key &#34;&#39;+\
                                c+&#39;&#34; : &#39;+str([ (k.name+&#39;, &#39;) for k in nf])+\
                                &#39;, using first one.\n&#39;)
                            n0=nf[0]
                        except LookupError:
                            raise CoaLookupError(&#39;No country match the key &#34;&#39;+c+&#39;&#34;. Error.&#39;)
                        except Exception as e1:
                            raise CoaNotManagedError(&#39;Not managed error &#39;+type(e1))
                    except Exception as e2:
                        raise CoaNotManagedError(&#39;Not managed error&#39;+type(e1))

                    if n0 != &#39;owid_*&#39;:
                        if self._standard==&#39;iso2&#39;:
                            n1=n0.alpha_2
                        elif self._standard==&#39;iso3&#39;:
                            n1=n0.alpha_3
                        elif self._standard==&#39;name&#39;:
                            n1=n0.name
                        elif self._standard==&#39;num&#39;:
                            n1=n0.numeric
                        else:
                            raise CoaKeyError(&#39;Current standard is &#39;+self._standard+\
                                &#39; which is not managed. Error.&#39;)

                n.append(n1)

        if output==&#39;list&#39;:
            return n
        elif output==&#39;dict&#39;:
            return dict(zip(w0, n))
        elif output==&#39;pandas&#39;:
            return pd.DataFrame({&#39;inputname&#39;:w0,self._standard:n})
        else:
            return None # should not be here

    def first_db_translation(self,w,db):
        &#34;&#34;&#34; This function helps to translate from country name to
        standard for specific databases. It&#39;s the first step
        before final translation.

        One can easily add some database support adding some new rules
        for specific databases
        &#34;&#34;&#34;
        translation_dict={}
        # Caution : keys need to be in title mode, i.e. first letter capitalized
        if db==&#39;jhu&#39;:
            translation_dict.update({\
                &#34;Congo (Brazzaville)&#34;:&#34;Republic of the Congo&#34;,\
                &#34;Congo (Kinshasa)&#34;:&#34;COD&#34;,\
                &#34;Korea, South&#34;:&#34;KOR&#34;,\
                &#34;Taiwan*&#34;:&#34;Taiwan&#34;,\
                &#34;Laos&#34;:&#34;LAO&#34;,\
                &#34;West Bank And Gaza&#34;:&#34;PSE&#34;,\
                &#34;Burma&#34;:&#34;Myanmar&#34;,\
                &#34;Iran&#34;:&#34;IRN&#34;,\
                &#34;Diamond Princess&#34;:&#34;&#34;,\
                &#34;Ms Zaandam&#34;:&#34;&#34;,\
                &#34;Summer Olympics 2020&#34;:&#34;&#34;,\
                &#34;Micronesia&#34;:&#34;FSM&#34;,\
                    })  # last two are names of boats
        elif db==&#39;worldometers&#39;:
            translation_dict.update({\
                &#34;Dr Congo&#34;:&#34;COD&#34;,\
                &#34;Congo&#34;:&#34;COG&#34;,\
                &#34;Iran&#34;:&#34;IRN&#34;,\
                &#34;South Korea&#34;:&#34;KOR&#34;,\
                &#34;North Korea&#34;:&#34;PRK&#34;,\
                &#34;Czech Republic (Czechia)&#34;:&#34;CZE&#34;,\
                &#34;Laos&#34;:&#34;LAO&#34;,\
                &#34;Sao Tome &amp; Principe&#34;:&#34;STP&#34;,\
                &#34;Channel Islands&#34;:&#34;JEY&#34;,\
                &#34;St. Vincent &amp; Grenadines&#34;:&#34;VCT&#34;,\
                &#34;U.S. Virgin Islands&#34;:&#34;VIR&#34;,\
                &#34;Saint Kitts &amp; Nevis&#34;:&#34;KNA&#34;,\
                &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                &#34;Caribbean Netherlands&#34;:&#34;BES&#34;,\
                &#34;Wallis &amp; Futuna&#34;:&#34;WLF&#34;,\
                &#34;Saint Pierre &amp; Miquelon&#34;:&#34;SPM&#34;,\
                &#34;Sint Maarten&#34;:&#34;SXM&#34;,\
                } )
        elif db==&#39;owid&#39;:
            translation_dict.update({\
                    &#34;Bonaire Sint Eustatius And Saba&#34;:&#34;BES&#34;,\
                    &#34;Cape Verde&#34;:&#34;CPV&#34;,\
                    &#34;Democratic Republic Of Congo&#34;:&#34;COD&#34;,\
                    &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                    &#34;Laos&#34;:&#34;LAO&#34;,\
                    &#34;South Korea&#34;:&#34;KOR&#34;,\
                    &#34;Swaziland&#34;:&#34;SWZ&#34;,\
                    &#34;United States Virgin Islands&#34;:&#34;VIR&#34;,\
                    &#34;Iran&#34;:&#34;IRN&#34;,\
                    &#34;Micronesia (Country)&#34;:&#34;FSM&#34;,\
                    &#34;Northern Cyprus&#34;:&#34;CYP&#34;,\
                    &#34;Curacao&#34;:&#34;CUW&#34;,\
                    &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                    &#34;Vatican&#34;:&#34;VAT&#34;
                })
        return [translation_dict.get(k,k) for k in w]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coa.geo.GeoManager.first_db_translation"><code class="name flex">
<span>def <span class="ident">first_db_translation</span></span>(<span>self, w, db)</span>
</code></dt>
<dd>
<div class="desc"><p>This function helps to translate from country name to
standard for specific databases. It's the first step
before final translation.</p>
<p>One can easily add some database support adding some new rules
for specific databases</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_db_translation(self,w,db):
    &#34;&#34;&#34; This function helps to translate from country name to
    standard for specific databases. It&#39;s the first step
    before final translation.

    One can easily add some database support adding some new rules
    for specific databases
    &#34;&#34;&#34;
    translation_dict={}
    # Caution : keys need to be in title mode, i.e. first letter capitalized
    if db==&#39;jhu&#39;:
        translation_dict.update({\
            &#34;Congo (Brazzaville)&#34;:&#34;Republic of the Congo&#34;,\
            &#34;Congo (Kinshasa)&#34;:&#34;COD&#34;,\
            &#34;Korea, South&#34;:&#34;KOR&#34;,\
            &#34;Taiwan*&#34;:&#34;Taiwan&#34;,\
            &#34;Laos&#34;:&#34;LAO&#34;,\
            &#34;West Bank And Gaza&#34;:&#34;PSE&#34;,\
            &#34;Burma&#34;:&#34;Myanmar&#34;,\
            &#34;Iran&#34;:&#34;IRN&#34;,\
            &#34;Diamond Princess&#34;:&#34;&#34;,\
            &#34;Ms Zaandam&#34;:&#34;&#34;,\
            &#34;Summer Olympics 2020&#34;:&#34;&#34;,\
            &#34;Micronesia&#34;:&#34;FSM&#34;,\
                })  # last two are names of boats
    elif db==&#39;worldometers&#39;:
        translation_dict.update({\
            &#34;Dr Congo&#34;:&#34;COD&#34;,\
            &#34;Congo&#34;:&#34;COG&#34;,\
            &#34;Iran&#34;:&#34;IRN&#34;,\
            &#34;South Korea&#34;:&#34;KOR&#34;,\
            &#34;North Korea&#34;:&#34;PRK&#34;,\
            &#34;Czech Republic (Czechia)&#34;:&#34;CZE&#34;,\
            &#34;Laos&#34;:&#34;LAO&#34;,\
            &#34;Sao Tome &amp; Principe&#34;:&#34;STP&#34;,\
            &#34;Channel Islands&#34;:&#34;JEY&#34;,\
            &#34;St. Vincent &amp; Grenadines&#34;:&#34;VCT&#34;,\
            &#34;U.S. Virgin Islands&#34;:&#34;VIR&#34;,\
            &#34;Saint Kitts &amp; Nevis&#34;:&#34;KNA&#34;,\
            &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
            &#34;Caribbean Netherlands&#34;:&#34;BES&#34;,\
            &#34;Wallis &amp; Futuna&#34;:&#34;WLF&#34;,\
            &#34;Saint Pierre &amp; Miquelon&#34;:&#34;SPM&#34;,\
            &#34;Sint Maarten&#34;:&#34;SXM&#34;,\
            } )
    elif db==&#39;owid&#39;:
        translation_dict.update({\
                &#34;Bonaire Sint Eustatius And Saba&#34;:&#34;BES&#34;,\
                &#34;Cape Verde&#34;:&#34;CPV&#34;,\
                &#34;Democratic Republic Of Congo&#34;:&#34;COD&#34;,\
                &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                &#34;Laos&#34;:&#34;LAO&#34;,\
                &#34;South Korea&#34;:&#34;KOR&#34;,\
                &#34;Swaziland&#34;:&#34;SWZ&#34;,\
                &#34;United States Virgin Islands&#34;:&#34;VIR&#34;,\
                &#34;Iran&#34;:&#34;IRN&#34;,\
                &#34;Micronesia (Country)&#34;:&#34;FSM&#34;,\
                &#34;Northern Cyprus&#34;:&#34;CYP&#34;,\
                &#34;Curacao&#34;:&#34;CUW&#34;,\
                &#34;Faeroe Islands&#34;:&#34;FRO&#34;,\
                &#34;Vatican&#34;:&#34;VAT&#34;
            })
    return [translation_dict.get(k,k) for k in w]</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_GeoRegion"><code class="name flex">
<span>def <span class="ident">get_GeoRegion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the GeoRegion local instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_GeoRegion(self):
    &#34;&#34;&#34; return the GeoRegion local instance
    &#34;&#34;&#34;
    return self._gr</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_list_db"><code class="name flex">
<span>def <span class="ident">get_list_db</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return supported list of database name for translation of
country names to standard.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_db(self):
    &#34;&#34;&#34; return supported list of database name for translation of
    country names to standard.
    &#34;&#34;&#34;
    return self._list_db</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_list_output"><code class="name flex">
<span>def <span class="ident">get_list_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return supported list of output type. First one is default
for the class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_output(self):
    &#34;&#34;&#34; return supported list of output type. First one is default
    for the class
    &#34;&#34;&#34;
    return self._list_output</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_list_standard"><code class="name flex">
<span>def <span class="ident">get_list_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the list of supported standard name of countries.
First one is default for the class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_standard(self):
    &#34;&#34;&#34; return the list of supported standard name of countries.
    First one is default for the class
    &#34;&#34;&#34;
    return self._list_standard</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_region_list"><code class="name flex">
<span>def <span class="ident">get_region_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the list of region via the GeoRegion instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_region_list(self):
    &#34;&#34;&#34; return the list of region via the GeoRegion instance
    &#34;&#34;&#34;
    return self._gr.get_region_list()</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.get_standard"><code class="name flex">
<span>def <span class="ident">get_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return current standard use within the GeoManager class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_standard(self):
    &#34;&#34;&#34; return current standard use within the GeoManager class
    &#34;&#34;&#34;
    return self._standard</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.set_standard"><code class="name flex">
<span>def <span class="ident">set_standard</span></span>(<span>self, standard)</span>
</code></dt>
<dd>
<div class="desc"><p>set the working standard type within the GeoManager class.
The standard should meet the get_list_standard() requirement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_standard(self,standard):
    &#34;&#34;&#34;
    set the working standard type within the GeoManager class.
    The standard should meet the get_list_standard() requirement
    &#34;&#34;&#34;
    if not isinstance(standard,str):
        raise CoaTypeError(&#39;GeoManager error, the standard argument&#39;
            &#39; must be a string&#39;)
    if standard not in self.get_list_standard():
        raise CoaKeyError(&#39;GeoManager.set_standard error, &#34;&#39;+\
                                standard+&#39; not managed. Please see &#39;\
                                &#39;get_list_standard() function&#39;)
    self._standard=standard
    return self.get_standard()</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoManager.to_standard"><code class="name flex">
<span>def <span class="ident">to_standard</span></span>(<span>self, w, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a list of string of locations (countries), returns a
normalised list according to the used standard (defined
via the setStandard() or <strong>init</strong> function. Current default is iso2.</p>
<h2 id="arguments">Arguments</h2>
<p>first arg
&ndash;
w, list of string of locations (or single string)
to convert to standard one</p>
<p>output
&ndash; 'list' (default), 'dict' or 'pandas'
db
&ndash; database name to help conversion.
Default : None, meaning best effort to convert.
Known database : jhu, wordometer&hellip;
See get_list_db() for full list of known db for
standardization
interpret_region &ndash; Boolean, default=False. If yes, the output should
be only 'list'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_standard(self, w, **kwargs):
    &#34;&#34;&#34;Given a list of string of locations (countries), returns a
    normalised list according to the used standard (defined
    via the setStandard() or __init__ function. Current default is iso2.

    Arguments
    -----------------
    first arg        --  w, list of string of locations (or single string)
                         to convert to standard one

    output           -- &#39;list&#39; (default), &#39;dict&#39; or &#39;pandas&#39;
    db               -- database name to help conversion.
                        Default : None, meaning best effort to convert.
                        Known database : jhu, wordometer...
                        See get_list_db() for full list of known db for
                        standardization
    interpret_region -- Boolean, default=False. If yes, the output should
                        be only &#39;list&#39;.
    &#34;&#34;&#34;

    kwargs_test(kwargs,[&#39;output&#39;,&#39;db&#39;,&#39;interpret_region&#39;],&#39;Bad args used in the to_standard() function.&#39;)

    output=kwargs.get(&#39;output&#39;,self.get_list_output()[0])
    if output not in self.get_list_output():
        raise CoaKeyError(&#39;Incorrect output type. See get_list_output()&#39;
            &#39; or help.&#39;)

    db=kwargs.get(&#39;db&#39;,self.get_list_db()[0])
    if db not in self.get_list_db():
        raise CoaDbError(&#39;Unknown database &#34;&#39;+db+&#39;&#34; for translation to &#39;
            &#39;standardized location names. See get_list_db() or help.&#39;)

    interpret_region=kwargs.get(&#39;interpret_region&#39;,False)
    if not isinstance(interpret_region,bool):
        raise CoaTypeError(&#39;The interpret_region argument is a boolean, &#39;
            &#39;not a &#39;+str(type(interpret_region)))

    if interpret_region==True and output!=&#39;list&#39;:
        raise CoaKeyError(&#39;The interpret_region True argument is incompatible &#39;
            &#39;with non list output option.&#39;)

    if isinstance(w,str):
        w=[w]
    elif not isinstance(w,list):
        raise CoaTypeError(&#39;Waiting for str, list of str or pandas&#39;
            &#39;as input of get_standard function member of GeoManager&#39;)

    w=[v.title() for v in w] # capitalize first letter of each name

    w0=w.copy()

    if db:
        w=self.first_db_translation(w,db)
    n=[] # will contain standardized name of countries (if possible)

    #for c in w:
    while len(w)&gt;0:
        c=w.pop(0)
        if type(c)==int:
            c=str(c)
        elif type(c)!=str:
            raise CoaTypeError(&#39;Locations should be given as &#39;
                &#39;strings or integers only&#39;)
        if (c in self._gr.get_region_list()) and interpret_region == True:
            w=self._gr.get_countries_from_region(c)+w
        else:
            if len(c)==0:
                n1=&#39;&#39; #None
            else:
                try:
                    n0=pc.countries.lookup(c)
                except LookupError:
                    try:
                        if c.startswith(&#39;Owid_&#39;):
                            nf=[&#39;owid_*&#39;]
                            n1=&#39;OWID_*&#39;
                        else:
                            nf=pc.countries.search_fuzzy(c)
                        if len(nf)&gt;1:
                            warnings.warn(&#39;Caution. More than one country match the key &#34;&#39;+\
                            c+&#39;&#34; : &#39;+str([ (k.name+&#39;, &#39;) for k in nf])+\
                            &#39;, using first one.\n&#39;)
                        n0=nf[0]
                    except LookupError:
                        raise CoaLookupError(&#39;No country match the key &#34;&#39;+c+&#39;&#34;. Error.&#39;)
                    except Exception as e1:
                        raise CoaNotManagedError(&#39;Not managed error &#39;+type(e1))
                except Exception as e2:
                    raise CoaNotManagedError(&#39;Not managed error&#39;+type(e1))

                if n0 != &#39;owid_*&#39;:
                    if self._standard==&#39;iso2&#39;:
                        n1=n0.alpha_2
                    elif self._standard==&#39;iso3&#39;:
                        n1=n0.alpha_3
                    elif self._standard==&#39;name&#39;:
                        n1=n0.name
                    elif self._standard==&#39;num&#39;:
                        n1=n0.numeric
                    else:
                        raise CoaKeyError(&#39;Current standard is &#39;+self._standard+\
                            &#39; which is not managed. Error.&#39;)

            n.append(n1)

    if output==&#39;list&#39;:
        return n
    elif output==&#39;dict&#39;:
        return dict(zip(w0, n))
    elif output==&#39;pandas&#39;:
        return pd.DataFrame({&#39;inputname&#39;:w0,self._standard:n})
    else:
        return None # should not be here</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="coa.geo.GeoRegion"><code class="flex name class">
<span>class <span class="ident">GeoRegion</span></span>
</code></dt>
<dd>
<div class="desc"><p>GeoRegion class definition. Does not inheritate from any other
class.</p>
<p>It should raise only CoaError and derived exceptions in case
of errors (see pycoa.error)</p>
<p><strong>init</strong> member function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoRegion():
    &#34;&#34;&#34;GeoRegion class definition. Does not inheritate from any other
    class.

    It should raise only CoaError and derived exceptions in case
    of errors (see pycoa.error)
    &#34;&#34;&#34;

    _source_dict={&#34;UN_M49&#34;:&#34;https://en.wikipedia.org/w/index.php?title=UN_M49&amp;oldid=986603718&#34;, # pointing the previous correct ref . https://en.wikipedia.org/wiki/UN_M49&#34;,\
        &#34;GeoScheme&#34;:&#34;https://en.wikipedia.org/w/index.php?title=List_of_countries_by_United_Nations_geoscheme&amp;oldid=1008989486&#34;, #pointing the previous correct ref. https://en.wikipedia.org/wiki/List_of_countries_by_United_Nations_geoscheme&#34;,
        &#34;European Union&#34;:&#34;https://europa.eu/european-union/about-eu/countries/member-countries_en&#34;,
        &#34;G7&#34;:&#34;https://en.wikipedia.org/wiki/Group_of_Seven&#34;,
        &#34;G8&#34;:&#34;https://en.wikipedia.org/wiki/Group_of_Eight&#34;,
        &#34;G20&#34;:&#34;https://en.wikipedia.org/wiki/G20&#34;,
        &#34;G77&#34;:&#34;https://www.g77.org/doc/members.html&#34;,
        &#34;OECD&#34;:&#34;https://en.wikipedia.org/wiki/OECD&#34;,
        &#34;Commonwealth&#34;:&#34;https://en.wikipedia.org/wiki/Member_states_of_the_Commonwealth_of_Nations&#34;,
        }

    _region_dict={}
    _p_gs = pd.DataFrame()

    def __init__(self,):
        &#34;&#34;&#34; __init__ member function.
        &#34;&#34;&#34;
        #if &#39;XK&#39; in self._country_list:
        #    del self._country_list[&#39;XK&#39;] # creates bugs in pycountry and is currently a contested country as country


        # --- get the UN M49 information and organize the data in the _region_dict

        verb(&#34;Init of GeoRegion() from &#34;+str(inspect.stack()[1]))

        p_m49=pd.read_html(get_local_from_url(self._source_dict[&#34;UN_M49&#34;],0))[1]

        p_m49.columns=[&#39;code&#39;,&#39;region_name&#39;]
        p_m49[&#39;region_name&#39;]=[r.split(&#39;(&#39;)[0].rstrip().title() for r in p_m49.region_name]  # suppress information in parenthesis in region name
        p_m49.set_index(&#39;code&#39;)

        self._region_dict.update(p_m49.to_dict(&#39;split&#39;)[&#39;data&#39;])
        self._region_dict.update({  &#34;UE&#34;:&#34;European Union&#34;,
                                    &#34;G7&#34;:&#34;G7&#34;,
                                    &#34;G8&#34;:&#34;G8&#34;,
                                    &#34;G20&#34;:&#34;G20&#34;,
                                    &#34;OECD&#34;:&#34;Oecd&#34;,
                                    &#34;G77&#34;:&#34;G77&#34;,
                                    &#34;CW&#34;:&#34;Commonwealth&#34;
                                    })  # add UE for other analysis

        # --- filling cw information
        p_cw=pd.read_html(get_local_from_url(&#39;https://en.wikipedia.org/wiki/Member_states_of_the_Commonwealth_of_Nations&#39;))
        self._cw=[w.split(&#39;[&#39;)[0] for w in p_cw[0][&#39;Country&#39;].to_list()]   # removing wikipedia notes

        # --- get the UnitedNation GeoScheme and organize the data
        p_gs=pd.read_html(get_local_from_url(self._source_dict[&#34;GeoScheme&#34;],0))[0]
        p_gs.columns=[&#39;country&#39;,&#39;capital&#39;,&#39;iso2&#39;,&#39;iso3&#39;,&#39;num&#39;,&#39;m49&#39;]

        idx=[]
        reg=[]
        cap=[]

        for index, row in p_gs.iterrows():
            if row.iso3 != &#39;–&#39; : # meaning a non standard iso in wikipedia UN GeoScheme
                for r in row.m49.replace(&#34; &#34;,&#34;&#34;).split(&#39;&lt;&#39;):
                    idx.append(row.iso3)
                    reg.append(int(r))
                    cap.append(row.capital)
        self._p_gs=pd.DataFrame({&#39;iso3&#39;:idx,&#39;capital&#39;:cap,&#39;region&#39;:reg})
        self._p_gs=self._p_gs.merge(p_m49,how=&#39;left&#39;,left_on=&#39;region&#39;,\
                            right_on=&#39;code&#39;).drop([&#34;code&#34;],axis=1)

    def get_source(self):
        return self._source_dict

    def get_region_list(self):
        return list(self._region_dict.values())

    def is_region(self,region):
        &#34;&#34;&#34; it returns either False or the correctly named region name
        &#34;&#34;&#34;
        if type(region) != str:
            raise CoaKeyError(&#34;The given region is not a str type.&#34;)

        region=region.title()  # if not properly capitalized

        if region not in self.get_region_list():
            return False
        else :
            return region

    def get_countries_from_region(self,region):
        &#34;&#34;&#34; it returns a list of countries for the given region name.
        The standard used is iso3. To convert to another standard,
        use the GeoManager class.
        &#34;&#34;&#34;
        r = self.is_region(region)
        if not r:
            raise CoaKeyError(&#39;The given region &#34;&#39;+str(region)+&#39;&#34; is unknown.&#39;)
        region=r

        clist=[]

        if region==&#39;European Union&#39;:
            clist=[&#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
                        &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
                        &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
                        &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
        elif region==&#39;G7&#39;:
            clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;]
        elif region==&#39;G8&#39;:
            clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;,&#39;RUS&#39;]
        elif region==&#39;G20&#39;:
            clist=[&#39;ZAF&#39;,&#39;SAU&#39;,&#39;ARG&#39;,&#39;AUS&#39;,&#39;BRA&#39;,&#39;CAN&#39;,&#39;CHN&#39;,&#39;KOR&#39;,&#39;USA&#39;,\
                &#39;IND&#39;,&#39;IDN&#39;,&#39;JAP&#39;,&#39;MEX&#39;,&#39;GBR&#39;,&#39;RUS&#39;,&#39;TUR&#39;,\
                &#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
                &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
                &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
                &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
        elif region==&#39;Oecd&#39;: # OCDE in french
            clist=[&#39;DEU&#39;,&#39;AUS&#39;,&#39;AUT&#39;,&#39;BEL&#39;,&#39;CAN&#39;,&#39;CHL&#39;,&#39;COL&#39;,&#39;KOR&#39;,&#39;DNK&#39;,\
                &#39;ESP&#39;,&#39;EST&#39;,&#39;USA&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ISL&#39;,&#39;ISR&#39;,\
                &#39;ITA&#39;,&#39;JAP&#39;,&#39;LVA&#39;,&#39;LTU&#39;,&#39;LUX&#39;,&#39;MEX&#39;,&#39;NOR&#39;,&#39;NZL&#39;,&#39;NLD&#39;,&#39;POL&#39;,\
                &#39;PRT&#39;,&#39;SVK&#39;,&#39;SVN&#39;,&#39;SWE&#39;,&#39;CHE&#39;,&#39;GBR&#39;,&#39;CZE&#39;,&#39;TUR&#39;]
        elif region==&#39;G77&#39;:
            clist=[&#39;AFG&#39;,&#39;DZA&#39;,&#39;AGO&#39;,&#39;ATG&#39;,&#39;ARG&#39;,&#39;AZE&#39;,&#39;BHS&#39;,&#39;BHR&#39;,&#39;BGD&#39;,&#39;BRB&#39;,&#39;BLZ&#39;,
                &#39;BEN&#39;,&#39;BTN&#39;,&#39;BOL&#39;,&#39;BWA&#39;,&#39;BRA&#39;,&#39;BRN&#39;,&#39;BFA&#39;,&#39;BDI&#39;,&#39;CPV&#39;,&#39;KHM&#39;,&#39;CMR&#39;,
                &#39;CAF&#39;,&#39;TCD&#39;,&#39;CHL&#39;,&#39;CHN&#39;,&#39;COL&#39;,&#39;COM&#39;,&#39;COG&#39;,&#39;CRI&#39;,&#39;CIV&#39;,&#39;CUB&#39;,&#39;PRK&#39;,
                &#39;COD&#39;,&#39;DJI&#39;,&#39;DMA&#39;,&#39;DOM&#39;,&#39;ECU&#39;,&#39;EGY&#39;,&#39;SLV&#39;,&#39;GNQ&#39;,&#39;ERI&#39;,&#39;SWZ&#39;,&#39;ETH&#39;,
                &#39;FJI&#39;,&#39;GAB&#39;,&#39;GMB&#39;,&#39;GHA&#39;,&#39;GRD&#39;,&#39;GTM&#39;,&#39;GIN&#39;,&#39;GNB&#39;,&#39;GUY&#39;,&#39;HTI&#39;,&#39;HND&#39;,
                &#39;IND&#39;,&#39;IDN&#39;,&#39;IRN&#39;,&#39;IRQ&#39;,&#39;JAM&#39;,&#39;JOR&#39;,&#39;KEN&#39;,&#39;KIR&#39;,&#39;KWT&#39;,&#39;LAO&#39;,&#39;LBN&#39;,
                &#39;LSO&#39;,&#39;LBR&#39;,&#39;LBY&#39;,&#39;MDG&#39;,&#39;MWI&#39;,&#39;MYS&#39;,&#39;MDV&#39;,&#39;MLI&#39;,&#39;MHL&#39;,&#39;MRT&#39;,&#39;MUS&#39;,
                &#39;FSM&#39;,&#39;MNG&#39;,&#39;MAR&#39;,&#39;MOZ&#39;,&#39;MMR&#39;,&#39;NAM&#39;,&#39;NRU&#39;,&#39;NPL&#39;,&#39;NIC&#39;,&#39;NER&#39;,&#39;NGA&#39;,
                &#39;OMN&#39;,&#39;PAK&#39;,&#39;PAN&#39;,&#39;PNG&#39;,&#39;PRY&#39;,&#39;PER&#39;,&#39;PHL&#39;,&#39;QAT&#39;,&#39;RWA&#39;,&#39;KNA&#39;,&#39;LCA&#39;,
                &#39;VCT&#39;,&#39;WSM&#39;,&#39;STP&#39;,&#39;SAU&#39;,&#39;SEN&#39;,&#39;SYC&#39;,&#39;SLE&#39;,&#39;SGP&#39;,&#39;SLB&#39;,&#39;SOM&#39;,&#39;ZAF&#39;,
                &#39;SSD&#39;,&#39;LKA&#39;,&#39;PSE&#39;,&#39;SDN&#39;,&#39;SUR&#39;,&#39;SYR&#39;,&#39;TJK&#39;,&#39;THA&#39;,&#39;TLS&#39;,&#39;TGO&#39;,&#39;TON&#39;,
                &#39;TTO&#39;,&#39;TUN&#39;,&#39;TKM&#39;,&#39;UGA&#39;,&#39;ARE&#39;,&#39;TZA&#39;,&#39;URY&#39;,&#39;VUT&#39;,&#39;VEN&#39;,&#39;VNM&#39;,&#39;YEM&#39;,
                &#39;ZMB&#39;,&#39;ZWE&#39;]
        elif region==&#39;Commonwealth&#39;:
            clist=self._cw
        else:
            clist=self._p_gs[self._p_gs[&#39;region_name&#39;]==region][&#39;iso3&#39;].to_list()

        return sorted(clist)

    def get_pandas(self):
        return self._p_gs</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coa.geo.GeoRegion.get_countries_from_region"><code class="name flex">
<span>def <span class="ident">get_countries_from_region</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<div class="desc"><p>it returns a list of countries for the given region name.
The standard used is iso3. To convert to another standard,
use the GeoManager class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_countries_from_region(self,region):
    &#34;&#34;&#34; it returns a list of countries for the given region name.
    The standard used is iso3. To convert to another standard,
    use the GeoManager class.
    &#34;&#34;&#34;
    r = self.is_region(region)
    if not r:
        raise CoaKeyError(&#39;The given region &#34;&#39;+str(region)+&#39;&#34; is unknown.&#39;)
    region=r

    clist=[]

    if region==&#39;European Union&#39;:
        clist=[&#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
                    &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
                    &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
                    &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
    elif region==&#39;G7&#39;:
        clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;]
    elif region==&#39;G8&#39;:
        clist=[&#39;DEU&#39;,&#39;CAN&#39;,&#39;USA&#39;,&#39;FRA&#39;,&#39;ITA&#39;,&#39;JAP&#39;,&#39;GBR&#39;,&#39;RUS&#39;]
    elif region==&#39;G20&#39;:
        clist=[&#39;ZAF&#39;,&#39;SAU&#39;,&#39;ARG&#39;,&#39;AUS&#39;,&#39;BRA&#39;,&#39;CAN&#39;,&#39;CHN&#39;,&#39;KOR&#39;,&#39;USA&#39;,\
            &#39;IND&#39;,&#39;IDN&#39;,&#39;JAP&#39;,&#39;MEX&#39;,&#39;GBR&#39;,&#39;RUS&#39;,&#39;TUR&#39;,\
            &#39;AUT&#39;,&#39;BEL&#39;,&#39;BGR&#39;,&#39;CYP&#39;,&#39;CZE&#39;,&#39;DEU&#39;,&#39;DNK&#39;,&#39;EST&#39;,\
            &#39;ESP&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HRV&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ITA&#39;,\
            &#39;LTU&#39;,&#39;LUX&#39;,&#39;LVA&#39;,&#39;MLT&#39;,&#39;NLD&#39;,&#39;POL&#39;,&#39;PRT&#39;,&#39;ROU&#39;,\
            &#39;SWE&#39;,&#39;SVN&#39;,&#39;SVK&#39;]
    elif region==&#39;Oecd&#39;: # OCDE in french
        clist=[&#39;DEU&#39;,&#39;AUS&#39;,&#39;AUT&#39;,&#39;BEL&#39;,&#39;CAN&#39;,&#39;CHL&#39;,&#39;COL&#39;,&#39;KOR&#39;,&#39;DNK&#39;,\
            &#39;ESP&#39;,&#39;EST&#39;,&#39;USA&#39;,&#39;FIN&#39;,&#39;FRA&#39;,&#39;GRC&#39;,&#39;HUN&#39;,&#39;IRL&#39;,&#39;ISL&#39;,&#39;ISR&#39;,\
            &#39;ITA&#39;,&#39;JAP&#39;,&#39;LVA&#39;,&#39;LTU&#39;,&#39;LUX&#39;,&#39;MEX&#39;,&#39;NOR&#39;,&#39;NZL&#39;,&#39;NLD&#39;,&#39;POL&#39;,\
            &#39;PRT&#39;,&#39;SVK&#39;,&#39;SVN&#39;,&#39;SWE&#39;,&#39;CHE&#39;,&#39;GBR&#39;,&#39;CZE&#39;,&#39;TUR&#39;]
    elif region==&#39;G77&#39;:
        clist=[&#39;AFG&#39;,&#39;DZA&#39;,&#39;AGO&#39;,&#39;ATG&#39;,&#39;ARG&#39;,&#39;AZE&#39;,&#39;BHS&#39;,&#39;BHR&#39;,&#39;BGD&#39;,&#39;BRB&#39;,&#39;BLZ&#39;,
            &#39;BEN&#39;,&#39;BTN&#39;,&#39;BOL&#39;,&#39;BWA&#39;,&#39;BRA&#39;,&#39;BRN&#39;,&#39;BFA&#39;,&#39;BDI&#39;,&#39;CPV&#39;,&#39;KHM&#39;,&#39;CMR&#39;,
            &#39;CAF&#39;,&#39;TCD&#39;,&#39;CHL&#39;,&#39;CHN&#39;,&#39;COL&#39;,&#39;COM&#39;,&#39;COG&#39;,&#39;CRI&#39;,&#39;CIV&#39;,&#39;CUB&#39;,&#39;PRK&#39;,
            &#39;COD&#39;,&#39;DJI&#39;,&#39;DMA&#39;,&#39;DOM&#39;,&#39;ECU&#39;,&#39;EGY&#39;,&#39;SLV&#39;,&#39;GNQ&#39;,&#39;ERI&#39;,&#39;SWZ&#39;,&#39;ETH&#39;,
            &#39;FJI&#39;,&#39;GAB&#39;,&#39;GMB&#39;,&#39;GHA&#39;,&#39;GRD&#39;,&#39;GTM&#39;,&#39;GIN&#39;,&#39;GNB&#39;,&#39;GUY&#39;,&#39;HTI&#39;,&#39;HND&#39;,
            &#39;IND&#39;,&#39;IDN&#39;,&#39;IRN&#39;,&#39;IRQ&#39;,&#39;JAM&#39;,&#39;JOR&#39;,&#39;KEN&#39;,&#39;KIR&#39;,&#39;KWT&#39;,&#39;LAO&#39;,&#39;LBN&#39;,
            &#39;LSO&#39;,&#39;LBR&#39;,&#39;LBY&#39;,&#39;MDG&#39;,&#39;MWI&#39;,&#39;MYS&#39;,&#39;MDV&#39;,&#39;MLI&#39;,&#39;MHL&#39;,&#39;MRT&#39;,&#39;MUS&#39;,
            &#39;FSM&#39;,&#39;MNG&#39;,&#39;MAR&#39;,&#39;MOZ&#39;,&#39;MMR&#39;,&#39;NAM&#39;,&#39;NRU&#39;,&#39;NPL&#39;,&#39;NIC&#39;,&#39;NER&#39;,&#39;NGA&#39;,
            &#39;OMN&#39;,&#39;PAK&#39;,&#39;PAN&#39;,&#39;PNG&#39;,&#39;PRY&#39;,&#39;PER&#39;,&#39;PHL&#39;,&#39;QAT&#39;,&#39;RWA&#39;,&#39;KNA&#39;,&#39;LCA&#39;,
            &#39;VCT&#39;,&#39;WSM&#39;,&#39;STP&#39;,&#39;SAU&#39;,&#39;SEN&#39;,&#39;SYC&#39;,&#39;SLE&#39;,&#39;SGP&#39;,&#39;SLB&#39;,&#39;SOM&#39;,&#39;ZAF&#39;,
            &#39;SSD&#39;,&#39;LKA&#39;,&#39;PSE&#39;,&#39;SDN&#39;,&#39;SUR&#39;,&#39;SYR&#39;,&#39;TJK&#39;,&#39;THA&#39;,&#39;TLS&#39;,&#39;TGO&#39;,&#39;TON&#39;,
            &#39;TTO&#39;,&#39;TUN&#39;,&#39;TKM&#39;,&#39;UGA&#39;,&#39;ARE&#39;,&#39;TZA&#39;,&#39;URY&#39;,&#39;VUT&#39;,&#39;VEN&#39;,&#39;VNM&#39;,&#39;YEM&#39;,
            &#39;ZMB&#39;,&#39;ZWE&#39;]
    elif region==&#39;Commonwealth&#39;:
        clist=self._cw
    else:
        clist=self._p_gs[self._p_gs[&#39;region_name&#39;]==region][&#39;iso3&#39;].to_list()

    return sorted(clist)</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoRegion.get_pandas"><code class="name flex">
<span>def <span class="ident">get_pandas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pandas(self):
    return self._p_gs</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoRegion.get_region_list"><code class="name flex">
<span>def <span class="ident">get_region_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_region_list(self):
    return list(self._region_dict.values())</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoRegion.get_source"><code class="name flex">
<span>def <span class="ident">get_source</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source(self):
    return self._source_dict</code></pre>
</details>
</dd>
<dt id="coa.geo.GeoRegion.is_region"><code class="name flex">
<span>def <span class="ident">is_region</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<div class="desc"><p>it returns either False or the correctly named region name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_region(self,region):
    &#34;&#34;&#34; it returns either False or the correctly named region name
    &#34;&#34;&#34;
    if type(region) != str:
        raise CoaKeyError(&#34;The given region is not a str type.&#34;)

    region=region.title()  # if not properly capitalized

    if region not in self.get_region_list():
        return False
    else :
        return region</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#about">About :</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coa" href="index.html">coa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coa.geo.GeoCountry" href="#coa.geo.GeoCountry">GeoCountry</a></code></h4>
<ul class="">
<li><code><a title="coa.geo.GeoCountry.add_field" href="#coa.geo.GeoCountry.add_field">add_field</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_country" href="#coa.geo.GeoCountry.get_country">get_country</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_data" href="#coa.geo.GeoCountry.get_data">get_data</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_list_countries" href="#coa.geo.GeoCountry.get_list_countries">get_list_countries</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_list_properties" href="#coa.geo.GeoCountry.get_list_properties">get_list_properties</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_region_list" href="#coa.geo.GeoCountry.get_region_list">get_region_list</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_source" href="#coa.geo.GeoCountry.get_source">get_source</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_subregion_list" href="#coa.geo.GeoCountry.get_subregion_list">get_subregion_list</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_subregions_from_list_of_region_names" href="#coa.geo.GeoCountry.get_subregions_from_list_of_region_names">get_subregions_from_list_of_region_names</a></code></li>
<li><code><a title="coa.geo.GeoCountry.get_subregions_from_region" href="#coa.geo.GeoCountry.get_subregions_from_region">get_subregions_from_region</a></code></li>
<li><code><a title="coa.geo.GeoCountry.is_init" href="#coa.geo.GeoCountry.is_init">is_init</a></code></li>
<li><code><a title="coa.geo.GeoCountry.is_region" href="#coa.geo.GeoCountry.is_region">is_region</a></code></li>
<li><code><a title="coa.geo.GeoCountry.is_subregion" href="#coa.geo.GeoCountry.is_subregion">is_subregion</a></code></li>
<li><code><a title="coa.geo.GeoCountry.test_is_init" href="#coa.geo.GeoCountry.test_is_init">test_is_init</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coa.geo.GeoInfo" href="#coa.geo.GeoInfo">GeoInfo</a></code></h4>
<ul class="">
<li><code><a title="coa.geo.GeoInfo.add_field" href="#coa.geo.GeoInfo.add_field">add_field</a></code></li>
<li><code><a title="coa.geo.GeoInfo.get_GeoManager" href="#coa.geo.GeoInfo.get_GeoManager">get_GeoManager</a></code></li>
<li><code><a title="coa.geo.GeoInfo.get_list_field" href="#coa.geo.GeoInfo.get_list_field">get_list_field</a></code></li>
<li><code><a title="coa.geo.GeoInfo.get_source" href="#coa.geo.GeoInfo.get_source">get_source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coa.geo.GeoManager" href="#coa.geo.GeoManager">GeoManager</a></code></h4>
<ul class="">
<li><code><a title="coa.geo.GeoManager.first_db_translation" href="#coa.geo.GeoManager.first_db_translation">first_db_translation</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_GeoRegion" href="#coa.geo.GeoManager.get_GeoRegion">get_GeoRegion</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_list_db" href="#coa.geo.GeoManager.get_list_db">get_list_db</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_list_output" href="#coa.geo.GeoManager.get_list_output">get_list_output</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_list_standard" href="#coa.geo.GeoManager.get_list_standard">get_list_standard</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_region_list" href="#coa.geo.GeoManager.get_region_list">get_region_list</a></code></li>
<li><code><a title="coa.geo.GeoManager.get_standard" href="#coa.geo.GeoManager.get_standard">get_standard</a></code></li>
<li><code><a title="coa.geo.GeoManager.set_standard" href="#coa.geo.GeoManager.set_standard">set_standard</a></code></li>
<li><code><a title="coa.geo.GeoManager.to_standard" href="#coa.geo.GeoManager.to_standard">to_standard</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coa.geo.GeoRegion" href="#coa.geo.GeoRegion">GeoRegion</a></code></h4>
<ul class="">
<li><code><a title="coa.geo.GeoRegion.get_countries_from_region" href="#coa.geo.GeoRegion.get_countries_from_region">get_countries_from_region</a></code></li>
<li><code><a title="coa.geo.GeoRegion.get_pandas" href="#coa.geo.GeoRegion.get_pandas">get_pandas</a></code></li>
<li><code><a title="coa.geo.GeoRegion.get_region_list" href="#coa.geo.GeoRegion.get_region_list">get_region_list</a></code></li>
<li><code><a title="coa.geo.GeoRegion.get_source" href="#coa.geo.GeoRegion.get_source">get_source</a></code></li>
<li><code><a title="coa.geo.GeoRegion.is_region" href="#coa.geo.GeoRegion.is_region">is_region</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>