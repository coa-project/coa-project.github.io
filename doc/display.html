<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>coa.display API documentation</title>
<meta name="description" content="Project : PyCoA
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coa.display</code></h1>
</header>
<section id="section-intro">
<p>Project : PyCoA
Date :
april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint LICENSE file</p>
<p>Module : coa.display</p>
<h2 id="about">About :</h2>
<p>An interface module to easily plot pycoa data with bokeh</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Project : PyCoA
Date :    april 2020 - march 2021
Authors : Olivier Dadoun, Julien Browaeys, Tristan Beau
Copyright ©pycoa.fr
License: See joint LICENSE file

Module : coa.display

About :
-------

An interface module to easily plot pycoa data with bokeh

&#34;&#34;&#34;

from coa.tools import kwargs_test, extract_dates, verb, get_db_list_dict
from coa.error import *

import math
import pandas as pd
import geopandas as gpd
import numpy as np
from collections import defaultdict
import itertools
import json
import io
from io import BytesIO
import base64
from IPython import display
import copy
import locale

from bokeh.models import ColumnDataSource, TableColumn, DataTable, ColorBar, LogTicker,\
    HoverTool, CrosshairTool, BasicTicker, GeoJSONDataSource, LinearColorMapper, LogColorMapper,Label, \
    PrintfTickFormatter, BasicTickFormatter, NumeralTickFormatter, CustomJS, CustomJSHover, Select, \
    Range1d, DatetimeTickFormatter, Legend, LegendItem, Text
from bokeh.models.widgets import Tabs, Panel
from bokeh.plotting import figure
from bokeh.layouts import row, column, gridplot
from bokeh.palettes import Category10, Category20, Viridis256
from bokeh.models import Title

from bokeh.io import export_png
from bokeh import events
from bokeh.models.widgets import DateSlider
from bokeh.models import LabelSet, WMTSTileSource
from bokeh.transform import transform, cumsum

import shapely.geometry as sg

import branca.colormap
from branca.colormap import LinearColormap
from branca.element import Element, Figure
import folium
from PIL import Image
import coa.geo as coge
import matplotlib.pyplot as plt
import datetime as dt
import bisect
from functools import wraps
from IPython.core.display import display, HTML

width_height_default = [500, 380]

MAXCOUNTRIESDISPLAYED = 27
class CocoDisplay:
    def __init__(self, db=None, geo = None):
        verb(&#34;Init of CocoDisplay() with db=&#34; + str(db))
        self.database_name = db
        self.dbld = get_db_list_dict()
        self.lcolors = Category20[20]
        self.scolors = Category10[5]
        self.ax_type = [&#39;linear&#39;, &#39;log&#39;]
        self.geom = []
        self.geopan = gpd.GeoDataFrame()
        self.location_geometry = None
        self.boundary_metropole = None
        self.listfigs = []
        self.options_stats  = [&#39;when&#39;,&#39;input&#39;,&#39;input_field&#39;]
        self.options_charts = [ &#39;bins&#39;]
        self.options_front = [&#39;where&#39;,&#39;option&#39;,&#39;which&#39;,&#39;what&#39;,&#39;visu&#39;]
        self.available_tiles = [&#39;openstreet&#39;,&#39;esri&#39;,&#39;stamen&#39;]
        self.available_modes = [&#39;mouse&#39;,&#39;vline&#39;,&#39;hline&#39;]
        self.uptitle, self.subtitle = &#39; &#39;,&#39; &#39;

        self.dfigure_default = {&#39;plot_height&#39;:width_height_default[1] ,&#39;plot_width&#39;:width_height_default[0],&#39;title&#39;:None,&#39;textcopyright&#39;:&#39;default&#39;}
        self.dvisu_default = {&#39;mode&#39;:&#39;mouse&#39;,&#39;tile&#39;:self.available_tiles[0],&#39;orientation&#39;:&#39;horizontal&#39;,&#39;cursor_date&#39;:None,&#39;maplabel&#39;:None,&#39;guideline&#39;:False}

        self.when_beg = dt.date(1, 1, 1)
        self.when_end = dt.date(1, 1, 1)

        self.alloptions =  self.options_stats + self.options_charts + self.options_front + list(self.dfigure_default.keys()) +\
                           list(self.dvisu_default.keys()) + [&#39;resumetype&#39;]

        self.iso3country = self.dbld[self.database_name][0]
        self.granularity = self.dbld[self.database_name][1]
        self.namecountry = self.dbld[self.database_name][2]
        try:
            if self.granularity != &#39;nation&#39;:
                self.geo = coge.GeoCountry(self.iso3country)
                if self.granularity == &#39;region&#39;:
                    self.location_geometry = self.geo.get_region_list()[[&#39;code_region&#39;, &#39;name_region&#39;, &#39;geometry&#39;]]
                    self.location_geometry = self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                    if self.iso3country == &#39;PRT&#39;:
                         tmp=self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                         tmp = tmp.loc[tmp.code_region==&#39;PT.99&#39;]
                         self.boundary_metropole =tmp[&#39;geometry&#39;].total_bounds
                    if self.iso3country == &#39;FRA&#39;:
                         tmp=self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                         tmp = tmp.loc[tmp.code_region==&#39;999&#39;]
                         self.boundary_metropole =tmp[&#39;geometry&#39;].total_bounds
                elif self.granularity == &#39;subregion&#39;:
                    list_dep_metro = None
                    self.location_geometry = self.geo.get_subregion_list()[[&#39;code_subregion&#39;, &#39;name_subregion&#39;, &#39;geometry&#39;]]
                    self.location_geometry = self.location_geometry.rename(columns={&#39;name_subregion&#39;: &#39;location&#39;})
                    #if country == &#39;FRA&#39;:
                    #     list_dep_metro =  geo.get_subregions_from_region(name=&#39;Métropole&#39;)
                    #elif country == &#39;ESP&#39;:
                    #     list_dep_metro =  geo.get_subregions_from_region(name=&#39;España peninsular&#39;)
                    #if list_dep_metro:
                    #    self.boundary_metropole = self.location_geometry.loc[self.location_geometry.code_subregion.isin(list_dep_metro)][&#39;geometry&#39;].total_bounds
            else:
                   self.geo=coge.GeoManager(&#39;name&#39;)
                   geopan = gpd.GeoDataFrame()#crs=&#34;EPSG:4326&#34;)
                   info = coge.GeoInfo()
                   allcountries = self.geo.get_GeoRegion().get_countries_from_region(&#39;world&#39;)
                   geopan[&#39;location&#39;] = [self.geo.to_standard(c)[0] for c in allcountries]
                   geopan = info.add_field(field=[&#39;geometry&#39;],input=geopan ,geofield=&#39;location&#39;)
                   geopan = gpd.GeoDataFrame(geopan, geometry=geopan.geometry, crs=&#34;EPSG:4326&#34;)
                   geopan = geopan[geopan.location != &#39;Antarctica&#39;]
                   geopan = geopan.dropna().reset_index(drop=True)
                   self.location_geometry  = geopan
        except:
            raise CoaTypeError(&#39;What data base are you looking for ?&#39;)

    &#39;&#39;&#39; FIGURE COMMUN FOR ALL &#39;&#39;&#39;
    def standardfig(self, **kwargs):
        &#34;&#34;&#34;
         Create a standard Bokeh figure, with pycoa.fr copyright, used in all the bokeh charts
         &#34;&#34;&#34;
        plot_width = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
        plot_height = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])
        textcopyright = kwargs.get(&#39;textcopyright&#39;, self.dfigure_default[&#39;textcopyright&#39;])

        if textcopyright  == &#39;default&#39;:
                textcopyright = &#39;©pycoa.fr (data from: {})&#39;.format(self.database_name)
        else:
                textcopyright = &#39;©pycoa.fr &#39; + textcopyright

        citation = Label(x=0.65 * plot_width - len(textcopyright), y=0.01 * plot_height,
                                          x_units=&#39;screen&#39;, y_units=&#39;screen&#39;,
                                          text_font_size=&#39;1.5vh&#39;, background_fill_color=&#39;white&#39;, background_fill_alpha=.75,
                                          text=textcopyright)

        for i in list(self.dvisu_default.keys())  + self.options_front + self.options_charts + [&#39;textcopyright&#39;] + self.options_stats + [&#39;date_slider&#39;]:
            if i in kwargs.keys():
                kwargs.pop(i)
        kwargs.pop(&#39;title&#39;)
        fig = figure(**kwargs, tools=[&#39;save&#39;, &#39;box_zoom,reset&#39;], toolbar_location=&#34;right&#34;)
        #fig.add_layout(citation)
        fig.add_layout(Title(text=self.uptitle, text_font_size=&#34;10pt&#34;), &#39;above&#39;)
        fig.add_layout(Title(text=self.subtitle, text_font_size=&#34;8pt&#34;, text_font_style=&#34;italic&#34;), &#39;below&#39;)
        return fig

    def get_listfigures(self):
        return  self.listfigs
    def set_listfigures(self,fig):
            if not isinstance(fig,list):
                fig = [fig]
            self.listfigs = fig
    &#39;&#39;&#39; WRAPPER COMMUN FOR ALL&#39;&#39;&#39;
    def decowrapper(func):
        &#39;&#39;&#39;
            Main decorator it mainly deals with arg testings
        &#39;&#39;&#39;
        @wraps(func)
        def wrapper(self, input = None, input_field = None, **kwargs):
            &#34;&#34;&#34;
            Parse a standard input, return :
                - pandas: with location keyword (eventually force a column named &#39;where&#39; to &#39;location&#39;)
                - kwargs:
                    * keys = [plot_width, plot_width, title, when, title_temporal,bins, what, which]
            Note that method used only the needed variables, some of them are useless
            &#34;&#34;&#34;
            if not isinstance(input, pd.DataFrame):
                raise CoaTypeError(input + &#39;Must be a pandas, with pycoa structure !&#39;)

            kwargs_test(kwargs, self.alloptions, &#39;Bad args used in the display function.&#39;)
            when = kwargs.get(&#39;when&#39;, None)
            which = kwargs.get(&#39;which&#39;, input.columns[2])
            if input_field and &#39;cur_&#39; in input_field:
                what =  which
            else:
                 # cumul is the default
                what = kwargs.get(&#39;what&#39;, which)

            if input_field is None:
                input_field = which

            if isinstance(input_field,list):
                test = input_field[0]
            else:
                test = input_field
            if input[[test,&#39;date&#39;]].isnull().values.all():
                raise CoaKeyError(&#39;All values for &#39;+ which + &#39; is nan nor empty&#39;)

            option = kwargs.get(&#39;option&#39;, None)
            bins = kwargs.get(&#39;bins&#39;, 10)
            title = kwargs.get(&#39;title&#39;, None)
            #textcopyright = kwargs.get(&#39;textcopyright&#39;, &#39;default&#39;)
            kwargs[&#39;plot_width&#39;] = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
            kwargs[&#39;plot_height&#39;] = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])

            if &#39;where&#39; in input.columns:
                input = input.rename(columns={&#39;where&#39;: &#39;location&#39;})

            if &#39;codelocation&#39; and &#39;clustername&#39; not in input.columns:
                input[&#39;codelocation&#39;] = input[&#39;location&#39;]
                input[&#39;clustername&#39;] = input[&#39;location&#39;]
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]
                input[&#39;permanentdisplay&#39;] = input[&#39;location&#39;]
            else:
                if self.granularity == &#39;nation&#39; :
                    #input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;) if len(x)&lt; 10 else x[0]+&#39;...&#39;+x[-1] )
                    input[&#39;permanentdisplay&#39;] = input.apply(lambda x: x.clustername if self.geo.get_GeoRegion().is_region(x.clustername) else str(x.codelocation), axis = 1)
                else:
                    if self.granularity == &#39;subregion&#39; :
                        input = input.reset_index(drop=True)
                        if isinstance(input[&#39;codelocation&#39;][0],list):
                            input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#34;&#39;&#34;, &#39;&#39;)\
                                                         if len(x)&lt;5 else &#39;[&#39;+str(x[0]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;,...,&#39;+str(x[-1]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;]&#39;)

                        trad={}
                        cluster = input.clustername.unique()
                        if isinstance(input.location[0],list):
                           cluster = [i for i in cluster]
                        for i in cluster:
                            if i == self.namecountry:
                                input[&#39;permanentdisplay&#39;] = input.clustername #[self.dbld[self.database_name][2]]*len(input)
                            else:
                                if self.geo.is_region(i):
                                    trad[i] = self.geo.is_region(i)
                                elif self.geo.is_subregion(i):
                                    trad[i] = self.geo.is_subregion(i)#input.loc[input.clustername==i][&#39;codelocation&#39;].iloc[0]
                                else:
                                    trad[i] = i
                                trad={k:(v[:3]+&#39;...&#39;+v[-3:] if len(v)&gt;8 else v) for k,v in trad.items()}
                                if &#39;,&#39; in input.codelocation[0]:
                                    input[&#39;permanentdisplay&#39;] = input.clustername
                                else:
                                    input[&#39;permanentdisplay&#39;] = input.codelocation#input.clustername.map(trad)
                    elif self.granularity == &#39;region&#39; :
                        if all(i == self.namecountry for i in input.clustername.unique()):
                            input[&#39;permanentdisplay&#39;] = [self.namecountry]*len(input)
                        else:
                            input[&#39;permanentdisplay&#39;] = input.codelocation
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

            maplabel = kwargs.get(&#39;maplabel&#39;, None)
            if maplabel and &#39;unsorted&#39; in maplabel:
                pass
            else:
                input = input.sort_values(by=input_field, ascending = False).reset_index(drop=True)

            uniqloc = input.clustername.unique()

            if len(uniqloc) &lt; 5:
                colors = self.scolors
            else:
                colors = self.lcolors
            colors = itertools.cycle(colors)
            dico_colors = {i: next(colors) for i in uniqloc}

            input = input.copy()
            if not &#39;colors&#39; in input.columns:
                input.loc[:,&#39;colors&#39;] = input[&#39;clustername&#39;].map(dico_colors)#(pd.merge(input, country_col, on=&#39;location&#39;))

            if not isinstance(input_field, list):
                  input_field = [input_field]
            else:
                  input_field = input_field
            col2=which
            when_beg = input[[col2,&#39;date&#39;]].date.min()
            when_end = input[[col2,&#39;date&#39;]].date.max()

            if when:
                when_beg, when_end = extract_dates(when)
                if when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                    when_end = input[[col2,&#39;date&#39;]].date.max()

                if when_beg == dt.date(1, 1, 1):
                    when_beg = input[[col2,&#39;date&#39;]].date.min()

                if not isinstance(when_beg, dt.date):
                    raise CoaNoData(&#34;With your current cuts, there are no data to plot.&#34;)

                if when_end &lt;= when_beg:
                    print(&#39;Requested date below available one, take&#39;, when_beg)
                    when_end = when_beg
                if when_beg &gt; input[[col2,&#39;date&#39;]].date.max() or when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                    raise CoaNoData(&#34;No available data after &#34;+str(input[[input_field[0],&#39;date&#39;]].date.max()))
            when_end_change = when_end

            for i in input_field:
                if input[i].isnull().all():
                    raise CoaTypeError(&#34;Sorry all data are NaN for &#34; + i)
                else:
                    when_end_change = min(when_end_change,CocoDisplay.changeto_nonull_date(input, when_end, i))

            if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
                if len(input_field) &gt; 1:
                    print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
                input_field = input_field[0]

            if when_end_change != when_end:
                when_end = when_end_change

            self.when_beg = when_beg
            self.when_end = when_end
            input = input.loc[(input[&#39;date&#39;] &gt;=  self.when_beg) &amp; (input[&#39;date&#39;] &lt;=  self.when_end)]

            title_temporal = &#39; (&#39; + &#39;between &#39; + when_beg.strftime(&#39;%d/%m/%Y&#39;) + &#39; and &#39; + when_end.strftime(&#39;%d/%m/%Y&#39;) + &#39;)&#39;
            if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
                title_temporal = &#39; (&#39; + when_end.strftime(&#39;%d/%m/%Y&#39;)  + &#39;)&#39;
            title_option=&#39;&#39;
            if option:
                if &#39;sumallandsmooth7&#39; in option:
                    option.remove(&#39;sumallandsmooth7&#39;)
                    option += [&#39;sumall&#39;,&#39;smooth7&#39;]
                title_option = &#39; (option: &#39; + str(option)+&#39;)&#39;

            input_field_tostring = str(input_field).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;).replace(&#39;\&#39;&#39;, &#39;&#39;)
            whichtitle = which
            if &#39;pop&#39; in input_field_tostring:
                whichtitle = input_field_tostring.replace(&#39;weekly &#39;,&#39;&#39;).replace(&#39;daily &#39;,&#39;&#39;)

            if &#39;daily&#39; in input_field_tostring:
                titlefig = whichtitle + &#39;, &#39; + &#39;day to day difference&#39; + title_option
            elif &#39;weekly&#39; in input_field_tostring:
                titlefig = whichtitle + &#39;, &#39; + &#39;week to week difference&#39; + title_option
            else:
                if &#39;cur_&#39; in  which or &#39;idx_&#39; in  which:
                    #titlefig = which + &#39;, &#39; + &#39;current &#39; + which.replace(&#39;cur_&#39;,&#39;&#39;).replace(&#39;idx_&#39;,&#39;&#39;)+ title_option
                    titlefig = whichtitle + &#39;, current value&#39; + title_option
                else:
                    titlefig = whichtitle + &#39;, cumulative&#39;+ title_option

            if title:
                title = title
            else:
                title  = titlefig
            self.uptitle = title

            textcopyright = kwargs.get(&#39;textcopyright&#39;, None)
            if textcopyright:
                textcopyright = &#39;©pycoa.fr &#39; + textcopyright + title_temporal
                kwargs.pop(&#39;textcopyright&#39;)
            else:
                textcopyright = &#39;©pycoa.fr data from: {}&#39;.format(self.database_name)+&#39; &#39;+title_temporal

            self.subtitle = textcopyright
            kwargs[&#39;title&#39;] = title+title_temporal
            return func(self, input, input_field, **kwargs)
        return wrapper

    @decowrapper
    def pycoa_resume_data(self, input, input_field, **kwargs):
        loc=list(input[&#39;clustername&#39;].unique())
        input[&#39;cases&#39;] = input[input_field]
        resumetype = kwargs.get(&#39;resumetype&#39;,&#39;spiral&#39;)
        if resumetype == &#39;spiral&#39;:
            dspiral={i:CocoDisplay.spiral(input.loc[ (input.clustername==i) &amp;
                        (input.date &gt;= self.when_beg) &amp;
                        (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
            input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(dspiral)
        elif resumetype == &#39;spark&#39;:
            spark={i:CocoDisplay.sparkline(input.loc[ (input.clustername==i) &amp;
                        (input.date &gt;= self.when_beg) &amp;
                        (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
            input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(spark)
        else:
            raise CoaError(&#39;pycoa_resume_data can use spiral or spark ... here what ?&#39;)
        input = input.loc[input.date==input.date.max()].reset_index(drop=True)
        def path_to_image_html(path):
            return &#39;&lt;img src=&#34;&#39;+ path + &#39;&#34; width=&#34;60&#34; &gt;&#39;

        input=input.drop(columns=[&#39;permanentdisplay&#39;,&#39;rolloverdisplay&#39;,&#39;colors&#39;,&#39;cases&#39;])
        input=input.apply(lambda x: x.round(2) if x.name in [input_field,&#39;daily&#39;,&#39;weekly&#39;] else x)
        if isinstance(input[&#39;location&#39;][0], list):
            col=[i for i in list(input.columns) if i not in [&#39;clustername&#39;,&#39;location&#39;,&#39;codelocation&#39;]]
            col.insert(0,&#39;clustername&#39;)
            input = input[col]
            input=input.set_index(&#39;clustername&#39;)
        else:
           input = input.drop(columns=&#39;clustername&#39;)
           input=input.set_index(&#39;location&#39;)

        return input.to_html(escape=False,formatters=dict(resume=path_to_image_html))

    &#39;&#39;&#39; DECORATORS FOR PLOT: DATE, VERSUS, SCROLLINGMENU &#39;&#39;&#39;
    def decoplot(func):
        &#34;&#34;&#34;
        decorator for plot purpose
        &#34;&#34;&#34;
        @wraps(func)
        def inner_plot(self, input = None, input_field = None, **kwargs):
            mode = kwargs.get(&#39;mode&#39;, None)
            if mode:
                mode = mode
            else:
                mode = self.dvisu_default[&#39;mode&#39;]
            if mode not in self.available_modes:
                raise CoaTypeError(&#39;Don\&#39;t know the mode wanted. So far:&#39; + str(self.available_modes))
            kwargs[&#39;mode&#39;] = mode

            if &#39;location&#39; in input.columns:
                location_ordered_byvalues = list(
                    input.loc[input.date == self.when_end].sort_values(by=input_field, ascending=False)[&#39;clustername&#39;].unique())
                input = input.copy()  # needed to avoid warning
                input.loc[:,&#39;clustername&#39;] = pd.Categorical(input.clustername,
                                                       categories=location_ordered_byvalues, ordered=True)

                input = input.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;]).reset_index(drop = True)

                if func.__name__ != &#39;pycoa_scrollingmenu&#39; :
                    if len(location_ordered_byvalues) &gt;= MAXCOUNTRIESDISPLAYED:
                        input = input.loc[input.clustername.isin(location_ordered_byvalues[:MAXCOUNTRIESDISPLAYED])]
                list_max = []
                for i in input_field:
                    list_max.append(max(input.loc[input.clustername.isin(location_ordered_byvalues)][i]))
                if len([x for x in list_max if not np.isnan(x)]) &gt; 0:
                    amplitude = (np.nanmax(list_max) - np.nanmin(list_max))
                    if amplitude &gt; 10 ** 4:
                        self.ax_type.reverse()
                if func.__name__ == &#39;pycoa_scrollingmenu&#39; :
                    if isinstance(input_field,list):
                        if len(input_field) &gt; 1:
                            print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
                        input_field = input_field[0]
                    if self.dbld[self.database_name][1] == &#39;nation&#39; and self.dbld[self.database_name][0] != &#39;WW&#39;:
                        func.__name__ = &#39;pycoa_date_plot&#39;
            return func(self, input, input_field, **kwargs)
        return inner_plot

    &#39;&#39;&#39; PLOT VERSUS &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_plot(self, input = None, input_field = None ,**kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a versus plot according to arguments.
        See help(pycoa_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element. It should be a list dim=2. Moreover the 2 variables must be present
        in the DataFrame considered.
        - plot_heigh = width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        if len(input_field) != 2:
            raise CoaTypeError(&#39;Two variables are needed to plot a versus chart ... &#39;)
        panels = []
        cases_custom = CocoDisplay.rollerJS()
        if self.get_listfigures():
            self.set_listfigures([])
        listfigs=[]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( x_axis_label = input_field[0], y_axis_label = input_field[1],
                                                y_axis_type = axis_type, **kwargs )

            standardfig.add_tools(HoverTool(
                tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;),
                          (input_field[0], &#39;@{casesx}&#39; + &#39;{custom}&#39;),
                          (input_field[1], &#39;@{casesy}&#39; + &#39;{custom}&#39;)],
                formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{casesx}&#39;: cases_custom, &#39;@{casesy}&#39;: cases_custom,
                            &#39;@date&#39;: &#39;datetime&#39;}, mode = kwargs[&#39;mode&#39;],
                point_policy=&#34;snap_to_data&#34;))  # ,PanTool())

            for loc in input.clustername.unique():
                pandaloc = input.loc[input.clustername == loc].sort_values(by=&#39;date&#39;, ascending=&#39;True&#39;)
                pandaloc.rename(columns={input_field[0]: &#39;casesx&#39;, input_field[1]: &#39;casesy&#39;}, inplace=True)
                standardfig.line(x=&#39;casesx&#39;, y=&#39;casesy&#39;,
                                 source=ColumnDataSource(pandaloc), legend_label=pandaloc.clustername.iloc[0],
                                 color=pandaloc.colors.iloc[0], line_width=3, hover_line_width=4)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title=axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            listfigs.append(standardfig)
            CocoDisplay.bokeh_legend(standardfig)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs=panels)
        return tabs

    &#39;&#39;&#39; DATE PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_date_plot(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot according to arguments. See help(pycoa_date_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        panels = []
        listfigs = []
        cases_custom = CocoDisplay.rollerJS()
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;,**kwargs)
            i = 0
            r_list=[]
            maxou=-1000
            lcolors = iter(self.lcolors)
            line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;,&#39;dashdot&#39;]
            for val in input_field:
                for loc in list(input.clustername.unique()):
                    input_filter = input.loc[input.clustername == loc].reset_index(drop = True)

                    src = ColumnDataSource(input_filter)
                    leg = input_filter.clustername[0]
                    #leg = input_filter.permanentdisplay[0]
                    if len(input_field)&gt;1:
                        leg = input_filter.permanentdisplay[0] + &#39;, &#39; + val
                    if len(list(input.clustername.unique())) == 1:
                        color = next(lcolors)
                    else:
                        color = input_filter.colors[0]
                    r = standardfig.line(x = &#39;date&#39;, y = val, source = src,
                                     color = color, line_width = 3,
                                     legend_label = leg,
                                     hover_line_width = 4, name = val, line_dash=line_style[i%4])
                    r_list.append(r)
                    maxou=max(maxou,np.nanmax(input_filter[val].values))
                i += 1
            for r in r_list:
                label = r.name
                tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
                formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
                hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
                standardfig.add_tools(hover)
                if guideline:
                    cross= CrosshairTool()
                    standardfig.add_tools(cross)

            if axis_type == &#39;linear&#39;:
                if maxou  &lt; 1e4 :
                    standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title = axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            standardfig.legend.click_policy=&#34;hide&#34;
            standardfig.legend.label_text_font_size = &#39;8pt&#39;
            if len(input_field) &gt; 1 and len(input_field)*len(input.clustername.unique())&gt;16:
                standardfig.legend.visible=False
            standardfig.xaxis.formatter = DatetimeTickFormatter(
                days = [&#34;%d/%m/%y&#34;], months = [&#34;%d/%m/%y&#34;], years = [&#34;%b %Y&#34;])
            CocoDisplay.bokeh_legend(standardfig)
            listfigs.append(standardfig)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs = panels)
        return tabs

    &#39;&#39;&#39; SPIRAL PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_spiral_plot(self, input = None, input_field = None, **kwargs):
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        panels = []
        listfigs = []
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        borne=300
        kwargs.pop(&#39;plot_width&#39;)
        standardfig = self.standardfig(y_axis_type = None, x_axis_type = None,
        width=kwargs[&#39;plot_height&#39;], x_range=[-borne, borne], y_range=[-borne, borne], match_aspect=True,**kwargs)

        if len(input.clustername.unique()) &gt; 1 :
            print(&#39;Can only display spiral for ONE location. I took the first one:&#39;, input.clustername[0])
            input = input.loc[input.clustername == input.clustername[0]].copy()
        input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
        input[&#34;dayofyear&#34;]=input.date.dt.dayofyear
        input[&#39;year&#39;]=input.date.dt.year
        input[&#39;cases&#39;] = input[input_field]

        K = 2*input[input_field].max()
        #drop bissextile fine tuning in needed in the future
        input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
        input[&#34;dayofyear_angle&#34;] = input[&#34;dayofyear&#34;]*2 * np.pi/365
        input[&#34;r_baseline&#34;] = input.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)
        size_factor = 16
        input[&#34;r_cas_sup&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] + 0.5*x[input_field]*size_factor,axis=1)
        input[&#34;r_cas_inf&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] - 0.5*x[input_field]*size_factor,axis=1)

        radius = 200
        def polar(theta,r,norm=radius/input[&#34;r_baseline&#34;].max()):
            x = norm*r*np.cos(theta)
            y = norm*r*np.sin(theta)
            return x,y
        x_base,y_base=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_baseline&#34;])
        x_cas_sup,y_cas_sup=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_sup&#34;])
        x_cas_inf,y_cas_inf=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_inf&#34;])

        xcol,ycol=[],[]
        [ xcol.append([i,j]) for i,j in zip(x_cas_inf,x_cas_sup)]
        [ ycol.append([i,j]) for i,j in zip(y_cas_inf,y_cas_sup)]
        standardfig.patches(xcol,ycol,color=&#39;blue&#39;,fill_alpha = 0.5)

        src = ColumnDataSource(data=dict(
        x=x_base,
        y=y_base,
        date=input[&#39;date&#39;],
        cases=input[&#39;cases&#39;]
        ))
        standardfig.line( x = &#39;x&#39;, y = &#39;y&#39;, source = src, legend_label = input.clustername[0],
                        line_width = 3, line_color = &#39;blue&#39;)
        circle = standardfig.circle(&#39;x&#39;, &#39;y&#39;, size=2, source=src)

        cases_custom = CocoDisplay.rollerJS()
        hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                               formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;},
                               renderers=[circle],
                               point_policy=&#34;snap_to_data&#34;)
        standardfig.add_tools(hover_tool)

        outer_radius=250
        [standardfig.annular_wedge(
            x=0, y=0, inner_radius=0, outer_radius=outer_radius, start_angle=i*np.pi/6,\
            end_angle=(i+1)*np.pi/6,fill_color=None,line_color=&#39;black&#39;,line_dash=&#39;dotted&#39;)
        for i in range(12)]

        label = [&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;,&#39;May&#39;,&#39;June&#39;,&#39;July&#39;,&#39;August&#39;,&#39;September&#39;,&#39;October&#39;,&#39;November&#39;,&#39;December&#39;]
        xr,yr = polar(np.linspace(0, 2 * np.pi, 13),outer_radius,1)
        standardfig.text(xr[:-1], yr[:-1], label,text_font_size=&#34;9pt&#34;, text_align=&#34;center&#34;, text_baseline=&#34;middle&#34;)

        standardfig.legend.background_fill_alpha = 0.6
        standardfig.legend.location = &#34;top_left&#34;
        standardfig.legend.click_policy=&#34;hide&#34;
        return standardfig

    &#39;&#39;&#39; SCROLLINGMENU PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_scrollingmenu(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot, with a scrolling menu location, according to arguments.
        See help(pycoa_scrollingmenu).
        Keyword arguments
        -----------------
        len(location) &gt; 2
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        -guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        mode = kwargs.get(&#39;mode&#39;,self.dvisu_default[&#39;mode&#39;])
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])

        uniqloc = input.clustername.unique().to_list()
        uniqloc.sort()
        if &#39;location&#39; in input.columns:
            if len(uniqloc) &lt; 2:
                raise CoaTypeError(&#39;What do you want me to do ? You have selected, only one country.&#39;
                                   &#39;There is no sens to use this method. See help.&#39;)
        input = input[[&#39;date&#39;, &#39;clustername&#39;, input_field]]
        input = input.sort_values(by=&#39;clustername&#39;, ascending = True).reset_index(drop=True)

        mypivot = pd.pivot_table(input, index=&#39;date&#39;, columns=&#39;clustername&#39;, values=input_field)
        column_order = uniqloc
        mypivot = mypivot.reindex(column_order, axis=1)
        source = ColumnDataSource(mypivot)

        filter_data1 = mypivot[[uniqloc[0]]].rename(columns={uniqloc[0]: &#39;cases&#39;})
        src1 = ColumnDataSource(filter_data1)

        filter_data2 = mypivot[[uniqloc[1]]].rename(columns={uniqloc[1]: &#39;cases&#39;})
        src2 = ColumnDataSource(filter_data2)

        cases_custom = CocoDisplay.rollerJS()
        hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                               formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;}, mode = mode,
                               point_policy=&#34;snap_to_data&#34;)  # ,PanTool())

        panels = []
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;, **kwargs)

            standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)

            standardfig.add_tools(hover_tool)
            if guideline:
                cross= CrosshairTool()
                standardfig.add_tools(cross)
            def add_line(src, options, init, color):
                s = Select(options = options, value = init)
                r = standardfig.line(x = &#39;date&#39;, y = &#39;cases&#39;, source = src, line_width = 3, line_color = color)
                li = LegendItem(label = init, renderers = [r])
                s.js_on_change(&#39;value&#39;, CustomJS(args=dict(s0=source, s1=src, li=li),
                                                 code=&#34;&#34;&#34;
                                            var c = cb_obj.value;
                                            var y = s0.data[c];
                                            s1.data[&#39;cases&#39;] = y;
                                            li.label = {value: cb_obj.value};
                                            s1.change.emit();
                                     &#34;&#34;&#34;))
                return s, li

            s1, li1 = add_line(src1, uniqloc, uniqloc[0], self.scolors[0])
            s2, li2 = add_line(src2, uniqloc, uniqloc[1], self.scolors[1])
            standardfig.add_layout(Legend(items = [li1, li2]))
            standardfig.legend.location = &#39;top_left&#39;
            layout = row(column(row(s1, s2), row(standardfig)))
            panel = Panel(child = layout, title = axis_type)
            panels.append(panel)

        tabs = Tabs(tabs = panels)
        label = standardfig.title
        return tabs

    &#39;&#39;&#39; YEARLY PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_yearly_plot(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot according to arguments. See help(pycoa_date_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        if len(input.clustername.unique()) &gt; 1 :
            print(&#39;Can only display yearly plot for ONE location. I took the first one:&#39;, input.clustername[0])
        input = input.loc[input.clustername == input.clustername[0]].copy()

        panels = []
        listfigs = []
        cases_custom = CocoDisplay.rollerJS()
        input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
        #drop bissextile fine tuning in needed in the future
        input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
        input = input.copy()
        input.loc[:,&#39;allyears&#39;]=input[&#39;date&#39;].apply(lambda x : x.year)
        input[&#39;allyears&#39;] = input[&#39;allyears&#39;].astype(int)
        input.loc[:,&#39;dayofyear&#39;]= input[&#39;date&#39;].apply(lambda x : x.dayofyear)
        allyears = list(input.allyears.unique())
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        if len(input_field)&gt;1:
            CoaError(&#39;Only one variable could be displayed&#39;)
        else:
            input_field=input_field[0]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type,**kwargs)
            i = 0
            r_list=[]
            maxou=-1000
            input[&#39;cases&#39;]=input[input_field]
            line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;]
            colors = itertools.cycle(self.lcolors)
            for loc in list(input.clustername.unique()):
                for year in allyears:
                    input_filter = input.loc[(input.clustername == loc) &amp; (input[&#39;date&#39;].dt.year.eq(year))].reset_index(drop = True)
                    src = ColumnDataSource(input_filter)
                    leg = loc + &#39; &#39; + str(year)
                    r = standardfig.line(x = &#39;dayofyear&#39;, y = input_field, source = src,
                                     color = next(colors), line_width = 3,
                                     legend_label = leg,
                                     hover_line_width = 4, name = input_field)
                    maxou=max(maxou,np.nanmax(input_filter[input_field].values))

            label = input_field
            tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;)]
            formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
            hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;])  # ,PanTool())
            standardfig.add_tools(hover)
            if guideline:
                cross= CrosshairTool()
                standardfig.add_tools(cross)

            if axis_type == &#39;linear&#39;:
                if maxou  &lt; 1e4 :
                    standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title = axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            standardfig.legend.click_policy=&#34;hide&#34;

            labelspd=input.loc[(input.allyears.eq(2021)) &amp; (input.date.dt.day.eq(1))]
            standardfig.xaxis.ticker = list(labelspd[&#39;dayofyear&#39;].astype(int))
            replacelabelspd =  labelspd[&#39;date&#39;].apply(lambda x: str(x.strftime(&#34;%b&#34;)))
            #label_dict = dict(zip(input.loc[input.allyears.eq(2020)][&#39;daymonth&#39;],input.loc[input.allyears.eq(2020)][&#39;date&#39;].apply(lambda x: str(x.day)+&#39;/&#39;+str(x.month))))
            standardfig.xaxis.major_label_overrides = dict(zip(list(labelspd[&#39;dayofyear&#39;].astype(int)),list(replacelabelspd)))

            CocoDisplay.bokeh_legend(standardfig)
            listfigs.append(standardfig)

        tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
        formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
        hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
        standardfig.add_tools(hover)
        if guideline:
            cross= CrosshairTool()
            standardfig.add_tools(cross)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs = panels)
        return tabs

    &#39;&#39;&#39; DECORATORS FOR HISTO VERTICAL, HISTO HORIZONTAL, PIE &amp; MAP&#39;&#39;&#39;
    def decohistomap(func):
        &#34;&#34;&#34;
        Decorator function used for histogram and map
        &#34;&#34;&#34;
        @wraps(func)
        def inner_hm(self, input = None, input_field = None, **kwargs):
            tile = kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])

            maplabel = kwargs.get(&#39;maplabel&#39;, None)
            if not isinstance(maplabel,list):
                    maplabel=[maplabel]
            #if maplabel:
            #    maplabel = maplabel

            if &#39;map&#39; in func.__name__:
                kwargs[&#39;maplabel&#39;] = maplabel

            orientation = kwargs.get(&#39;orientation&#39;, self.dvisu_default[&#39;orientation&#39;])
            cursor_date = kwargs.get(&#39;cursor_date&#39;, None)
            #if orientation:
            #    kwargs[&#39;orientation&#39;] = orientation
            #kwargs[&#39;cursor_date&#39;] = kwargs.get(&#39;cursor_date&#39;,  self.dvisu_default[&#39;cursor_date&#39;])
            if isinstance(input[&#39;location&#39;].iloc[0],list):
                input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
                input = input.explode(&#39;location&#39;)
            else:
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

            uniqloc = input.clustername.unique()

            geopdwd = input
            if maplabel and &#39;unsorted&#39; in maplabel:
                pass
            else:
                geopdwd = geopdwd.sort_values(by=input_field, ascending = False).reset_index(drop=True)

            started = geopdwd.date.min()
            ended = geopdwd.date.max()
            if cursor_date:
                date_slider = DateSlider(title = &#34;Date: &#34;, start = started, end = ended,
                                     value = ended, step=24 * 60 * 60 * 1000, orientation = orientation)
                #wanted_date = date_slider.value_as_datetime.date()

            #if func.__name__ == &#39;pycoa_mapfolium&#39; or func.__name__ == &#39;pycoa_map&#39; or func.__name__ == &#39;innerdecomap&#39; or func.__name__ == &#39;innerdecopycoageo&#39;:
            if func.__name__ in [&#39;pycoa_mapfolium&#39;,&#39;pycoa_map&#39;,&#39;pycoageo&#39; ,&#39;pycoa_pimpmap&#39;]:
                if isinstance(input.location.to_list()[0],list):
                    geom = self.location_geometry
                    geodic={loc:geom.loc[geom.location==loc][&#39;geometry&#39;].values[0] for loc in geopdwd.location.unique()}
                    geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(geodic)
                else:
                    geopdwd = pd.merge(geopdwd, self.location_geometry, on=&#39;location&#39;)

                kwargs[&#39;tile&#39;] = tile
                if self.iso3country in [&#39;USA&#39;]:#[&#39;FRA&#39;,&#39;USA&#39;]
                    geo = copy.deepcopy(self.geo)
                    d = geo._list_translation
                    if func.__name__ != &#39;pycoa_mapfolium&#39;:
                        if any(i in list(geopdwd.codelocation.unique()) for i in d.keys()) \
                        or any(True for i in d.keys() if &#39;&#39;.join(list(geopdwd.codelocation.unique())).find(i)!=-1):
                            geo.set_dense_geometry()
                            kwargs.pop(&#39;tile&#39;)
                        else:
                            geo.set_main_geometry()
                            d = {}
                        new_geo = geo.get_data()[[&#39;name_&#39;+self.granularity,&#39;geometry&#39;]]
                        new_geo = new_geo.rename(columns={&#39;name_&#39;+self.granularity:&#39;location&#39;})
                        new_geo = new_geo.set_index(&#39;location&#39;)[&#39;geometry&#39;].to_dict()

                        geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(new_geo)
                geopdwd = gpd.GeoDataFrame(geopdwd, geometry=geopdwd.geometry, crs=&#34;EPSG:4326&#34;)

            if func.__name__ == &#39;pycoa_histo&#39;:
                pos = {}
                new = pd.DataFrame()
                n = 0
                for i in uniqloc:
                    perloc = geopdwd.loc[geopdwd.clustername == i]
                    if all(perloc != 0):
                        pos = perloc.index[0]
                        if new.empty:
                            new = perloc
                        else:
                            new = new.append(perloc)
                        n += 1
                geopdwd = new.reset_index(drop=True)
            if cursor_date:
                date_slider = date_slider
            else:
                date_slider = None
            kwargs[&#39;date_slider&#39;] = date_slider
            return func(self, geopdwd, input_field, **kwargs)
        return inner_hm

    &#39;&#39;&#39; VERTICAL HISTO &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    def pycoa_histo(self,  geopdwd, input_field = None, **kwargs):
        &#39;&#39;&#39;
            -----------------
            Create 1D histogramme by value according to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - geopdwd : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filter = geopdwd_filter.reset_index(drop = True)

        input = geopdwd_filter.rename(columns = {&#39;cases&#39;: input_field})
        bins = kwargs.get(&#39;bins&#39;, None)

        if &#39;location&#39; in input.columns:
            uniqloc = list(input.clustername.unique())
            allval  = input.loc[input.clustername.isin(uniqloc)][[&#39;clustername&#39;, input_field,&#39;permanentdisplay&#39;]]
            min_val = allval[input_field].min()
            max_val = allval[input_field].max()

            if bins:
                bins = bins
            else:
                if len(uniqloc) == 1:
                    bins = 2
                    min_val = 0.
                else:
                    bins = 11

            delta = (max_val - min_val ) / bins
            interval = [ min_val + i*delta for i in range(bins+1)]

            contributors = {  i : [] for i in range(bins+1)}
            for i in range(len(allval)):
                rank = bisect.bisect_left(interval, allval.iloc[i][input_field])
                if rank == bins+1:
                    rank = bins
                contributors[rank].append(allval.iloc[i][&#39;clustername&#39;])

            colors = itertools.cycle(self.lcolors)
            lcolors = [next(colors) for i in range(bins+1)]
            contributors = dict(sorted(contributors.items()))
            frame_histo = pd.DataFrame({
                              &#39;left&#39;: [0]+interval[:-1],
                              &#39;right&#39;:interval,
                              &#39;middle_bin&#39;: [format((i+j)/2, &#34;.1f&#34;) for i,j in zip([0]+interval[:-1],interval)],
                              &#39;top&#39;: [len(i) for i in list(contributors.values())],
                              &#39;contributors&#39;: [&#39;, &#39;.join(i) for i in contributors.values()],
                              &#39;colors&#39;: lcolors})
        #tooltips = &#34;&#34;&#34;
        #&lt;div style=&#34;width: 400px&#34;&gt;
        #&lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
        #&lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
        #&lt;/div&gt;
        #&#34;&#34;&#34;
        tooltips = &#34;&#34;&#34;
        &lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
        &lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
        &#34;&#34;&#34;
        hover_tool = HoverTool(tooltips = tooltips)
        panels = []
        bottom = 0
        x_axis_type, y_axis_type, axis_type_title = 3 * [&#39;linear&#39;]
        for axis_type in [&#34;linear&#34;, &#34;linlog&#34;, &#34;loglin&#34;, &#34;loglog&#34;]:
            if axis_type == &#39;linlog&#39;:
                y_axis_type, axis_type_title = &#39;log&#39;, &#39;logy&#39;
            if axis_type == &#39;loglin&#39;:
                x_axis_type, y_axis_type, axis_type_title = &#39;log&#39;, &#39;linear&#39;, &#39;logx&#39;
            if axis_type == &#39;loglog&#39;:
                x_axis_type, y_axis_type = &#39;log&#39;, &#39;log&#39;
                axis_type_title = &#39;loglog&#39;

            standardfig = self.standardfig(x_axis_type=x_axis_type, y_axis_type=y_axis_type, **kwargs)

            standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)
            standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
            standardfig.add_tools(hover_tool)
            standardfig.x_range = Range1d(1.05 * interval[0], 1.05 * interval[-1])
            standardfig.y_range = Range1d(0, 1.05 * frame_histo[&#39;top&#39;].max())
            if x_axis_type == &#34;log&#34;:
                left = 0.8
                if frame_histo[&#39;left&#39;][0] &lt;= 0:
                    frame_histo.at[0, &#39;left&#39;] = left
                else:
                    left  = frame_histo[&#39;left&#39;][0]
                standardfig.x_range = Range1d(left, 10 * interval[-1])

            if y_axis_type == &#34;log&#34;:
                bottom = 0.0001
                standardfig.y_range = Range1d(0.001, 10 * frame_histo[&#39;top&#39;].max())

            standardfig.quad(source=ColumnDataSource(frame_histo), top=&#39;top&#39;, bottom=bottom, left=&#39;left&#39;, \
                             right=&#39;right&#39;, fill_color=&#39;colors&#39;)
            panel = Panel(child=standardfig, title=axis_type_title)
            panels.append(panel)
        tabs = Tabs(tabs=panels)
        return tabs

    &#39;&#39;&#39; DECORATORS FOR HISTO VERTICAL, HISTO HORIZONTAL, PIE &#39;&#39;&#39;
    def decohistopie(func):
        @wraps(func)
        def inner_decohistopie(self, geopdwd, input_field, **kwargs):
            &#34;&#34;&#34;
            Decorator for
            Horizontal histogram &amp; Pie Chart
            &#34;&#34;&#34;
            geopdwd[&#39;cases&#39;] = geopdwd[input_field]
            maplabel = kwargs.get(&#39;maplabel&#39;,None)
            plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
            plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

            geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
            geopdwd_filter = geopdwd_filter.reset_index(drop = True)
            geopdwd_filter[&#39;cases&#39;] = geopdwd_filter[input_field]
            cursor_date = kwargs.get(&#39;cursor_date&#39;,self.dvisu_default[&#39;cursor_date&#39;])
            date_slider = kwargs[&#39;date_slider&#39;]
            my_date = geopdwd.date.unique()
            dico_utc = {i: DateSlider(value=i).value for i in my_date}
            geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
            #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
            #geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])
            geopdwd = geopdwd.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
            geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])
            locunique = geopdwd_filter.clustername.unique()#geopdwd_filtered.location.unique()
            geopdwd_filter = geopdwd_filter.copy()
            nmaxdisplayed = MAXCOUNTRIESDISPLAYED


            if len(locunique) &gt;= nmaxdisplayed :#and func.__name__ != &#39;pycoa_pie&#39; :
                if func.__name__ != &#39;pycoa_pie&#39; :
                    geopdwd_filter = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed])]
                else:
                    geopdwd_filter_first = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed-1])]
                    geopdwd_filter_other = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[nmaxdisplayed-1:])]
                    geopdwd_filter_other = geopdwd_filter_other.groupby(&#39;date&#39;).sum()
                    geopdwd_filter_other[&#39;location&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;clustername&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;codelocation&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;permanentdisplay&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;rolloverdisplay&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;colors&#39;] = &#39;#FFFFFF&#39;

                    geopdwd_filter = geopdwd_filter_first
                    geopdwd_filter = geopdwd_filter.append(geopdwd_filter_other)
            if func.__name__ == &#39;pycoa_horizonhisto&#39; :
                #geopdwd_filter[&#39;bottom&#39;] = geopdwd_filter.index
                geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;cases&#39;]
                geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;cases&#39;]
                geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;left&#39;].apply(lambda x: 0 if x &gt; 0 else x)
                geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 0 if x &lt; 0 else x)

                n = len(geopdwd_filter.index)
                d =  plot_height / n
                ymax = plot_height

                geopdwd_filter[&#39;top&#39;] = [ymax*(n-i)/n + d/2   for i in range(n)]
                geopdwd_filter[&#39;bottom&#39;] = [ymax*(n-i)/n - d/2 for i in range(n)]
                geopdwd_filter[&#39;horihistotexty&#39;] = geopdwd_filter[&#39;bottom&#39;] + d/2
                geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
                if maplabel and &#39;label%&#39; in maplabel:
                    geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 100.*x)
                    geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
                    geopdwd_filter[&#39;horihistotext&#39;] = [str(round(i))+&#39;%&#39; for i in geopdwd_filter[&#39;right&#39;]]
                else:
                    geopdwd_filter[&#39;horihistotext&#39;] = [ &#39;{:.3g}&#39;.format(float(i)) if float(i)&gt;1.e4 else round(float(i),2) for i in geopdwd_filter[&#39;right&#39;] ]
                    geopdwd_filter[&#39;horihistotext&#39;] = [str(i) for i in geopdwd_filter[&#39;horihistotext&#39;]]
            if func.__name__ == &#39;pycoa_pie&#39; :
                geopdwd_filter = self.add_columns_for_pie_chart(geopdwd_filter,input_field)
                geopdwd = self.add_columns_for_pie_chart(geopdwd,input_field)
                if maplabel and &#39;label%&#39; in maplabel:
                    geopdwd_filter[&#39;textdisplayed2&#39;] = geopdwd_filter[&#39;percentage&#39;]
                    geopdwd[&#39;textdisplayed2&#39;] =  geopdwd[&#39;percentage&#39;]

            source = ColumnDataSource(data = geopdwd)
            input_filter = geopdwd_filter
            srcfiltered = ColumnDataSource(data = input_filter)
            max_value = max(input_filter[&#39;cases&#39;])
            min_value = min(input_filter[&#39;cases&#39;])
            min_value_gt0 = min(input_filter[input_filter[&#39;cases&#39;] &gt; 0][&#39;cases&#39;])
            panels = []
            for axis_type in self.ax_type:
                plot_width = kwargs[&#39;plot_width&#39;]
                plot_height = kwargs[&#39;plot_height&#39;]
                standardfig = self.standardfig( x_axis_type = axis_type,  x_range = (1.05*min_value, 1.05 * max_value),**kwargs)
                if maplabel and &#39;label%&#39; in maplabel:
                    standardfig.x_range = Range1d(0.01, 1.2 * max_value*100)
                    standardfig.xaxis.axis_label = &#39;percentage(%)&#39;
                    standardfig.xaxis.formatter = BasicTickFormatter(use_scientific=False)
                else:
                    standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
                    standardfig.x_range = Range1d(0.01, 1.2 * max_value)
                if not input_filter[input_filter[input_field] &lt; 0.].empty:
                    standardfig.x_range = Range1d(1.2 * min_value, 1.2 * max_value)

                if axis_type == &#34;log&#34;:
                    if not input_filter[input_filter[input_field] &lt; 0.].empty:
                        print(&#39;Some value are negative, can\&#39;t display log scale in this context&#39;)
                    else:
                        if func.__name__ == &#39;pycoa_horizonhisto&#39; :
                            if maplabel and &#39;label%&#39; in maplabel:
                                standardfig.x_range = Range1d(0.01, 50 * max_value*100)
                            else:
                                standardfig.x_range = Range1d(0.01, 50 * max_value)
                            srcfiltered.data[&#39;left&#39;] = [0.01] * len(srcfiltered.data[&#39;right&#39;])

                if func.__name__ == &#39;pycoa_pie&#39;:
                    if not input_filter[input_filter[input_field] &lt; 0.].empty:
                        raise CoaKeyError(&#39;Some values are negative, can\&#39;t display a Pie chart, try histo by location&#39;)
                    standardfig.plot_width = plot_height
                    standardfig.plot_height = plot_height

                if date_slider:
                    date_slider.width = int(0.8*plot_width)
                    callback = CustomJS(args = dict(source = source,
                                                  source_filter = srcfiltered,
                                                  date_slider = date_slider,
                                                  ylabel = standardfig.yaxis[0],
                                                  title = standardfig.title,
                                                  x_range = standardfig.x_range,
                                                  x_axis_type = axis_type,
                                                  figure = standardfig),
                            code = &#34;&#34;&#34;
                            var date_slide = date_slider.value;
                            var dates = source.data[&#39;date_utc&#39;];
                            var val = source.data[&#39;cases&#39;];
                            var loc = source.data[&#39;clustername&#39;];
                            //var loc = source.data[&#39;location&#39;];
                            var subregion = source.data[&#39;name_subregion&#39;];
                            var codeloc = source.data[&#39;codelocation&#39;];
                            var colors = source.data[&#39;colors&#39;];

                            var newval = [];
                            var newloc = [];
                            var newcolors = [];
                            var newcodeloc = [];
                            var newname_subregion = [];
                            var labeldic = {};
                            for (var i = 0; i &lt; dates.length; i++){
                            if (dates[i] == date_slide){
                                newval.push(parseFloat(val[i]));
                                newloc.push(loc[i]);
                                newcodeloc.push(codeloc[i]);
                                newcolors.push(colors[i]);
                                if(typeof subregion !== &#39;undefined&#39;)
                                    newname_subregion.push(subregion[i]);

                                }
                            }
                            var len = source_filter.data[&#39;clustername&#39;].length;

                            var indices = new Array(len);
                            for (var i = 0; i &lt; len; i++) indices[i] = i;

                            indices.sort(function (a, b) { return newval[a] &gt; newval[b] ? -1 : newval[a] &lt; newval[b] ? 1 : 0; });
                            var orderval = [];
                            var orderloc = [];
                            var ordercodeloc = [];
                            var ordername_subregion = [];
                            var ordercolors = [];
                            var textdisplayed = [];
                            for (var i = 0; i &lt; len; i++)
                            {
                                orderval.push(newval[indices[i]]);
                                orderloc.push(newloc[indices[i]]);
                                ordercodeloc.push(newcodeloc[indices[i]]);

                                if(typeof subregion !== &#39;undefined&#39;)
                                    ordername_subregion.push(newname_subregion[i]);
                                ordercolors.push(newcolors[indices[i]]);
                                //labeldic[len-indices[i]] = newcodeloc[indices[i]];
                                textdisplayed.push(newcodeloc[indices[i]].padStart(40,&#39; &#39;));
                            }


                            source_filter.data[&#39;cases&#39;] = orderval;
                            const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;
                            var tot = orderval.reduce(reducer);
                            var top = [];
                            var bottom = [];
                            var starts = [];
                            var ends = [];
                            var middle = [];
                            var text_x = [];
                            var text_y = [];
                            var r = 0.7;
                            var bthick = 0.95;
                            var cumul = 0.;
                            var percentage = [];
                            var angle = [];
                            var text_size = [];
                            var left_quad = [];
                            var right_quad = [];

                            for(var i = 0; i &lt; orderval.length; i++)
                            {
                                cumul += ((orderval[i] / tot) * 2 * Math.PI);
                                ends.push(cumul);
                                if(i==0)
                                    starts.push(0);
                                else
                                    starts.push(ends[i-1]);
                                middle.push((ends[i]+starts[i])/2);
                                text_x.push(r*Math.cos(middle[i]));
                                text_y.push(r*Math.sin(middle[i]));
                                percentage.push(String(100.*orderval[i] / tot).slice(0, 4));
                                angle.push((orderval[i] / tot) * 2 * Math.PI)
                                /*if ((ends[i]-starts[i]) &gt; 0.08*(2 * Math.PI))
                                    text_size.push(&#39;10pt&#39;);
                                else
                                    text_size.push(&#39;6pt&#39;);*/

                                //top.push((orderval.length-i) + bthick/2);
                                //bottom.push((orderval.length-i) - bthick/2);

                                if (isNaN(orderval[i])) orderval[i] = 0.;
                                if(orderval[i]&lt;=0.)
                                {
                                    left_quad.push(orderval[i]);
                                    right_quad.push(0.);
                                }
                                else
                                {
                                    left_quad.push(0);
                                    right_quad.push(orderval[i]);
                                }
                            }

                            source_filter.data[&#39;clustername&#39;] = orderloc;
                            source_filter.data[&#39;codelocation&#39;] = ordercodeloc;
                            //source_filter.data[&#39;colors&#39;] = ordercolors;

                            if(typeof subregion !== &#39;undefined&#39;)
                                source_filter.data[&#39;rolloverdisplay&#39;] = ordername_subregion;
                            else
                                source_filter.data[&#39;rolloverdisplay&#39;] = orderloc;

                            source_filter.data[&#39;ends&#39;] = ends;
                            source_filter.data[&#39;starts&#39;] = starts;
                            source_filter.data[&#39;middle&#39;] = middle;
                            source_filter.data[&#39;text_x&#39;] = text_x;
                            source_filter.data[&#39;text_y&#39;] = text_y;
                            //source_filter.data[&#39;text_size&#39;] = text_size;
                            source_filter.data[&#39;percentage&#39;] = percentage;
                            source_filter.data[&#39;angle&#39;] = angle;


                            source_filter.data[&#39;left&#39;] = left_quad;
                            source_filter.data[&#39;right&#39;] = right_quad;

                            var mid =[];
                            var ht = [];
                            var textdisplayed2 = [];

                            var n = right_quad.length;
                            var d = figure.plot_height / n;
                            var ymax = figure.plot_height;

                            for(i=0; i&lt;right_quad.length;i++){
                                top.push(parseInt(ymax*(n-i)/n+d/2));
                                bottom.push(parseInt(ymax*(n-i)/n-d/2));
                                mid.push(parseInt(ymax*(n-i)/n));
                                labeldic[parseInt(ymax*(n-i)/n)] = ordercodeloc[i];

                                ht.push(right_quad[i].toFixed(2).toString());
                                var a=new Intl.NumberFormat().format(right_quad[i])
                                textdisplayed2.push(a.toString().padStart(26,&#39; &#39;));
                                //textdisplayed2.push(right_quad[i].toFixed(2).toString().padStart(40,&#39; &#39;));

                            }
                            source_filter.data[&#39;top&#39;] = top;
                            source_filter.data[&#39;bottom&#39;] = bottom;

                            source_filter.data[&#39;horihistotextxy&#39;] =  mid;
                            source_filter.data[&#39;horihistotextx&#39;] =  right_quad;
                            source_filter.data[&#39;horihistotext&#39;] =  ht;
                            source_filter.data[&#39;permanentdisplay&#39;] = ordercodeloc;
                            source_filter.data[&#39;textdisplayed&#39;] = textdisplayed;
                            source_filter.data[&#39;textdisplayed2&#39;] = textdisplayed2;
                            var maxx = Math.max.apply(Math, right_quad);
                            var minx = Math.min.apply(Math, left_quad);

                            ylabel.major_label_overrides = labeldic;
                            console.log(labeldic);
                            x_range.end =  1.2 * maxx;
                            x_range.start =  1.05 * minx;
                            if(minx &gt;= 0){
                                x_range.start =  0.01;
                                source_filter.data[&#39;left&#39;] = Array(left_quad.length).fill(0.01);
                                }
                            var tmp = title.text;
                            tmp = tmp.slice(0, -11);
                            var dateconverted = new Date(date_slide);
                            var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                            var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                            var yyyy = dateconverted.getFullYear();
                            var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                            title.text = tmp + dmy+&#34;)&#34;;

                            source_filter.change.emit();
                        &#34;&#34;&#34;)
                    date_slider.js_on_change(&#39;value&#39;, callback)
                cases_custom = CocoDisplay.rollerJS()
                if func.__name__ == &#39;pycoa_pie&#39; :
                    standardfig.add_tools(HoverTool(
                        tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), (&#39;%&#39;,&#39;@percentage&#39;), ],
                        formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, &#39;%&#39;:&#39;printf&#39;},
                        point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
                else:
                    standardfig.add_tools(HoverTool(
                        tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), ],
                        formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, },
                        point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
                panel = Panel(child = standardfig, title = axis_type)
                panels.append(panel)
            return func(self, srcfiltered, panels, date_slider)
        return inner_decohistopie

    &#39;&#39;&#39; VERTICAL HISTO &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decohistopie
    def pycoa_horizonhisto(self, srcfiltered, panels, date_slider):
        &#39;&#39;&#39;
            -----------------
            Create 1D histogramme by location according to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        n = len(panels)
        new_panels = []
        for i in range(n):
            fig = panels[i].child
            fig.y_range = Range1d(min(srcfiltered.data[&#39;bottom&#39;]), max(srcfiltered.data[&#39;top&#39;]))
            fig.yaxis[0].formatter = NumeralTickFormatter(format=&#34;0.0&#34;)
            ytick_loc = [int(i) for i in srcfiltered.data[&#39;horihistotexty&#39;]]
            fig.yaxis.ticker  = ytick_loc
            label_dict = dict(zip(ytick_loc,srcfiltered.data[&#39;permanentdisplay&#39;]))
            fig.yaxis.major_label_overrides = label_dict

            #print(fig.y_range ,fig.yaxis.major_label_overrides)
            fig.quad(source = srcfiltered,
                top=&#39;top&#39;, bottom = &#39;bottom&#39;, left = &#39;left&#39;, right = &#39;right&#39;, color = &#39;colors&#39;, line_color = &#39;black&#39;,
                line_width = 1, hover_line_width = 2)

            labels = LabelSet(
                    x = &#39;horihistotextx&#39;,
                    y = &#39;horihistotexty&#39;,
                    x_offset=5,
                    y_offset=-4,
                    text = &#39;horihistotext&#39;,
                    source = srcfiltered,text_font_size=&#39;10px&#39;,text_color=&#39;black&#39;)
            fig.add_layout(labels)

            panel = Panel(child = fig, title = panels[i].title)
            new_panels.append(panel)
        tabs = Tabs(tabs = new_panels)
        if date_slider:
                tabs = column(date_slider,tabs)
        return tabs

    &#39;&#39;&#39; PIE &#39;&#39;&#39;
    def add_columns_for_pie_chart(self,df,column_name):
        df = df.copy()
        column_sum = df[column_name].sum()
        df[&#39;percentage&#39;] = df[column_name]/column_sum
        percentages = [0]  + df[&#39;percentage&#39;].cumsum().tolist()
        df[&#39;angle&#39;] = (df[column_name]/column_sum)*2 * np.pi
        df[&#39;starts&#39;] = [p * 2 * np.pi for p in percentages[:-1]]
        df[&#39;ends&#39;] = [p * 2 * np.pi for p in percentages[1:]]
        df[&#39;diff&#39;] = (df[&#39;ends&#39;] - df[&#39;starts&#39;])
        df[&#39;middle&#39;] = df[&#39;starts&#39;]+np.abs(df[&#39;ends&#39;]-df[&#39;starts&#39;])/2.
        df[&#39;cos&#39;] = np.cos(df[&#39;middle&#39;]) * 0.9
        df[&#39;sin&#39;] = np.sin(df[&#39;middle&#39;]) * 0.9

        df[&#39;text_size&#39;] = &#39;8pt&#39;
        df[&#39;textdisplayed&#39;] = df[&#39;permanentdisplay&#39;].str.pad(36, side = &#34;left&#34;)
        locale.setlocale(locale.LC_ALL, &#39;en_US&#39;)
        df[&#39;textdisplayed2&#39;] = [ locale.format(&#34;%d&#34;, i, grouping=True)\
                for i in df[column_name]]
        #df[&#39;textdisplayed2&#39;] = df[column_name].astype(str) #[i.str for i in df[column_name]]
        df[&#39;textdisplayed2&#39;] = df[&#39;textdisplayed2&#39;].str.pad(26, side = &#34;left&#34;)
        #df[&#39;textdisplayed2&#39;]  = df[column_name].str.pad(26, side = &#34;left&#34;)
        df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed&#39;]=&#39;&#39;
        df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed2&#39;]=&#39;&#39;
        df[&#39;percentage&#39;] = 100.*df[&#39;percentage&#39;]
        return df

    @decowrapper
    @decohistomap
    @decohistopie
    def pycoa_pie(self, srcfiltered, panels, date_slider):
        &#39;&#39;&#39;
            -----------------
            Create a pie chart according to arguments.
            See help(pycoa_pie).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
        &#39;&#39;&#39;
        standardfig = panels[0].child
        standardfig.plot_height=400
        standardfig.plot_width=400
        standardfig.x_range = Range1d(-1.1, 1.1)
        standardfig.y_range = Range1d(-1.1, 1.1)
        standardfig.axis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None

        standardfig.wedge(x=0, y=0, radius=1.,line_color=&#39;#E8E8E8&#39;,
        start_angle=cumsum(&#39;angle&#39;, include_zero=True), end_angle=cumsum(&#39;angle&#39;),
        fill_color=&#39;colors&#39;, legend_label=&#39;clustername&#39;, source=srcfiltered)
        standardfig.legend.visible = False

        labels = LabelSet(x=0, y=0,text=&#39;textdisplayed&#39;,angle=cumsum(&#39;angle&#39;, include_zero=True),
        text_font_size=&#34;10pt&#34;,source=srcfiltered,render_mode=&#39;canvas&#39;)

        labels2 = LabelSet(x=0, y=0, text=&#39;textdisplayed2&#39;,
        angle=cumsum(&#39;angle&#39;, include_zero=True),text_font_size=&#34;8pt&#34;,source=srcfiltered)

        standardfig.add_layout(labels)
        standardfig.add_layout(labels2)
        if date_slider:
            standardfig = column(date_slider,standardfig)
        return standardfig

    &#39;&#39;&#39; MAP FOLIUM &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    def pycoa_mapfolium(self, geopdwd, input_field, **kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a map folium to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        title = kwargs.get(&#39;title&#39;, None)
        tile =  kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])
        tile = CocoDisplay.convert_tile(tile, &#39;folium&#39;)
        maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
        plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
        plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

        geopdwd[&#39;cases&#39;] = geopdwd[input_field]
        geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
        geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered[input_field]
        my_date = geopdwd.date.unique()
        dico_utc = {i: DateSlider(value=i).value for i in my_date}
        geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
        #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
        #geopdwd_filtered = geopdwd_filtered.sort_values(by=&#39;cases&#39;, ascending = False).reset_index()
        #locunique = geopdwd_filtered.clustername.unique()#geopdwd_filtered.location.unique()
        if self.database_name == &#39;risklayer&#39;:
            geopdwd_filtered = geopdwd_filtered.loc[geopdwd_filtered.geometry.notna()]

        uniqloc = list(geopdwd_filtered.codelocation.unique())
        geopdwd_filtered = geopdwd_filtered.drop(columns=[&#39;date&#39;, &#39;colors&#39;])

        msg = &#34;(data from: {})&#34;.format(self.database_name)

        minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds

        mapa = folium.Map(tiles=tile, attr=&#39;&lt;a href=\&#34;http://pycoa.fr\&#34;&gt; ©pycoa.fr &lt;/a&gt;&#39; + msg)
        #min_lat=minx, max_lat=maxx, min_lon=miny, max_lon=maxy)
        #location=[geopdwd_filtered.centroid.y.mean(),geopdwd_filtered.centroid.x.mean()],)
        if self.dbld[self.database_name][0] != &#39;WW&#39;:
            mapa.fit_bounds([(miny, minx), (maxy, maxx)])

        fig = Figure(width=plot_width, height=plot_height)
        fig.add_child(mapa)
        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[input_field]),
                                                     np.nanmax(geopdwd_filtered[input_field]))
        min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

        invViridis256 = Viridis256[::-1]
        if &#39;log&#39; in maplabel:
            geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0][&#39;cases&#39;]
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#d9d9d9&#39;)
            colormap =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
        else:
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#d9d9d9&#39;)
            colormap = branca.colormap.LinearColormap(color_mapper.palette).scale(min_col, max_col)
        colormap.caption =  title
        colormap.add_to(mapa)
        map_id = colormap.get_name()

        custom_label_colorbar_js = &#34;&#34;&#34;
        var div = document.getElementById(&#39;legend&#39;);
        var ticks = document.getElementsByClassName(&#39;tick&#39;)
        for(var i = 0; i &lt; ticks.length; i++){
        var values = ticks[i].textContent.replace(&#39;,&#39;,&#39;&#39;)
        val = parseFloat(values).toExponential(1).toString().replace(&#34;+&#34;, &#34;&#34;)
        if(parseFloat(ticks[i].textContent) == 0) val = 0.
        div.innerHTML = div.innerHTML.replace(ticks[i].textContent,val);
        }
        &#34;&#34;&#34;
        e = Element(custom_label_colorbar_js)
        html = colormap.get_root()
        html.script.get_root().render()
        html.script._children[e.get_name()] = e
        geopdwd_filtered[input_field + &#39;scientific_format&#39;] = \
            ([&#39;{:.5g}&#39;.format(i) for i in geopdwd_filtered[&#39;cases&#39;]])
        # ([&#39;{:.3g}&#39;.format(i) if i&gt;100000 else i for i in geopdwd_filter[input_field]])

        map_dict = geopdwd_filtered.set_index(&#39;location&#39;)[input_field].to_dict()
        if np.nanmin(geopdwd_filtered[input_field]) == np.nanmax(geopdwd_filtered[input_field]):
            map_dict[&#39;FakeCountry&#39;] = 0.

        if &#39;log&#39; in maplabel:
            color_scale =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
        else:
            color_scale = LinearColormap(color_mapper.palette, vmin=min(map_dict.values()), vmax=max(map_dict.values()))

        def get_color(feature):
            value = map_dict.get(feature[&#39;properties&#39;][&#39;location&#39;])
            if value is None or np.isnan(value):
                return &#39;#8c8c8c&#39;  # MISSING -&gt; gray
            else:
                return color_scale(value)

        displayed = &#39;rolloverdisplay&#39;
        folium.GeoJson(
            geopdwd_filtered,
            style_function=lambda x:
            {
                &#39;fillColor&#39;: get_color(x),
                &#39;fillOpacity&#39;: 0.8,
                &#39;color&#39;: None
            },
            highlight_function=lambda x: {&#39;weight&#39;: 2, &#39;color&#39;: &#39;green&#39;},
            tooltip=folium.features.GeoJsonTooltip(fields=[displayed, input_field + &#39;scientific_format&#39;],
                                                   aliases=[&#39;location&#39; + &#39;:&#39;, input_field + &#34;:&#34;],
                                                   style=&#34;&#34;&#34;
                        background-color: #F0EFEF;
                        border: 2px solid black;
                        border-radius: 3px;
                        box-shadow: 3px;
                        opacity: 0.2;
                        &#34;&#34;&#34;),
            # &#39;&lt;div style=&#34;barialckground-color: royalblue 0.2; color: black; padding: 2px; border: 1px solid black; border-radius: 2px;&#34;&gt;&#39;+input_field+&#39;&lt;/div&gt;&#39;])
        ).add_to(mapa)
        return mapa

    &#39;&#39;&#39; DECORATOR FOR MAP BOKEH &#39;&#39;&#39;
    def decopycoageo(func):
        @wraps(func)
        def innerdecopycoageo(self, geopdwd, input_field, **kwargs):
            geopdwd[&#39;cases&#39;] = geopdwd[input_field]
            geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
            geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
            geopdwd_filtered = gpd.GeoDataFrame(geopdwd_filtered, geometry=geopdwd_filtered.geometry, crs=&#34;EPSG:4326&#34;)
            geopdwd = geopdwd.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False])
            geopdwd_filtered = geopdwd_filtered.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False]).drop(columns=[&#39;date&#39;, &#39;colors&#39;])
            new_poly = []
            geolistmodified = dict()

            for index, row in geopdwd_filtered.iterrows():
                split_poly = []
                new_poly = []
                if row[&#39;geometry&#39;]:
                    for pt in self.get_polycoords(row):
                        if type(pt) == tuple:
                            new_poly.append(CocoDisplay.wgs84_to_web_mercator(pt))
                        elif type(pt) == list:
                            shifted = []
                            for p in pt:
                                shifted.append(CocoDisplay.wgs84_to_web_mercator(p))
                            new_poly.append(sg.Polygon(shifted))
                        else:
                            raise CoaTypeError(&#34;Neither tuple or list don&#39;t know what to do with \
                                your geometry description&#34;)

                    if type(new_poly[0]) == tuple:
                        geolistmodified[row[&#39;location&#39;]] = sg.Polygon(new_poly)
                    else:
                        geolistmodified[row[&#39;location&#39;]] = sg.MultiPolygon(new_poly)
            ng = pd.DataFrame(geolistmodified.items(), columns=[&#39;location&#39;, &#39;geometry&#39;])
            geolistmodified = gpd.GeoDataFrame({&#39;location&#39;: ng[&#39;location&#39;], &#39;geometry&#39;: gpd.GeoSeries(ng[&#39;geometry&#39;])}, crs=&#34;epsg:3857&#34;)
            geopdwd_filtered = geopdwd_filtered.drop(columns=&#39;geometry&#39;)
            geopdwd_filtered = pd.merge(geolistmodified, geopdwd_filtered, on=&#39;location&#39;)
            #if kwargs[&#39;wanted_dates&#39;]:
            #    kwargs.pop(&#39;wanted_dates&#39;)
            return func(self, geopdwd, geopdwd_filtered, **kwargs)
        return innerdecopycoageo

    &#39;&#39;&#39; RETURN GEOMETRY, LOCATIO + CASES &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    def pycoageo(self, geopdwd, geopdwd_filtered, **kwargs):
        return geopdwd_filtered

    def decomap(func):
        @wraps(func)
        def innerdecomap(self, geopdwd, geopdwd_filtered, **kwargs):
            title = kwargs.get(&#39;title&#39;, None)
            maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
            tile =  kwargs.get(&#39;tile&#39;, None)
            if tile:
                tile = CocoDisplay.convert_tile(tile, &#39;bokeh&#39;)

            uniqloc = list(geopdwd_filtered.clustername.unique())
            dfLabel = pd.DataFrame()
            sourcemaplabel = ColumnDataSource(dfLabel)
            if maplabel or func.__name__ == &#39;pycoa_pimpmap&#39;:
                locsum = geopdwd_filtered.clustername.unique()
                numberpercluster = geopdwd_filtered[&#39;clustername&#39;].value_counts().to_dict()
                sumgeo = geopdwd_filtered.copy()
                sumgeo[&#39;geometry&#39;] = sumgeo[&#39;geometry&#39;].buffer(0.001) #needed with geopandas 0.10.2
                sumgeo = sumgeo.dissolve(by=&#39;clustername&#39;, aggfunc=&#39;sum&#39;).reset_index()
                sumgeo[&#39;nb&#39;] = sumgeo[&#39;clustername&#39;].map(numberpercluster)
                #print(geopdwd_filtered.loc[geopdwd_filtered.clustername==&#39;Île-de-France&#39;].reset_index(drop=True).explode(index_parts=False))
                centrosx = sumgeo[&#39;geometry&#39;].centroid.x
                centrosy = sumgeo[&#39;geometry&#39;].centroid.y
                cases = sumgeo[&#39;cases&#39;]/sumgeo[&#39;nb&#39;]
                dfLabel=pd.DataFrame({&#39;clustername&#39;:sumgeo.clustername,&#39;centroidx&#39;:centrosx,&#39;centroidy&#39;:centrosy,&#39;cases&#39;:cases,&#39;geometry&#39;:sumgeo[&#39;geometry&#39;]})

                if &#39;spark&#39; in maplabel:
                    sparkos = {i: CocoDisplay.sparkline(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                                (geopdwd.date &gt;= self.when_beg) &amp;
                                (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[&#39;cases&#39;]) for i in locsum }
                    dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                    dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)
                if &#39;spiral&#39; in maplabel:
                    sparkos = {i: CocoDisplay.spiral(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                                (geopdwd.date &gt;= self.when_beg) &amp;
                                (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[[&#39;date&#39;,&#39;cases&#39;,&#39;clustername&#39;]]) for i in locsum }
                    dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                    dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)

                dfLabel[&#39;cases&#39;] = dfLabel[&#39;cases&#39;].round(2)
                # Converting links to html tags
                if &#39;label%&#39; in maplabel:
                    dfLabel[&#39;cases&#39;] = [str(round(float(i*100),2))+&#39;%&#39; for i in dfLabel[&#39;cases&#39;]]
                else:
                    dfLabel[&#39;cases&#39;]=[str(i) for i in dfLabel[&#39;cases&#39;]]
                sourcemaplabel = ColumnDataSource(dfLabel.drop(columns=&#39;geometry&#39;))
            minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds #self.boundary
            #if self.dbld[self.database_name][0] != &#39;WW&#39;:
            #    ratio = 0.05
            #    minx -= ratio*minx
            #    maxx += ratio*maxx
            #    miny -= ratio*miny
            #    maxy += ratio*maxy
            #if func.__name__ == &#39;pycoa_pimpmap&#39;:
            #    dico[&#39;titlebar&#39;]=tit[:-12]+&#39; [ &#39;+dico[&#39;when_beg&#39;].strftime(&#39;%d/%m/%Y&#39;)+ &#39;-&#39;+ tit[-12:-1]+&#39;])&#39;

            kwargs[&#39;plot_width&#39;]=kwargs[&#39;plot_height&#39;]
            x_range=(minx,maxx)
            y_range=(miny,maxy)
            if func.__name__ == &#39;pycoa_pimpmap&#39;:
                standardfig = self.standardfig(x_range=x_range, y_range=y_range, x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)
            else:
                standardfig = self.standardfig(x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)

            if tile:
                wmt = WMTSTileSource(
                            url=tile)
                standardfig.add_tile(wmt)
            else:
                standardfig.background_fill_color = &#34;lightgrey&#34;

            geopdwd_filtered = geopdwd_filtered[[&#39;cases&#39;,&#39;geometry&#39;,&#39;location&#39;,&#39;clustername&#39;,&#39;codelocation&#39;,&#39;rolloverdisplay&#39;]]
            if not dfLabel.empty:
                geopdwd_filtered = geopdwd_filtered.drop(columns = &#39;geometry&#39;)
                geopdwd_filtered = pd.merge(geopdwd_filtered, dfLabel[[&#39;clustername&#39;,&#39;geometry&#39;]], on = &#39;clustername&#39;)
                geopdwd_filtered = geopdwd_filtered.drop_duplicates(subset = [&#39;clustername&#39;])
            if self.dbld[self.database_name][0] == &#39;BEL&#39; :
                reorder = list(geopdwd_filtered.location.unique())
                geopdwd_filtered = geopdwd_filtered.set_index(&#39;location&#39;)
                geopdwd_filtered = geopdwd_filtered.reindex(index = reorder)
                geopdwd_filtered = geopdwd_filtered.reset_index()

            if self.dbld[self.database_name][0] == &#39;GBR&#39; :
                geopdwd = geopdwd.loc[~geopdwd.cases.isnull()]
                geopdwd_filtered  = geopdwd_filtered.loc[~geopdwd_filtered.cases.isnull()]
            return func(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs)
        return innerdecomap

    &#39;&#39;&#39; MAP BOKEH &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    @decomap
    def pycoa_map(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a map bokeh with arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
            - tile : tile
            - maplabel: False
        &#39;&#39;&#39;

        date_slider = kwargs[&#39;date_slider&#39;]
        maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                     np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

        min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

        json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
        geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

        invViridis256 = Viridis256[::-1]
        if &#39;log&#39; in maplabel:
            color_mapper = LogColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#ffffff&#39;)
        else:
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
            color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4, width=standardfig.plot_width, bar_line_cap=&#39;round&#39;,
                             border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
        color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))

        if &#39;label%&#39; in maplabel:
            color_bar.formatter = BasicTickFormatter(use_scientific=False)
            color_bar.formatter = NumeralTickFormatter(format=&#34;0.0%&#34;)

        standardfig.add_layout(color_bar, &#39;below&#39;)

        if date_slider:
            allcases_location, allcases_dates = pd.DataFrame(), pd.DataFrame()
            allcases_location = geopdwd.groupby(&#39;location&#39;)[&#39;cases&#39;].apply(list)
            geopdwd_tmp = geopdwd.drop_duplicates(subset = [&#39;location&#39;]).drop(columns = &#39;cases&#39;)
            geopdwd_tmp = pd.merge(geopdwd_tmp, allcases_location, on = &#39;location&#39;)
            geopdwd_tmp  = geopdwd_tmp.drop_duplicates(subset = [&#39;clustername&#39;])
            geopdwd_tmp = ColumnDataSource(geopdwd_tmp.drop(columns=[&#39;geometry&#39;]))

            sourcemaplabel.data[&#39;rolloverdisplay&#39;] = sourcemaplabel.data[&#39;clustername&#39;]
            callback = CustomJS(args =  dict(source = geopdwd_tmp, source_filter = geopdwd_filtered,
                                          date_sliderjs = date_slider, title=standardfig.title,
                                          maplabeljs = sourcemaplabel),
                        code = &#34;&#34;&#34;
                        var ind_date_max = (date_sliderjs.end-date_sliderjs.start)/(24*3600*1000);
                        var ind_date = (date_sliderjs.value-date_sliderjs.start)/(24*3600*1000);
                        var new_cases = [];
                        var dict = {};
                        var iloop = source_filter.data[&#39;clustername&#39;].length;

                        function form(value) {
                             if(value&gt;10000 || value &lt;0.01)
                                value =  Number.parseFloat(value).toExponential(2);
                             else
                                 value = Number.parseFloat(value).toFixed(2);
                            console.log(value);
                            return value;
                         }
                        for (var i = 0; i &lt; source.get_length(); i++)
                        {
                                var val=form(source.data[&#39;cases&#39;][i][ind_date_max-ind_date]);
                                new_cases.push(val);
                        }
                        if(source.get_length() == 1 &amp;&amp; iloop&gt;1)
                            for(var i = 0; i &lt; iloop; i++)
                                for(var j = 0; j &lt; new_cases.length; j++){
                                source_filter.data[&#39;cases&#39;][i][j] = new_cases[j];
                                }
                        else{
                            source_filter.data[&#39;cases&#39;] = new_cases;
                            }

                        if (maplabeljs.get_length() !== 0){
                            maplabeljs.data[&#39;cases&#39;] = source_filter.data[&#39;cases&#39;];
                            }
                        for (var i = 0; i &lt; maplabeljs.get_length(); i++)
                        {
                            maplabeljs.data[&#39;cases&#39;][i] = form(maplabeljs.data[&#39;cases&#39;][i]).toString();
                            maplabeljs.data[&#39;rolloverdisplay&#39;][i] = source_filter.data[&#39;rolloverdisplay&#39;][i];
                        }
                        var tmp = title.text;
                        tmp = tmp.slice(0, -11);
                        var dateconverted = new Date(date_sliderjs.value);
                        var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                        var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                        var yyyy = dateconverted.getFullYear();
                        var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                        title.text = tmp + dmy+&#34;)&#34;;
                        if (maplabeljs.get_length() !== 0)
                            maplabeljs.change.emit();

                        console.log(maplabeljs.data[&#39;cases&#39;]);
                        source_filter.change.emit();
                    &#34;&#34;&#34;)
            date_slider.js_on_change(&#39;value&#39;, callback)


        standardfig.xaxis.visible = False
        standardfig.yaxis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None
        standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                            fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                            line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)

        if &#39;text&#39; in maplabel :
            labels = LabelSet(
                x = &#39;centroidx&#39;,
                y = &#39;centroidy&#39;,
                text = &#39;cases&#39;,
                source = sourcemaplabel, text_font_size=&#39;10px&#39;,text_color=&#39;white&#39;,background_fill_color=&#39;grey&#39;,background_fill_alpha=0.5)
            standardfig.add_layout(labels)

        #cases_custom = CocoDisplay.rollerJS()
        callback = CustomJS(code=&#34;&#34;&#34;
        //document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.backgroundColor=&#34;transparent&#34;;
        document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.opacity=&#34;0.7&#34;;
        &#34;&#34;&#34; )
        tooltips = &#34;&#34;&#34;
                    &lt;b&gt;location: @rolloverdisplay&lt;br&gt;
                    cases: @cases{0,0.0}&lt;/b&gt;
                   &#34;&#34;&#34;
        standardfig.add_tools(HoverTool(tooltips = tooltips,
        formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;cases&#39;: &#39;printf&#39;,},
        point_policy = &#34;snap_to_data&#34;,callback=callback))  # ,PanTool())
        if date_slider:
            standardfig = column(date_slider, standardfig)
        return standardfig

    &#39;&#39;&#39; PIMPMAP BOKEH &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    @decomap
    def pycoa_pimpmap(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a bokeh map with pimpline label and with to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
            - tile : tile
            - maplabel: False
        &#39;&#39;&#39;
        standardfig.xaxis.visible = False
        standardfig.yaxis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None

        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                     np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

        json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
        geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

        invViridis256 = Viridis256[::-1]
        color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
        color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4,
                             border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
        color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))
        standardfig.add_layout(color_bar, &#39;below&#39;)
        standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                                    fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                                    line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)
        standardfig.image_url(url=&#39;pimpmap&#39;, x=&#39;centroidx&#39;, y=&#39;centroidy&#39;,source=sourcemaplabel,anchor=&#34;center&#34;)
        return standardfig
    ######################
    def tiles_list(self):
        return self.available_tiles
    ###################### BEGIN Static Methods ##################
    @staticmethod
    def convert_tile(tilename, which = &#39;bokeh&#39;):
        &#39;&#39;&#39; Return tiles url according to folium or bokeh resquested&#39;&#39;&#39;
        tile = &#39;openstreet&#39;
        if tilename == &#39;openstreet&#39;:
            if which == &#39;folium&#39;:
                tile = r&#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#39;
            else:
                tile = r&#39;http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png&#39;
        elif tilename == &#39;positron&#39;:
            print(&#39;Problem with positron tile (huge http resquest need to check), esri is then used ...&#39;)
            tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
        #    tile = &#39;https://tiles.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png&#39;
        elif tilename == &#39;esri&#39;:
            tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
        elif tilename == &#39;stamen&#39;:
            tile = r&#39;http://tile.stamen.com/toner/{z}/{x}/{y}.png&#39;
        else:
            print(&#39;Don\&#39;t know you tile ... take default one: &#39;)
        return tile
    #####################
    @staticmethod
    def dict_shorten_loc(toshort):
        &#39;&#39;&#39;
            return a shorten name location
        &#39;&#39;&#39;
        s = []
        if type(toshort) == np.ndarray:
            toshort = list(toshort)
            toshort = [toshort]
            s = &#39;&#39;
        elif type(toshort) == str:
            toshort = [toshort]
            s = &#39;&#39;
        #if type(toshort) != list:
        #    print(&#39;That is weird ...&#39;, toshort, &#39;not str nor list&#39;)
        for val in toshort:
            if not isinstance(val,str):
                val= str(val)
            if type(val) == list:
                val = val[0]
            if val.find(&#39;,&#39;) == -1:
                A = val
            else:
                txt = val.split(&#39;,&#39;)
                if len(txt[0]) &lt; 4 and len(txt[-1]) &lt; 4:
                    A = [txt[0] + &#39;...&#39; + txt[-1]]
                else:
                    A = txt[0][:5] + &#39;...&#39; + txt[-1][-5:]
            if type(s) == list:
                s.append(A)
            else:
                s = A
            if isinstance(s, list):
                s=s[0]
        return s
    ######################
    @staticmethod
    def bokeh_legend(bkfigure):
        toggle_legend_js = CustomJS(args=dict(leg=bkfigure.legend[0]),
                                    code=&#34;&#34;&#34;
        if(leg.visible)
        {
            leg.visible = false;
        }
        else
        {
            leg.visible = true;
        }
        &#34;&#34;&#34;)
        bkfigure.js_on_event(events.DoubleTap, toggle_legend_js)
    ######################
    @staticmethod
    def min_max_range(a_min, a_max):
        &#34;&#34;&#34; Return a cleverly rounded min and max giving raw min and raw max of data.
        Usefull for hist range and colormap
        &#34;&#34;&#34;
        min_p = 0
        max_p = 0
        if a_min != 0:
            min_p = math.floor(math.log10(math.fabs(a_min)))  # power
        if a_max != 0:
            max_p = math.floor(math.log10(math.fabs(a_max)))

        if a_min == 0:
            if a_max == 0:
                p = 0
            else:
                p = max_p
        else:
            if a_max == 0:
                p = min_p
            else:
                p = max(min_p, max_p)

        if a_min != 0:
            min_r = math.floor(a_min / 10 ** (p - 1)) * 10 ** (p - 1)  # min range rounded
        else:
            min_r = 0

        if a_max != 0:
            max_r = math.ceil(a_max / 10 ** (p - 1)) * 10 ** (p - 1)
        else:
            max_r = 0

        if min_r == max_r:
            if min_r == 0:
                min_r = -1
                max_r = 1
                k = 0
            elif max_r &gt; 0:
                k = 0.1
            else:
                k = -0.1
            max_r = (1 + k) * max_r
            min_r = (1 - k) * min_r

        return (min_r, max_r)
    ######################
    @staticmethod
    def save_map2png(map=None, pngfile=&#39;map.png&#39;):
        &#34;&#34;&#34;
        Save map as png geckodriver and PIL packages are needed
        &#34;&#34;&#34;
        size = width_height_default[0], width_height_default[1]
        if pngfile:
            pngfile = pngfile
        img_data = map._to_png(5)
        img = Image.open(io.BytesIO(img_data))
        img.thumbnail(size, Image.ANTIALIAS)
        img.save(pngfile)
        print(pngfile, &#39; is now save ...&#39;)
    ######################
    @staticmethod
    def save_pandas_as_png(df=None, pngfile=&#39;pandas.png&#39;):
        source = ColumnDataSource(df)
        df_columns = [df.index.name]
        df_columns.extend(df.columns.values)
        columns_for_table = []
        for column in df_columns:
            if column is not None:
                columns_for_table.append(TableColumn(field=column, title=column))
                # width_height_default
        data_table = DataTable(source=source, columns=columns_for_table,
                               height_policy=&#34;auto&#34;, width_policy=&#34;auto&#34;, index_position=None)
        export_png(data_table, filename=pngfile)
    ######################
    @staticmethod
    def changeto_nonan_date(df=None, when_end=None, field=None):
        if not isinstance(when_end, dt.date):
            raise CoaTypeError(&#39; Not a valid data ... &#39;)

        boolval = True
        j = 0
        while (boolval):
            boolval = df.loc[df.date == (when_end - dt.timedelta(days=j))][field].dropna().empty
            j += 1
        if j &gt; 1:
            verb(str(when_end) + &#39;: all the value seems to be nan! I will find an other previous date.\n&#39; +
                 &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
        return when_end - dt.timedelta(days=j - 1)
    ######################
    @staticmethod
    def changeto_nonull_date(df=None,when_end = None, field=None):
        if not isinstance(when_end, dt.date):
            raise CoaTypeError(&#39; Not a valid data ... &#39;)
        boolval = True
        j = 0
        #df = df.fillna(0)
        if all(df[field] == 0):
            print(&#39;all value is null for all date !&#39;)
            return when_end
        else:
            while(boolval):
                boolval = all(v == 0. or np.isnan(v) for v in df.loc[df.date == (when_end - dt.timedelta(days=j))][field].values)
                j += 1
            if j &gt; 1:
                verb(str(when_end) + &#39;: all the value seems to be 0! I will find an other previous date.\n&#39; +
                     &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
            return when_end - dt.timedelta(days=j - 1)
    ######################
    @staticmethod
    def get_utcdate(date):
        return (date - dt.date(1970, 1, 1)).total_seconds() * 1000.
    ######################
    @staticmethod
    def test_all_val_null(s):
        a = s.to_numpy()
        return (a == 0).all()
    ######################
    @staticmethod
    def get_polycoords(geopandasrow):
        &#34;&#34;&#34;
        Take a row of a geopandas as an input (i.e : for index, row in geopdwd.iterrows():...)
            and returns a tuple (if the geometry is a Polygon) or a list (if the geometry is a multipolygon)
            of an exterior.coords
        &#34;&#34;&#34;
        geometry = geopandasrow[&#39;geometry&#39;]
        all = []
        if geometry.type == &#39;Polygon&#39;:
            return list(geometry.exterior.coords)
        if geometry.type == &#39;MultiPolygon&#39;:
            for ea in geometry.geoms:
                all.append(list(ea.exterior.coords))
            return all
    ######################
    @staticmethod
    def wgs84_to_web_mercator(tuple_xy):
        &#34;&#34;&#34;
        Take a tuple (longitude,latitude) from a coordinate reference system crs=EPSG:4326
         and converts it to a  longitude/latitude tuple from to Web Mercator format
        &#34;&#34;&#34;
        k = 6378137
        x = tuple_xy[0] * (k * np.pi / 180.0)
        if tuple_xy[1] == -90:
            lat = -89.99
        else:
            lat = tuple_xy[1]
        y = np.log(np.tan((90 + lat) * np.pi / 360.0)) * k
        return x, y
    ######################
    @staticmethod
    def rollerJS():
        return CustomJSHover(code=&#34;&#34;&#34;
                var value;
                 //   if(Math.abs(value)&gt;100000 || Math.abs(value)&lt;0.001)
                 //       return value.toExponential(2);
                 //   else
                 //       return value.toFixed(2);
                 if(value&gt;10000 || value &lt;0.01)
                    value =  Number.parseFloat(value).toExponential(2);
                 else
                     value = Number.parseFloat(value).toFixed(2);
                return value.toString();
                /*  var s = value;
                  var s0=s;
                  var sp1=s.split(&#34;.&#34;);
                  var p1=sp1[0].length
                  if (sp1.length&gt;1) {
                    var sp2=s.split(&#34;e&#34;);
                    var p2=sp2[0].length
                    var p3=p2
                    while(s[p2-1]==&#34;0&#34; &amp;&amp; p2&gt;p1) {
                        p2=p2-1;
                    }
                    s=s0.substring(0,p2)+s0.substring(p3,s0.length);
                  }
                  if (s.split(&#34;.&#34;)[0].length==s.length-1) {
                    s=s.substring(0,s.length-1);
                  }
                  return s;*/
                &#34;&#34;&#34;)
    ######################
    @staticmethod
    def sparkline(data, figsize=(0.5, 0.5), **kwags):
        &#34;&#34;&#34;
        Returns a HTML image tag containing a base64 encoded sparkline style plot
        &#34;&#34;&#34;
        data = list(data)
        fig, ax = plt.subplots(1, 1, figsize=figsize, **kwags)
        ax.patch.set_alpha(0.3)
        ax.plot(data)
        for k,v in ax.spines.items():
            v.set_visible(False)
        ax.set_xticks([])
        ax.set_yticks([])
        plt.plot(len(data) - 1, data[len(data) - 1], &#39;r.&#39;)

        #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
        img = BytesIO()
        plt.savefig(img)
        img.seek(0)
        plt.close()
        return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())
    ###################### END Static Methods ##################
    @staticmethod
    def spiral(data, figsize=(0.5, 0.5), **kwags):
        &#34;&#34;&#34;
        Returns a HTML image tag containing a base64 encoded spiral style plot
        https://github.com/emilienschultz/researchnotebooks/blob/master/20220116%20-%20Visualisation%20polaire%20cas%20COVID-19.ipynb
        &#34;&#34;&#34;
        data[&#34;date&#34;] = pd.to_datetime(data[&#34;date&#34;])
        # Utiliser des méthodes de l&#39;objet date de Pandas pour créer de nouvelles colonnes
        data[&#34;dayofyear&#34;] = data[&#34;date&#34;].dt.dayofyear # j&#39;ai cherché comment faire dayofyear et il se trouve qu&#39;il y a une fonction
        data[&#34;year&#34;] = data[&#34;date&#34;].dt.year

        K = 2*data[&#39;cases&#39;].max()
        data[&#34;dayofyear_angle&#34;] = data[&#34;dayofyear&#34;]*2 * np.pi/365 # gérer plus finement l&#39;année bissextile
        data[&#34;r_baseline&#34;] = data.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)

        E = 8 # facteur d&#39;expansion des données
        data[&#34;r_cas_sup&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] + E*x[&#34;cases&#34;],axis=1)
        data[&#34;r_cas_inf&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] - E*x[&#34;cases&#34;],axis=1)

        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: &#39;polar&#39;},figsize=(1,1))

        #ax.set_xticklabels([&#39;     january&#39;, &#39;&#39;, &#39;april&#39;, &#39;&#39;, &#39;july    &#39;, &#39;&#39;, &#39;october&#39;, &#39;&#39;])
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_baseline&#34;])
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;black&#34;)
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;black&#34;)

        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)

        ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
        ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)
        ax.set_rticks([])
        ax.grid(False)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
        img = BytesIO()
        plt.savefig(img)
        img.seek(0)
        plt.close()
        return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coa.display.CocoDisplay"><code class="flex name class">
<span>class <span class="ident">CocoDisplay</span></span>
<span>(</span><span>db=None, geo=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CocoDisplay:
    def __init__(self, db=None, geo = None):
        verb(&#34;Init of CocoDisplay() with db=&#34; + str(db))
        self.database_name = db
        self.dbld = get_db_list_dict()
        self.lcolors = Category20[20]
        self.scolors = Category10[5]
        self.ax_type = [&#39;linear&#39;, &#39;log&#39;]
        self.geom = []
        self.geopan = gpd.GeoDataFrame()
        self.location_geometry = None
        self.boundary_metropole = None
        self.listfigs = []
        self.options_stats  = [&#39;when&#39;,&#39;input&#39;,&#39;input_field&#39;]
        self.options_charts = [ &#39;bins&#39;]
        self.options_front = [&#39;where&#39;,&#39;option&#39;,&#39;which&#39;,&#39;what&#39;,&#39;visu&#39;]
        self.available_tiles = [&#39;openstreet&#39;,&#39;esri&#39;,&#39;stamen&#39;]
        self.available_modes = [&#39;mouse&#39;,&#39;vline&#39;,&#39;hline&#39;]
        self.uptitle, self.subtitle = &#39; &#39;,&#39; &#39;

        self.dfigure_default = {&#39;plot_height&#39;:width_height_default[1] ,&#39;plot_width&#39;:width_height_default[0],&#39;title&#39;:None,&#39;textcopyright&#39;:&#39;default&#39;}
        self.dvisu_default = {&#39;mode&#39;:&#39;mouse&#39;,&#39;tile&#39;:self.available_tiles[0],&#39;orientation&#39;:&#39;horizontal&#39;,&#39;cursor_date&#39;:None,&#39;maplabel&#39;:None,&#39;guideline&#39;:False}

        self.when_beg = dt.date(1, 1, 1)
        self.when_end = dt.date(1, 1, 1)

        self.alloptions =  self.options_stats + self.options_charts + self.options_front + list(self.dfigure_default.keys()) +\
                           list(self.dvisu_default.keys()) + [&#39;resumetype&#39;]

        self.iso3country = self.dbld[self.database_name][0]
        self.granularity = self.dbld[self.database_name][1]
        self.namecountry = self.dbld[self.database_name][2]
        try:
            if self.granularity != &#39;nation&#39;:
                self.geo = coge.GeoCountry(self.iso3country)
                if self.granularity == &#39;region&#39;:
                    self.location_geometry = self.geo.get_region_list()[[&#39;code_region&#39;, &#39;name_region&#39;, &#39;geometry&#39;]]
                    self.location_geometry = self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                    if self.iso3country == &#39;PRT&#39;:
                         tmp=self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                         tmp = tmp.loc[tmp.code_region==&#39;PT.99&#39;]
                         self.boundary_metropole =tmp[&#39;geometry&#39;].total_bounds
                    if self.iso3country == &#39;FRA&#39;:
                         tmp=self.location_geometry.rename(columns={&#39;name_region&#39;: &#39;location&#39;})
                         tmp = tmp.loc[tmp.code_region==&#39;999&#39;]
                         self.boundary_metropole =tmp[&#39;geometry&#39;].total_bounds
                elif self.granularity == &#39;subregion&#39;:
                    list_dep_metro = None
                    self.location_geometry = self.geo.get_subregion_list()[[&#39;code_subregion&#39;, &#39;name_subregion&#39;, &#39;geometry&#39;]]
                    self.location_geometry = self.location_geometry.rename(columns={&#39;name_subregion&#39;: &#39;location&#39;})
                    #if country == &#39;FRA&#39;:
                    #     list_dep_metro =  geo.get_subregions_from_region(name=&#39;Métropole&#39;)
                    #elif country == &#39;ESP&#39;:
                    #     list_dep_metro =  geo.get_subregions_from_region(name=&#39;España peninsular&#39;)
                    #if list_dep_metro:
                    #    self.boundary_metropole = self.location_geometry.loc[self.location_geometry.code_subregion.isin(list_dep_metro)][&#39;geometry&#39;].total_bounds
            else:
                   self.geo=coge.GeoManager(&#39;name&#39;)
                   geopan = gpd.GeoDataFrame()#crs=&#34;EPSG:4326&#34;)
                   info = coge.GeoInfo()
                   allcountries = self.geo.get_GeoRegion().get_countries_from_region(&#39;world&#39;)
                   geopan[&#39;location&#39;] = [self.geo.to_standard(c)[0] for c in allcountries]
                   geopan = info.add_field(field=[&#39;geometry&#39;],input=geopan ,geofield=&#39;location&#39;)
                   geopan = gpd.GeoDataFrame(geopan, geometry=geopan.geometry, crs=&#34;EPSG:4326&#34;)
                   geopan = geopan[geopan.location != &#39;Antarctica&#39;]
                   geopan = geopan.dropna().reset_index(drop=True)
                   self.location_geometry  = geopan
        except:
            raise CoaTypeError(&#39;What data base are you looking for ?&#39;)

    &#39;&#39;&#39; FIGURE COMMUN FOR ALL &#39;&#39;&#39;
    def standardfig(self, **kwargs):
        &#34;&#34;&#34;
         Create a standard Bokeh figure, with pycoa.fr copyright, used in all the bokeh charts
         &#34;&#34;&#34;
        plot_width = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
        plot_height = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])
        textcopyright = kwargs.get(&#39;textcopyright&#39;, self.dfigure_default[&#39;textcopyright&#39;])

        if textcopyright  == &#39;default&#39;:
                textcopyright = &#39;©pycoa.fr (data from: {})&#39;.format(self.database_name)
        else:
                textcopyright = &#39;©pycoa.fr &#39; + textcopyright

        citation = Label(x=0.65 * plot_width - len(textcopyright), y=0.01 * plot_height,
                                          x_units=&#39;screen&#39;, y_units=&#39;screen&#39;,
                                          text_font_size=&#39;1.5vh&#39;, background_fill_color=&#39;white&#39;, background_fill_alpha=.75,
                                          text=textcopyright)

        for i in list(self.dvisu_default.keys())  + self.options_front + self.options_charts + [&#39;textcopyright&#39;] + self.options_stats + [&#39;date_slider&#39;]:
            if i in kwargs.keys():
                kwargs.pop(i)
        kwargs.pop(&#39;title&#39;)
        fig = figure(**kwargs, tools=[&#39;save&#39;, &#39;box_zoom,reset&#39;], toolbar_location=&#34;right&#34;)
        #fig.add_layout(citation)
        fig.add_layout(Title(text=self.uptitle, text_font_size=&#34;10pt&#34;), &#39;above&#39;)
        fig.add_layout(Title(text=self.subtitle, text_font_size=&#34;8pt&#34;, text_font_style=&#34;italic&#34;), &#39;below&#39;)
        return fig

    def get_listfigures(self):
        return  self.listfigs
    def set_listfigures(self,fig):
            if not isinstance(fig,list):
                fig = [fig]
            self.listfigs = fig
    &#39;&#39;&#39; WRAPPER COMMUN FOR ALL&#39;&#39;&#39;
    def decowrapper(func):
        &#39;&#39;&#39;
            Main decorator it mainly deals with arg testings
        &#39;&#39;&#39;
        @wraps(func)
        def wrapper(self, input = None, input_field = None, **kwargs):
            &#34;&#34;&#34;
            Parse a standard input, return :
                - pandas: with location keyword (eventually force a column named &#39;where&#39; to &#39;location&#39;)
                - kwargs:
                    * keys = [plot_width, plot_width, title, when, title_temporal,bins, what, which]
            Note that method used only the needed variables, some of them are useless
            &#34;&#34;&#34;
            if not isinstance(input, pd.DataFrame):
                raise CoaTypeError(input + &#39;Must be a pandas, with pycoa structure !&#39;)

            kwargs_test(kwargs, self.alloptions, &#39;Bad args used in the display function.&#39;)
            when = kwargs.get(&#39;when&#39;, None)
            which = kwargs.get(&#39;which&#39;, input.columns[2])
            if input_field and &#39;cur_&#39; in input_field:
                what =  which
            else:
                 # cumul is the default
                what = kwargs.get(&#39;what&#39;, which)

            if input_field is None:
                input_field = which

            if isinstance(input_field,list):
                test = input_field[0]
            else:
                test = input_field
            if input[[test,&#39;date&#39;]].isnull().values.all():
                raise CoaKeyError(&#39;All values for &#39;+ which + &#39; is nan nor empty&#39;)

            option = kwargs.get(&#39;option&#39;, None)
            bins = kwargs.get(&#39;bins&#39;, 10)
            title = kwargs.get(&#39;title&#39;, None)
            #textcopyright = kwargs.get(&#39;textcopyright&#39;, &#39;default&#39;)
            kwargs[&#39;plot_width&#39;] = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
            kwargs[&#39;plot_height&#39;] = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])

            if &#39;where&#39; in input.columns:
                input = input.rename(columns={&#39;where&#39;: &#39;location&#39;})

            if &#39;codelocation&#39; and &#39;clustername&#39; not in input.columns:
                input[&#39;codelocation&#39;] = input[&#39;location&#39;]
                input[&#39;clustername&#39;] = input[&#39;location&#39;]
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]
                input[&#39;permanentdisplay&#39;] = input[&#39;location&#39;]
            else:
                if self.granularity == &#39;nation&#39; :
                    #input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;) if len(x)&lt; 10 else x[0]+&#39;...&#39;+x[-1] )
                    input[&#39;permanentdisplay&#39;] = input.apply(lambda x: x.clustername if self.geo.get_GeoRegion().is_region(x.clustername) else str(x.codelocation), axis = 1)
                else:
                    if self.granularity == &#39;subregion&#39; :
                        input = input.reset_index(drop=True)
                        if isinstance(input[&#39;codelocation&#39;][0],list):
                            input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#34;&#39;&#34;, &#39;&#39;)\
                                                         if len(x)&lt;5 else &#39;[&#39;+str(x[0]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;,...,&#39;+str(x[-1]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;]&#39;)

                        trad={}
                        cluster = input.clustername.unique()
                        if isinstance(input.location[0],list):
                           cluster = [i for i in cluster]
                        for i in cluster:
                            if i == self.namecountry:
                                input[&#39;permanentdisplay&#39;] = input.clustername #[self.dbld[self.database_name][2]]*len(input)
                            else:
                                if self.geo.is_region(i):
                                    trad[i] = self.geo.is_region(i)
                                elif self.geo.is_subregion(i):
                                    trad[i] = self.geo.is_subregion(i)#input.loc[input.clustername==i][&#39;codelocation&#39;].iloc[0]
                                else:
                                    trad[i] = i
                                trad={k:(v[:3]+&#39;...&#39;+v[-3:] if len(v)&gt;8 else v) for k,v in trad.items()}
                                if &#39;,&#39; in input.codelocation[0]:
                                    input[&#39;permanentdisplay&#39;] = input.clustername
                                else:
                                    input[&#39;permanentdisplay&#39;] = input.codelocation#input.clustername.map(trad)
                    elif self.granularity == &#39;region&#39; :
                        if all(i == self.namecountry for i in input.clustername.unique()):
                            input[&#39;permanentdisplay&#39;] = [self.namecountry]*len(input)
                        else:
                            input[&#39;permanentdisplay&#39;] = input.codelocation
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

            maplabel = kwargs.get(&#39;maplabel&#39;, None)
            if maplabel and &#39;unsorted&#39; in maplabel:
                pass
            else:
                input = input.sort_values(by=input_field, ascending = False).reset_index(drop=True)

            uniqloc = input.clustername.unique()

            if len(uniqloc) &lt; 5:
                colors = self.scolors
            else:
                colors = self.lcolors
            colors = itertools.cycle(colors)
            dico_colors = {i: next(colors) for i in uniqloc}

            input = input.copy()
            if not &#39;colors&#39; in input.columns:
                input.loc[:,&#39;colors&#39;] = input[&#39;clustername&#39;].map(dico_colors)#(pd.merge(input, country_col, on=&#39;location&#39;))

            if not isinstance(input_field, list):
                  input_field = [input_field]
            else:
                  input_field = input_field
            col2=which
            when_beg = input[[col2,&#39;date&#39;]].date.min()
            when_end = input[[col2,&#39;date&#39;]].date.max()

            if when:
                when_beg, when_end = extract_dates(when)
                if when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                    when_end = input[[col2,&#39;date&#39;]].date.max()

                if when_beg == dt.date(1, 1, 1):
                    when_beg = input[[col2,&#39;date&#39;]].date.min()

                if not isinstance(when_beg, dt.date):
                    raise CoaNoData(&#34;With your current cuts, there are no data to plot.&#34;)

                if when_end &lt;= when_beg:
                    print(&#39;Requested date below available one, take&#39;, when_beg)
                    when_end = when_beg
                if when_beg &gt; input[[col2,&#39;date&#39;]].date.max() or when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                    raise CoaNoData(&#34;No available data after &#34;+str(input[[input_field[0],&#39;date&#39;]].date.max()))
            when_end_change = when_end

            for i in input_field:
                if input[i].isnull().all():
                    raise CoaTypeError(&#34;Sorry all data are NaN for &#34; + i)
                else:
                    when_end_change = min(when_end_change,CocoDisplay.changeto_nonull_date(input, when_end, i))

            if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
                if len(input_field) &gt; 1:
                    print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
                input_field = input_field[0]

            if when_end_change != when_end:
                when_end = when_end_change

            self.when_beg = when_beg
            self.when_end = when_end
            input = input.loc[(input[&#39;date&#39;] &gt;=  self.when_beg) &amp; (input[&#39;date&#39;] &lt;=  self.when_end)]

            title_temporal = &#39; (&#39; + &#39;between &#39; + when_beg.strftime(&#39;%d/%m/%Y&#39;) + &#39; and &#39; + when_end.strftime(&#39;%d/%m/%Y&#39;) + &#39;)&#39;
            if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
                title_temporal = &#39; (&#39; + when_end.strftime(&#39;%d/%m/%Y&#39;)  + &#39;)&#39;
            title_option=&#39;&#39;
            if option:
                if &#39;sumallandsmooth7&#39; in option:
                    option.remove(&#39;sumallandsmooth7&#39;)
                    option += [&#39;sumall&#39;,&#39;smooth7&#39;]
                title_option = &#39; (option: &#39; + str(option)+&#39;)&#39;

            input_field_tostring = str(input_field).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;).replace(&#39;\&#39;&#39;, &#39;&#39;)
            whichtitle = which
            if &#39;pop&#39; in input_field_tostring:
                whichtitle = input_field_tostring.replace(&#39;weekly &#39;,&#39;&#39;).replace(&#39;daily &#39;,&#39;&#39;)

            if &#39;daily&#39; in input_field_tostring:
                titlefig = whichtitle + &#39;, &#39; + &#39;day to day difference&#39; + title_option
            elif &#39;weekly&#39; in input_field_tostring:
                titlefig = whichtitle + &#39;, &#39; + &#39;week to week difference&#39; + title_option
            else:
                if &#39;cur_&#39; in  which or &#39;idx_&#39; in  which:
                    #titlefig = which + &#39;, &#39; + &#39;current &#39; + which.replace(&#39;cur_&#39;,&#39;&#39;).replace(&#39;idx_&#39;,&#39;&#39;)+ title_option
                    titlefig = whichtitle + &#39;, current value&#39; + title_option
                else:
                    titlefig = whichtitle + &#39;, cumulative&#39;+ title_option

            if title:
                title = title
            else:
                title  = titlefig
            self.uptitle = title

            textcopyright = kwargs.get(&#39;textcopyright&#39;, None)
            if textcopyright:
                textcopyright = &#39;©pycoa.fr &#39; + textcopyright + title_temporal
                kwargs.pop(&#39;textcopyright&#39;)
            else:
                textcopyright = &#39;©pycoa.fr data from: {}&#39;.format(self.database_name)+&#39; &#39;+title_temporal

            self.subtitle = textcopyright
            kwargs[&#39;title&#39;] = title+title_temporal
            return func(self, input, input_field, **kwargs)
        return wrapper

    @decowrapper
    def pycoa_resume_data(self, input, input_field, **kwargs):
        loc=list(input[&#39;clustername&#39;].unique())
        input[&#39;cases&#39;] = input[input_field]
        resumetype = kwargs.get(&#39;resumetype&#39;,&#39;spiral&#39;)
        if resumetype == &#39;spiral&#39;:
            dspiral={i:CocoDisplay.spiral(input.loc[ (input.clustername==i) &amp;
                        (input.date &gt;= self.when_beg) &amp;
                        (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
            input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(dspiral)
        elif resumetype == &#39;spark&#39;:
            spark={i:CocoDisplay.sparkline(input.loc[ (input.clustername==i) &amp;
                        (input.date &gt;= self.when_beg) &amp;
                        (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
            input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(spark)
        else:
            raise CoaError(&#39;pycoa_resume_data can use spiral or spark ... here what ?&#39;)
        input = input.loc[input.date==input.date.max()].reset_index(drop=True)
        def path_to_image_html(path):
            return &#39;&lt;img src=&#34;&#39;+ path + &#39;&#34; width=&#34;60&#34; &gt;&#39;

        input=input.drop(columns=[&#39;permanentdisplay&#39;,&#39;rolloverdisplay&#39;,&#39;colors&#39;,&#39;cases&#39;])
        input=input.apply(lambda x: x.round(2) if x.name in [input_field,&#39;daily&#39;,&#39;weekly&#39;] else x)
        if isinstance(input[&#39;location&#39;][0], list):
            col=[i for i in list(input.columns) if i not in [&#39;clustername&#39;,&#39;location&#39;,&#39;codelocation&#39;]]
            col.insert(0,&#39;clustername&#39;)
            input = input[col]
            input=input.set_index(&#39;clustername&#39;)
        else:
           input = input.drop(columns=&#39;clustername&#39;)
           input=input.set_index(&#39;location&#39;)

        return input.to_html(escape=False,formatters=dict(resume=path_to_image_html))

    &#39;&#39;&#39; DECORATORS FOR PLOT: DATE, VERSUS, SCROLLINGMENU &#39;&#39;&#39;
    def decoplot(func):
        &#34;&#34;&#34;
        decorator for plot purpose
        &#34;&#34;&#34;
        @wraps(func)
        def inner_plot(self, input = None, input_field = None, **kwargs):
            mode = kwargs.get(&#39;mode&#39;, None)
            if mode:
                mode = mode
            else:
                mode = self.dvisu_default[&#39;mode&#39;]
            if mode not in self.available_modes:
                raise CoaTypeError(&#39;Don\&#39;t know the mode wanted. So far:&#39; + str(self.available_modes))
            kwargs[&#39;mode&#39;] = mode

            if &#39;location&#39; in input.columns:
                location_ordered_byvalues = list(
                    input.loc[input.date == self.when_end].sort_values(by=input_field, ascending=False)[&#39;clustername&#39;].unique())
                input = input.copy()  # needed to avoid warning
                input.loc[:,&#39;clustername&#39;] = pd.Categorical(input.clustername,
                                                       categories=location_ordered_byvalues, ordered=True)

                input = input.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;]).reset_index(drop = True)

                if func.__name__ != &#39;pycoa_scrollingmenu&#39; :
                    if len(location_ordered_byvalues) &gt;= MAXCOUNTRIESDISPLAYED:
                        input = input.loc[input.clustername.isin(location_ordered_byvalues[:MAXCOUNTRIESDISPLAYED])]
                list_max = []
                for i in input_field:
                    list_max.append(max(input.loc[input.clustername.isin(location_ordered_byvalues)][i]))
                if len([x for x in list_max if not np.isnan(x)]) &gt; 0:
                    amplitude = (np.nanmax(list_max) - np.nanmin(list_max))
                    if amplitude &gt; 10 ** 4:
                        self.ax_type.reverse()
                if func.__name__ == &#39;pycoa_scrollingmenu&#39; :
                    if isinstance(input_field,list):
                        if len(input_field) &gt; 1:
                            print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
                        input_field = input_field[0]
                    if self.dbld[self.database_name][1] == &#39;nation&#39; and self.dbld[self.database_name][0] != &#39;WW&#39;:
                        func.__name__ = &#39;pycoa_date_plot&#39;
            return func(self, input, input_field, **kwargs)
        return inner_plot

    &#39;&#39;&#39; PLOT VERSUS &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_plot(self, input = None, input_field = None ,**kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a versus plot according to arguments.
        See help(pycoa_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element. It should be a list dim=2. Moreover the 2 variables must be present
        in the DataFrame considered.
        - plot_heigh = width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        if len(input_field) != 2:
            raise CoaTypeError(&#39;Two variables are needed to plot a versus chart ... &#39;)
        panels = []
        cases_custom = CocoDisplay.rollerJS()
        if self.get_listfigures():
            self.set_listfigures([])
        listfigs=[]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( x_axis_label = input_field[0], y_axis_label = input_field[1],
                                                y_axis_type = axis_type, **kwargs )

            standardfig.add_tools(HoverTool(
                tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;),
                          (input_field[0], &#39;@{casesx}&#39; + &#39;{custom}&#39;),
                          (input_field[1], &#39;@{casesy}&#39; + &#39;{custom}&#39;)],
                formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{casesx}&#39;: cases_custom, &#39;@{casesy}&#39;: cases_custom,
                            &#39;@date&#39;: &#39;datetime&#39;}, mode = kwargs[&#39;mode&#39;],
                point_policy=&#34;snap_to_data&#34;))  # ,PanTool())

            for loc in input.clustername.unique():
                pandaloc = input.loc[input.clustername == loc].sort_values(by=&#39;date&#39;, ascending=&#39;True&#39;)
                pandaloc.rename(columns={input_field[0]: &#39;casesx&#39;, input_field[1]: &#39;casesy&#39;}, inplace=True)
                standardfig.line(x=&#39;casesx&#39;, y=&#39;casesy&#39;,
                                 source=ColumnDataSource(pandaloc), legend_label=pandaloc.clustername.iloc[0],
                                 color=pandaloc.colors.iloc[0], line_width=3, hover_line_width=4)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title=axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            listfigs.append(standardfig)
            CocoDisplay.bokeh_legend(standardfig)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs=panels)
        return tabs

    &#39;&#39;&#39; DATE PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_date_plot(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot according to arguments. See help(pycoa_date_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        panels = []
        listfigs = []
        cases_custom = CocoDisplay.rollerJS()
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;,**kwargs)
            i = 0
            r_list=[]
            maxou=-1000
            lcolors = iter(self.lcolors)
            line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;,&#39;dashdot&#39;]
            for val in input_field:
                for loc in list(input.clustername.unique()):
                    input_filter = input.loc[input.clustername == loc].reset_index(drop = True)

                    src = ColumnDataSource(input_filter)
                    leg = input_filter.clustername[0]
                    #leg = input_filter.permanentdisplay[0]
                    if len(input_field)&gt;1:
                        leg = input_filter.permanentdisplay[0] + &#39;, &#39; + val
                    if len(list(input.clustername.unique())) == 1:
                        color = next(lcolors)
                    else:
                        color = input_filter.colors[0]
                    r = standardfig.line(x = &#39;date&#39;, y = val, source = src,
                                     color = color, line_width = 3,
                                     legend_label = leg,
                                     hover_line_width = 4, name = val, line_dash=line_style[i%4])
                    r_list.append(r)
                    maxou=max(maxou,np.nanmax(input_filter[val].values))
                i += 1
            for r in r_list:
                label = r.name
                tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
                formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
                hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
                standardfig.add_tools(hover)
                if guideline:
                    cross= CrosshairTool()
                    standardfig.add_tools(cross)

            if axis_type == &#39;linear&#39;:
                if maxou  &lt; 1e4 :
                    standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title = axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            standardfig.legend.click_policy=&#34;hide&#34;
            standardfig.legend.label_text_font_size = &#39;8pt&#39;
            if len(input_field) &gt; 1 and len(input_field)*len(input.clustername.unique())&gt;16:
                standardfig.legend.visible=False
            standardfig.xaxis.formatter = DatetimeTickFormatter(
                days = [&#34;%d/%m/%y&#34;], months = [&#34;%d/%m/%y&#34;], years = [&#34;%b %Y&#34;])
            CocoDisplay.bokeh_legend(standardfig)
            listfigs.append(standardfig)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs = panels)
        return tabs

    &#39;&#39;&#39; SPIRAL PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_spiral_plot(self, input = None, input_field = None, **kwargs):
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        panels = []
        listfigs = []
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        borne=300
        kwargs.pop(&#39;plot_width&#39;)
        standardfig = self.standardfig(y_axis_type = None, x_axis_type = None,
        width=kwargs[&#39;plot_height&#39;], x_range=[-borne, borne], y_range=[-borne, borne], match_aspect=True,**kwargs)

        if len(input.clustername.unique()) &gt; 1 :
            print(&#39;Can only display spiral for ONE location. I took the first one:&#39;, input.clustername[0])
            input = input.loc[input.clustername == input.clustername[0]].copy()
        input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
        input[&#34;dayofyear&#34;]=input.date.dt.dayofyear
        input[&#39;year&#39;]=input.date.dt.year
        input[&#39;cases&#39;] = input[input_field]

        K = 2*input[input_field].max()
        #drop bissextile fine tuning in needed in the future
        input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
        input[&#34;dayofyear_angle&#34;] = input[&#34;dayofyear&#34;]*2 * np.pi/365
        input[&#34;r_baseline&#34;] = input.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)
        size_factor = 16
        input[&#34;r_cas_sup&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] + 0.5*x[input_field]*size_factor,axis=1)
        input[&#34;r_cas_inf&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] - 0.5*x[input_field]*size_factor,axis=1)

        radius = 200
        def polar(theta,r,norm=radius/input[&#34;r_baseline&#34;].max()):
            x = norm*r*np.cos(theta)
            y = norm*r*np.sin(theta)
            return x,y
        x_base,y_base=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_baseline&#34;])
        x_cas_sup,y_cas_sup=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_sup&#34;])
        x_cas_inf,y_cas_inf=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_inf&#34;])

        xcol,ycol=[],[]
        [ xcol.append([i,j]) for i,j in zip(x_cas_inf,x_cas_sup)]
        [ ycol.append([i,j]) for i,j in zip(y_cas_inf,y_cas_sup)]
        standardfig.patches(xcol,ycol,color=&#39;blue&#39;,fill_alpha = 0.5)

        src = ColumnDataSource(data=dict(
        x=x_base,
        y=y_base,
        date=input[&#39;date&#39;],
        cases=input[&#39;cases&#39;]
        ))
        standardfig.line( x = &#39;x&#39;, y = &#39;y&#39;, source = src, legend_label = input.clustername[0],
                        line_width = 3, line_color = &#39;blue&#39;)
        circle = standardfig.circle(&#39;x&#39;, &#39;y&#39;, size=2, source=src)

        cases_custom = CocoDisplay.rollerJS()
        hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                               formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;},
                               renderers=[circle],
                               point_policy=&#34;snap_to_data&#34;)
        standardfig.add_tools(hover_tool)

        outer_radius=250
        [standardfig.annular_wedge(
            x=0, y=0, inner_radius=0, outer_radius=outer_radius, start_angle=i*np.pi/6,\
            end_angle=(i+1)*np.pi/6,fill_color=None,line_color=&#39;black&#39;,line_dash=&#39;dotted&#39;)
        for i in range(12)]

        label = [&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;,&#39;May&#39;,&#39;June&#39;,&#39;July&#39;,&#39;August&#39;,&#39;September&#39;,&#39;October&#39;,&#39;November&#39;,&#39;December&#39;]
        xr,yr = polar(np.linspace(0, 2 * np.pi, 13),outer_radius,1)
        standardfig.text(xr[:-1], yr[:-1], label,text_font_size=&#34;9pt&#34;, text_align=&#34;center&#34;, text_baseline=&#34;middle&#34;)

        standardfig.legend.background_fill_alpha = 0.6
        standardfig.legend.location = &#34;top_left&#34;
        standardfig.legend.click_policy=&#34;hide&#34;
        return standardfig

    &#39;&#39;&#39; SCROLLINGMENU PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_scrollingmenu(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot, with a scrolling menu location, according to arguments.
        See help(pycoa_scrollingmenu).
        Keyword arguments
        -----------------
        len(location) &gt; 2
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        -guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        mode = kwargs.get(&#39;mode&#39;,self.dvisu_default[&#39;mode&#39;])
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])

        uniqloc = input.clustername.unique().to_list()
        uniqloc.sort()
        if &#39;location&#39; in input.columns:
            if len(uniqloc) &lt; 2:
                raise CoaTypeError(&#39;What do you want me to do ? You have selected, only one country.&#39;
                                   &#39;There is no sens to use this method. See help.&#39;)
        input = input[[&#39;date&#39;, &#39;clustername&#39;, input_field]]
        input = input.sort_values(by=&#39;clustername&#39;, ascending = True).reset_index(drop=True)

        mypivot = pd.pivot_table(input, index=&#39;date&#39;, columns=&#39;clustername&#39;, values=input_field)
        column_order = uniqloc
        mypivot = mypivot.reindex(column_order, axis=1)
        source = ColumnDataSource(mypivot)

        filter_data1 = mypivot[[uniqloc[0]]].rename(columns={uniqloc[0]: &#39;cases&#39;})
        src1 = ColumnDataSource(filter_data1)

        filter_data2 = mypivot[[uniqloc[1]]].rename(columns={uniqloc[1]: &#39;cases&#39;})
        src2 = ColumnDataSource(filter_data2)

        cases_custom = CocoDisplay.rollerJS()
        hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                               formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;}, mode = mode,
                               point_policy=&#34;snap_to_data&#34;)  # ,PanTool())

        panels = []
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;, **kwargs)

            standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)

            standardfig.add_tools(hover_tool)
            if guideline:
                cross= CrosshairTool()
                standardfig.add_tools(cross)
            def add_line(src, options, init, color):
                s = Select(options = options, value = init)
                r = standardfig.line(x = &#39;date&#39;, y = &#39;cases&#39;, source = src, line_width = 3, line_color = color)
                li = LegendItem(label = init, renderers = [r])
                s.js_on_change(&#39;value&#39;, CustomJS(args=dict(s0=source, s1=src, li=li),
                                                 code=&#34;&#34;&#34;
                                            var c = cb_obj.value;
                                            var y = s0.data[c];
                                            s1.data[&#39;cases&#39;] = y;
                                            li.label = {value: cb_obj.value};
                                            s1.change.emit();
                                     &#34;&#34;&#34;))
                return s, li

            s1, li1 = add_line(src1, uniqloc, uniqloc[0], self.scolors[0])
            s2, li2 = add_line(src2, uniqloc, uniqloc[1], self.scolors[1])
            standardfig.add_layout(Legend(items = [li1, li2]))
            standardfig.legend.location = &#39;top_left&#39;
            layout = row(column(row(s1, s2), row(standardfig)))
            panel = Panel(child = layout, title = axis_type)
            panels.append(panel)

        tabs = Tabs(tabs = panels)
        label = standardfig.title
        return tabs

    &#39;&#39;&#39; YEARLY PLOT &#39;&#39;&#39;
    @decowrapper
    @decoplot
    def pycoa_yearly_plot(self, input = None, input_field = None, **kwargs):
        &#39;&#39;&#39;
        -----------------
        Create a date plot according to arguments. See help(pycoa_date_plot).
        Keyword arguments
        -----------------
        - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - guideline = False
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
        if len(input.clustername.unique()) &gt; 1 :
            print(&#39;Can only display yearly plot for ONE location. I took the first one:&#39;, input.clustername[0])
        input = input.loc[input.clustername == input.clustername[0]].copy()

        panels = []
        listfigs = []
        cases_custom = CocoDisplay.rollerJS()
        input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
        #drop bissextile fine tuning in needed in the future
        input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
        input = input.copy()
        input.loc[:,&#39;allyears&#39;]=input[&#39;date&#39;].apply(lambda x : x.year)
        input[&#39;allyears&#39;] = input[&#39;allyears&#39;].astype(int)
        input.loc[:,&#39;dayofyear&#39;]= input[&#39;date&#39;].apply(lambda x : x.dayofyear)
        allyears = list(input.allyears.unique())
        if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
        if len(input_field)&gt;1:
            CoaError(&#39;Only one variable could be displayed&#39;)
        else:
            input_field=input_field[0]
        for axis_type in self.ax_type:
            standardfig = self.standardfig( y_axis_type = axis_type,**kwargs)
            i = 0
            r_list=[]
            maxou=-1000
            input[&#39;cases&#39;]=input[input_field]
            line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;]
            colors = itertools.cycle(self.lcolors)
            for loc in list(input.clustername.unique()):
                for year in allyears:
                    input_filter = input.loc[(input.clustername == loc) &amp; (input[&#39;date&#39;].dt.year.eq(year))].reset_index(drop = True)
                    src = ColumnDataSource(input_filter)
                    leg = loc + &#39; &#39; + str(year)
                    r = standardfig.line(x = &#39;dayofyear&#39;, y = input_field, source = src,
                                     color = next(colors), line_width = 3,
                                     legend_label = leg,
                                     hover_line_width = 4, name = input_field)
                    maxou=max(maxou,np.nanmax(input_filter[input_field].values))

            label = input_field
            tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;)]
            formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
            hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;])  # ,PanTool())
            standardfig.add_tools(hover)
            if guideline:
                cross= CrosshairTool()
                standardfig.add_tools(cross)

            if axis_type == &#39;linear&#39;:
                if maxou  &lt; 1e4 :
                    standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

            standardfig.legend.label_text_font_size = &#34;12px&#34;
            panel = Panel(child=standardfig, title = axis_type)
            panels.append(panel)
            standardfig.legend.background_fill_alpha = 0.6

            standardfig.legend.location = &#34;top_left&#34;
            standardfig.legend.click_policy=&#34;hide&#34;

            labelspd=input.loc[(input.allyears.eq(2021)) &amp; (input.date.dt.day.eq(1))]
            standardfig.xaxis.ticker = list(labelspd[&#39;dayofyear&#39;].astype(int))
            replacelabelspd =  labelspd[&#39;date&#39;].apply(lambda x: str(x.strftime(&#34;%b&#34;)))
            #label_dict = dict(zip(input.loc[input.allyears.eq(2020)][&#39;daymonth&#39;],input.loc[input.allyears.eq(2020)][&#39;date&#39;].apply(lambda x: str(x.day)+&#39;/&#39;+str(x.month))))
            standardfig.xaxis.major_label_overrides = dict(zip(list(labelspd[&#39;dayofyear&#39;].astype(int)),list(replacelabelspd)))

            CocoDisplay.bokeh_legend(standardfig)
            listfigs.append(standardfig)

        tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
        formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
        hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
        standardfig.add_tools(hover)
        if guideline:
            cross= CrosshairTool()
            standardfig.add_tools(cross)
        self.set_listfigures(listfigs)
        tabs = Tabs(tabs = panels)
        return tabs

    &#39;&#39;&#39; DECORATORS FOR HISTO VERTICAL, HISTO HORIZONTAL, PIE &amp; MAP&#39;&#39;&#39;
    def decohistomap(func):
        &#34;&#34;&#34;
        Decorator function used for histogram and map
        &#34;&#34;&#34;
        @wraps(func)
        def inner_hm(self, input = None, input_field = None, **kwargs):
            tile = kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])

            maplabel = kwargs.get(&#39;maplabel&#39;, None)
            if not isinstance(maplabel,list):
                    maplabel=[maplabel]
            #if maplabel:
            #    maplabel = maplabel

            if &#39;map&#39; in func.__name__:
                kwargs[&#39;maplabel&#39;] = maplabel

            orientation = kwargs.get(&#39;orientation&#39;, self.dvisu_default[&#39;orientation&#39;])
            cursor_date = kwargs.get(&#39;cursor_date&#39;, None)
            #if orientation:
            #    kwargs[&#39;orientation&#39;] = orientation
            #kwargs[&#39;cursor_date&#39;] = kwargs.get(&#39;cursor_date&#39;,  self.dvisu_default[&#39;cursor_date&#39;])
            if isinstance(input[&#39;location&#39;].iloc[0],list):
                input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
                input = input.explode(&#39;location&#39;)
            else:
                input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

            uniqloc = input.clustername.unique()

            geopdwd = input
            if maplabel and &#39;unsorted&#39; in maplabel:
                pass
            else:
                geopdwd = geopdwd.sort_values(by=input_field, ascending = False).reset_index(drop=True)

            started = geopdwd.date.min()
            ended = geopdwd.date.max()
            if cursor_date:
                date_slider = DateSlider(title = &#34;Date: &#34;, start = started, end = ended,
                                     value = ended, step=24 * 60 * 60 * 1000, orientation = orientation)
                #wanted_date = date_slider.value_as_datetime.date()

            #if func.__name__ == &#39;pycoa_mapfolium&#39; or func.__name__ == &#39;pycoa_map&#39; or func.__name__ == &#39;innerdecomap&#39; or func.__name__ == &#39;innerdecopycoageo&#39;:
            if func.__name__ in [&#39;pycoa_mapfolium&#39;,&#39;pycoa_map&#39;,&#39;pycoageo&#39; ,&#39;pycoa_pimpmap&#39;]:
                if isinstance(input.location.to_list()[0],list):
                    geom = self.location_geometry
                    geodic={loc:geom.loc[geom.location==loc][&#39;geometry&#39;].values[0] for loc in geopdwd.location.unique()}
                    geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(geodic)
                else:
                    geopdwd = pd.merge(geopdwd, self.location_geometry, on=&#39;location&#39;)

                kwargs[&#39;tile&#39;] = tile
                if self.iso3country in [&#39;USA&#39;]:#[&#39;FRA&#39;,&#39;USA&#39;]
                    geo = copy.deepcopy(self.geo)
                    d = geo._list_translation
                    if func.__name__ != &#39;pycoa_mapfolium&#39;:
                        if any(i in list(geopdwd.codelocation.unique()) for i in d.keys()) \
                        or any(True for i in d.keys() if &#39;&#39;.join(list(geopdwd.codelocation.unique())).find(i)!=-1):
                            geo.set_dense_geometry()
                            kwargs.pop(&#39;tile&#39;)
                        else:
                            geo.set_main_geometry()
                            d = {}
                        new_geo = geo.get_data()[[&#39;name_&#39;+self.granularity,&#39;geometry&#39;]]
                        new_geo = new_geo.rename(columns={&#39;name_&#39;+self.granularity:&#39;location&#39;})
                        new_geo = new_geo.set_index(&#39;location&#39;)[&#39;geometry&#39;].to_dict()

                        geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(new_geo)
                geopdwd = gpd.GeoDataFrame(geopdwd, geometry=geopdwd.geometry, crs=&#34;EPSG:4326&#34;)

            if func.__name__ == &#39;pycoa_histo&#39;:
                pos = {}
                new = pd.DataFrame()
                n = 0
                for i in uniqloc:
                    perloc = geopdwd.loc[geopdwd.clustername == i]
                    if all(perloc != 0):
                        pos = perloc.index[0]
                        if new.empty:
                            new = perloc
                        else:
                            new = new.append(perloc)
                        n += 1
                geopdwd = new.reset_index(drop=True)
            if cursor_date:
                date_slider = date_slider
            else:
                date_slider = None
            kwargs[&#39;date_slider&#39;] = date_slider
            return func(self, geopdwd, input_field, **kwargs)
        return inner_hm

    &#39;&#39;&#39; VERTICAL HISTO &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    def pycoa_histo(self,  geopdwd, input_field = None, **kwargs):
        &#39;&#39;&#39;
            -----------------
            Create 1D histogramme by value according to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - geopdwd : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filter = geopdwd_filter.reset_index(drop = True)

        input = geopdwd_filter.rename(columns = {&#39;cases&#39;: input_field})
        bins = kwargs.get(&#39;bins&#39;, None)

        if &#39;location&#39; in input.columns:
            uniqloc = list(input.clustername.unique())
            allval  = input.loc[input.clustername.isin(uniqloc)][[&#39;clustername&#39;, input_field,&#39;permanentdisplay&#39;]]
            min_val = allval[input_field].min()
            max_val = allval[input_field].max()

            if bins:
                bins = bins
            else:
                if len(uniqloc) == 1:
                    bins = 2
                    min_val = 0.
                else:
                    bins = 11

            delta = (max_val - min_val ) / bins
            interval = [ min_val + i*delta for i in range(bins+1)]

            contributors = {  i : [] for i in range(bins+1)}
            for i in range(len(allval)):
                rank = bisect.bisect_left(interval, allval.iloc[i][input_field])
                if rank == bins+1:
                    rank = bins
                contributors[rank].append(allval.iloc[i][&#39;clustername&#39;])

            colors = itertools.cycle(self.lcolors)
            lcolors = [next(colors) for i in range(bins+1)]
            contributors = dict(sorted(contributors.items()))
            frame_histo = pd.DataFrame({
                              &#39;left&#39;: [0]+interval[:-1],
                              &#39;right&#39;:interval,
                              &#39;middle_bin&#39;: [format((i+j)/2, &#34;.1f&#34;) for i,j in zip([0]+interval[:-1],interval)],
                              &#39;top&#39;: [len(i) for i in list(contributors.values())],
                              &#39;contributors&#39;: [&#39;, &#39;.join(i) for i in contributors.values()],
                              &#39;colors&#39;: lcolors})
        #tooltips = &#34;&#34;&#34;
        #&lt;div style=&#34;width: 400px&#34;&gt;
        #&lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
        #&lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
        #&lt;/div&gt;
        #&#34;&#34;&#34;
        tooltips = &#34;&#34;&#34;
        &lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
        &lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
        &#34;&#34;&#34;
        hover_tool = HoverTool(tooltips = tooltips)
        panels = []
        bottom = 0
        x_axis_type, y_axis_type, axis_type_title = 3 * [&#39;linear&#39;]
        for axis_type in [&#34;linear&#34;, &#34;linlog&#34;, &#34;loglin&#34;, &#34;loglog&#34;]:
            if axis_type == &#39;linlog&#39;:
                y_axis_type, axis_type_title = &#39;log&#39;, &#39;logy&#39;
            if axis_type == &#39;loglin&#39;:
                x_axis_type, y_axis_type, axis_type_title = &#39;log&#39;, &#39;linear&#39;, &#39;logx&#39;
            if axis_type == &#39;loglog&#39;:
                x_axis_type, y_axis_type = &#39;log&#39;, &#39;log&#39;
                axis_type_title = &#39;loglog&#39;

            standardfig = self.standardfig(x_axis_type=x_axis_type, y_axis_type=y_axis_type, **kwargs)

            standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)
            standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
            standardfig.add_tools(hover_tool)
            standardfig.x_range = Range1d(1.05 * interval[0], 1.05 * interval[-1])
            standardfig.y_range = Range1d(0, 1.05 * frame_histo[&#39;top&#39;].max())
            if x_axis_type == &#34;log&#34;:
                left = 0.8
                if frame_histo[&#39;left&#39;][0] &lt;= 0:
                    frame_histo.at[0, &#39;left&#39;] = left
                else:
                    left  = frame_histo[&#39;left&#39;][0]
                standardfig.x_range = Range1d(left, 10 * interval[-1])

            if y_axis_type == &#34;log&#34;:
                bottom = 0.0001
                standardfig.y_range = Range1d(0.001, 10 * frame_histo[&#39;top&#39;].max())

            standardfig.quad(source=ColumnDataSource(frame_histo), top=&#39;top&#39;, bottom=bottom, left=&#39;left&#39;, \
                             right=&#39;right&#39;, fill_color=&#39;colors&#39;)
            panel = Panel(child=standardfig, title=axis_type_title)
            panels.append(panel)
        tabs = Tabs(tabs=panels)
        return tabs

    &#39;&#39;&#39; DECORATORS FOR HISTO VERTICAL, HISTO HORIZONTAL, PIE &#39;&#39;&#39;
    def decohistopie(func):
        @wraps(func)
        def inner_decohistopie(self, geopdwd, input_field, **kwargs):
            &#34;&#34;&#34;
            Decorator for
            Horizontal histogram &amp; Pie Chart
            &#34;&#34;&#34;
            geopdwd[&#39;cases&#39;] = geopdwd[input_field]
            maplabel = kwargs.get(&#39;maplabel&#39;,None)
            plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
            plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

            geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
            geopdwd_filter = geopdwd_filter.reset_index(drop = True)
            geopdwd_filter[&#39;cases&#39;] = geopdwd_filter[input_field]
            cursor_date = kwargs.get(&#39;cursor_date&#39;,self.dvisu_default[&#39;cursor_date&#39;])
            date_slider = kwargs[&#39;date_slider&#39;]
            my_date = geopdwd.date.unique()
            dico_utc = {i: DateSlider(value=i).value for i in my_date}
            geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
            #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
            #geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])
            geopdwd = geopdwd.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
            geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])
            locunique = geopdwd_filter.clustername.unique()#geopdwd_filtered.location.unique()
            geopdwd_filter = geopdwd_filter.copy()
            nmaxdisplayed = MAXCOUNTRIESDISPLAYED


            if len(locunique) &gt;= nmaxdisplayed :#and func.__name__ != &#39;pycoa_pie&#39; :
                if func.__name__ != &#39;pycoa_pie&#39; :
                    geopdwd_filter = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed])]
                else:
                    geopdwd_filter_first = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed-1])]
                    geopdwd_filter_other = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[nmaxdisplayed-1:])]
                    geopdwd_filter_other = geopdwd_filter_other.groupby(&#39;date&#39;).sum()
                    geopdwd_filter_other[&#39;location&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;clustername&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;codelocation&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;permanentdisplay&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;rolloverdisplay&#39;] = &#39;others&#39;
                    geopdwd_filter_other[&#39;colors&#39;] = &#39;#FFFFFF&#39;

                    geopdwd_filter = geopdwd_filter_first
                    geopdwd_filter = geopdwd_filter.append(geopdwd_filter_other)
            if func.__name__ == &#39;pycoa_horizonhisto&#39; :
                #geopdwd_filter[&#39;bottom&#39;] = geopdwd_filter.index
                geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;cases&#39;]
                geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;cases&#39;]
                geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;left&#39;].apply(lambda x: 0 if x &gt; 0 else x)
                geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 0 if x &lt; 0 else x)

                n = len(geopdwd_filter.index)
                d =  plot_height / n
                ymax = plot_height

                geopdwd_filter[&#39;top&#39;] = [ymax*(n-i)/n + d/2   for i in range(n)]
                geopdwd_filter[&#39;bottom&#39;] = [ymax*(n-i)/n - d/2 for i in range(n)]
                geopdwd_filter[&#39;horihistotexty&#39;] = geopdwd_filter[&#39;bottom&#39;] + d/2
                geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
                if maplabel and &#39;label%&#39; in maplabel:
                    geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 100.*x)
                    geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
                    geopdwd_filter[&#39;horihistotext&#39;] = [str(round(i))+&#39;%&#39; for i in geopdwd_filter[&#39;right&#39;]]
                else:
                    geopdwd_filter[&#39;horihistotext&#39;] = [ &#39;{:.3g}&#39;.format(float(i)) if float(i)&gt;1.e4 else round(float(i),2) for i in geopdwd_filter[&#39;right&#39;] ]
                    geopdwd_filter[&#39;horihistotext&#39;] = [str(i) for i in geopdwd_filter[&#39;horihistotext&#39;]]
            if func.__name__ == &#39;pycoa_pie&#39; :
                geopdwd_filter = self.add_columns_for_pie_chart(geopdwd_filter,input_field)
                geopdwd = self.add_columns_for_pie_chart(geopdwd,input_field)
                if maplabel and &#39;label%&#39; in maplabel:
                    geopdwd_filter[&#39;textdisplayed2&#39;] = geopdwd_filter[&#39;percentage&#39;]
                    geopdwd[&#39;textdisplayed2&#39;] =  geopdwd[&#39;percentage&#39;]

            source = ColumnDataSource(data = geopdwd)
            input_filter = geopdwd_filter
            srcfiltered = ColumnDataSource(data = input_filter)
            max_value = max(input_filter[&#39;cases&#39;])
            min_value = min(input_filter[&#39;cases&#39;])
            min_value_gt0 = min(input_filter[input_filter[&#39;cases&#39;] &gt; 0][&#39;cases&#39;])
            panels = []
            for axis_type in self.ax_type:
                plot_width = kwargs[&#39;plot_width&#39;]
                plot_height = kwargs[&#39;plot_height&#39;]
                standardfig = self.standardfig( x_axis_type = axis_type,  x_range = (1.05*min_value, 1.05 * max_value),**kwargs)
                if maplabel and &#39;label%&#39; in maplabel:
                    standardfig.x_range = Range1d(0.01, 1.2 * max_value*100)
                    standardfig.xaxis.axis_label = &#39;percentage(%)&#39;
                    standardfig.xaxis.formatter = BasicTickFormatter(use_scientific=False)
                else:
                    standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
                    standardfig.x_range = Range1d(0.01, 1.2 * max_value)
                if not input_filter[input_filter[input_field] &lt; 0.].empty:
                    standardfig.x_range = Range1d(1.2 * min_value, 1.2 * max_value)

                if axis_type == &#34;log&#34;:
                    if not input_filter[input_filter[input_field] &lt; 0.].empty:
                        print(&#39;Some value are negative, can\&#39;t display log scale in this context&#39;)
                    else:
                        if func.__name__ == &#39;pycoa_horizonhisto&#39; :
                            if maplabel and &#39;label%&#39; in maplabel:
                                standardfig.x_range = Range1d(0.01, 50 * max_value*100)
                            else:
                                standardfig.x_range = Range1d(0.01, 50 * max_value)
                            srcfiltered.data[&#39;left&#39;] = [0.01] * len(srcfiltered.data[&#39;right&#39;])

                if func.__name__ == &#39;pycoa_pie&#39;:
                    if not input_filter[input_filter[input_field] &lt; 0.].empty:
                        raise CoaKeyError(&#39;Some values are negative, can\&#39;t display a Pie chart, try histo by location&#39;)
                    standardfig.plot_width = plot_height
                    standardfig.plot_height = plot_height

                if date_slider:
                    date_slider.width = int(0.8*plot_width)
                    callback = CustomJS(args = dict(source = source,
                                                  source_filter = srcfiltered,
                                                  date_slider = date_slider,
                                                  ylabel = standardfig.yaxis[0],
                                                  title = standardfig.title,
                                                  x_range = standardfig.x_range,
                                                  x_axis_type = axis_type,
                                                  figure = standardfig),
                            code = &#34;&#34;&#34;
                            var date_slide = date_slider.value;
                            var dates = source.data[&#39;date_utc&#39;];
                            var val = source.data[&#39;cases&#39;];
                            var loc = source.data[&#39;clustername&#39;];
                            //var loc = source.data[&#39;location&#39;];
                            var subregion = source.data[&#39;name_subregion&#39;];
                            var codeloc = source.data[&#39;codelocation&#39;];
                            var colors = source.data[&#39;colors&#39;];

                            var newval = [];
                            var newloc = [];
                            var newcolors = [];
                            var newcodeloc = [];
                            var newname_subregion = [];
                            var labeldic = {};
                            for (var i = 0; i &lt; dates.length; i++){
                            if (dates[i] == date_slide){
                                newval.push(parseFloat(val[i]));
                                newloc.push(loc[i]);
                                newcodeloc.push(codeloc[i]);
                                newcolors.push(colors[i]);
                                if(typeof subregion !== &#39;undefined&#39;)
                                    newname_subregion.push(subregion[i]);

                                }
                            }
                            var len = source_filter.data[&#39;clustername&#39;].length;

                            var indices = new Array(len);
                            for (var i = 0; i &lt; len; i++) indices[i] = i;

                            indices.sort(function (a, b) { return newval[a] &gt; newval[b] ? -1 : newval[a] &lt; newval[b] ? 1 : 0; });
                            var orderval = [];
                            var orderloc = [];
                            var ordercodeloc = [];
                            var ordername_subregion = [];
                            var ordercolors = [];
                            var textdisplayed = [];
                            for (var i = 0; i &lt; len; i++)
                            {
                                orderval.push(newval[indices[i]]);
                                orderloc.push(newloc[indices[i]]);
                                ordercodeloc.push(newcodeloc[indices[i]]);

                                if(typeof subregion !== &#39;undefined&#39;)
                                    ordername_subregion.push(newname_subregion[i]);
                                ordercolors.push(newcolors[indices[i]]);
                                //labeldic[len-indices[i]] = newcodeloc[indices[i]];
                                textdisplayed.push(newcodeloc[indices[i]].padStart(40,&#39; &#39;));
                            }


                            source_filter.data[&#39;cases&#39;] = orderval;
                            const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;
                            var tot = orderval.reduce(reducer);
                            var top = [];
                            var bottom = [];
                            var starts = [];
                            var ends = [];
                            var middle = [];
                            var text_x = [];
                            var text_y = [];
                            var r = 0.7;
                            var bthick = 0.95;
                            var cumul = 0.;
                            var percentage = [];
                            var angle = [];
                            var text_size = [];
                            var left_quad = [];
                            var right_quad = [];

                            for(var i = 0; i &lt; orderval.length; i++)
                            {
                                cumul += ((orderval[i] / tot) * 2 * Math.PI);
                                ends.push(cumul);
                                if(i==0)
                                    starts.push(0);
                                else
                                    starts.push(ends[i-1]);
                                middle.push((ends[i]+starts[i])/2);
                                text_x.push(r*Math.cos(middle[i]));
                                text_y.push(r*Math.sin(middle[i]));
                                percentage.push(String(100.*orderval[i] / tot).slice(0, 4));
                                angle.push((orderval[i] / tot) * 2 * Math.PI)
                                /*if ((ends[i]-starts[i]) &gt; 0.08*(2 * Math.PI))
                                    text_size.push(&#39;10pt&#39;);
                                else
                                    text_size.push(&#39;6pt&#39;);*/

                                //top.push((orderval.length-i) + bthick/2);
                                //bottom.push((orderval.length-i) - bthick/2);

                                if (isNaN(orderval[i])) orderval[i] = 0.;
                                if(orderval[i]&lt;=0.)
                                {
                                    left_quad.push(orderval[i]);
                                    right_quad.push(0.);
                                }
                                else
                                {
                                    left_quad.push(0);
                                    right_quad.push(orderval[i]);
                                }
                            }

                            source_filter.data[&#39;clustername&#39;] = orderloc;
                            source_filter.data[&#39;codelocation&#39;] = ordercodeloc;
                            //source_filter.data[&#39;colors&#39;] = ordercolors;

                            if(typeof subregion !== &#39;undefined&#39;)
                                source_filter.data[&#39;rolloverdisplay&#39;] = ordername_subregion;
                            else
                                source_filter.data[&#39;rolloverdisplay&#39;] = orderloc;

                            source_filter.data[&#39;ends&#39;] = ends;
                            source_filter.data[&#39;starts&#39;] = starts;
                            source_filter.data[&#39;middle&#39;] = middle;
                            source_filter.data[&#39;text_x&#39;] = text_x;
                            source_filter.data[&#39;text_y&#39;] = text_y;
                            //source_filter.data[&#39;text_size&#39;] = text_size;
                            source_filter.data[&#39;percentage&#39;] = percentage;
                            source_filter.data[&#39;angle&#39;] = angle;


                            source_filter.data[&#39;left&#39;] = left_quad;
                            source_filter.data[&#39;right&#39;] = right_quad;

                            var mid =[];
                            var ht = [];
                            var textdisplayed2 = [];

                            var n = right_quad.length;
                            var d = figure.plot_height / n;
                            var ymax = figure.plot_height;

                            for(i=0; i&lt;right_quad.length;i++){
                                top.push(parseInt(ymax*(n-i)/n+d/2));
                                bottom.push(parseInt(ymax*(n-i)/n-d/2));
                                mid.push(parseInt(ymax*(n-i)/n));
                                labeldic[parseInt(ymax*(n-i)/n)] = ordercodeloc[i];

                                ht.push(right_quad[i].toFixed(2).toString());
                                var a=new Intl.NumberFormat().format(right_quad[i])
                                textdisplayed2.push(a.toString().padStart(26,&#39; &#39;));
                                //textdisplayed2.push(right_quad[i].toFixed(2).toString().padStart(40,&#39; &#39;));

                            }
                            source_filter.data[&#39;top&#39;] = top;
                            source_filter.data[&#39;bottom&#39;] = bottom;

                            source_filter.data[&#39;horihistotextxy&#39;] =  mid;
                            source_filter.data[&#39;horihistotextx&#39;] =  right_quad;
                            source_filter.data[&#39;horihistotext&#39;] =  ht;
                            source_filter.data[&#39;permanentdisplay&#39;] = ordercodeloc;
                            source_filter.data[&#39;textdisplayed&#39;] = textdisplayed;
                            source_filter.data[&#39;textdisplayed2&#39;] = textdisplayed2;
                            var maxx = Math.max.apply(Math, right_quad);
                            var minx = Math.min.apply(Math, left_quad);

                            ylabel.major_label_overrides = labeldic;
                            console.log(labeldic);
                            x_range.end =  1.2 * maxx;
                            x_range.start =  1.05 * minx;
                            if(minx &gt;= 0){
                                x_range.start =  0.01;
                                source_filter.data[&#39;left&#39;] = Array(left_quad.length).fill(0.01);
                                }
                            var tmp = title.text;
                            tmp = tmp.slice(0, -11);
                            var dateconverted = new Date(date_slide);
                            var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                            var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                            var yyyy = dateconverted.getFullYear();
                            var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                            title.text = tmp + dmy+&#34;)&#34;;

                            source_filter.change.emit();
                        &#34;&#34;&#34;)
                    date_slider.js_on_change(&#39;value&#39;, callback)
                cases_custom = CocoDisplay.rollerJS()
                if func.__name__ == &#39;pycoa_pie&#39; :
                    standardfig.add_tools(HoverTool(
                        tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), (&#39;%&#39;,&#39;@percentage&#39;), ],
                        formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, &#39;%&#39;:&#39;printf&#39;},
                        point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
                else:
                    standardfig.add_tools(HoverTool(
                        tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), ],
                        formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, },
                        point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
                panel = Panel(child = standardfig, title = axis_type)
                panels.append(panel)
            return func(self, srcfiltered, panels, date_slider)
        return inner_decohistopie

    &#39;&#39;&#39; VERTICAL HISTO &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decohistopie
    def pycoa_horizonhisto(self, srcfiltered, panels, date_slider):
        &#39;&#39;&#39;
            -----------------
            Create 1D histogramme by location according to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        n = len(panels)
        new_panels = []
        for i in range(n):
            fig = panels[i].child
            fig.y_range = Range1d(min(srcfiltered.data[&#39;bottom&#39;]), max(srcfiltered.data[&#39;top&#39;]))
            fig.yaxis[0].formatter = NumeralTickFormatter(format=&#34;0.0&#34;)
            ytick_loc = [int(i) for i in srcfiltered.data[&#39;horihistotexty&#39;]]
            fig.yaxis.ticker  = ytick_loc
            label_dict = dict(zip(ytick_loc,srcfiltered.data[&#39;permanentdisplay&#39;]))
            fig.yaxis.major_label_overrides = label_dict

            #print(fig.y_range ,fig.yaxis.major_label_overrides)
            fig.quad(source = srcfiltered,
                top=&#39;top&#39;, bottom = &#39;bottom&#39;, left = &#39;left&#39;, right = &#39;right&#39;, color = &#39;colors&#39;, line_color = &#39;black&#39;,
                line_width = 1, hover_line_width = 2)

            labels = LabelSet(
                    x = &#39;horihistotextx&#39;,
                    y = &#39;horihistotexty&#39;,
                    x_offset=5,
                    y_offset=-4,
                    text = &#39;horihistotext&#39;,
                    source = srcfiltered,text_font_size=&#39;10px&#39;,text_color=&#39;black&#39;)
            fig.add_layout(labels)

            panel = Panel(child = fig, title = panels[i].title)
            new_panels.append(panel)
        tabs = Tabs(tabs = new_panels)
        if date_slider:
                tabs = column(date_slider,tabs)
        return tabs

    &#39;&#39;&#39; PIE &#39;&#39;&#39;
    def add_columns_for_pie_chart(self,df,column_name):
        df = df.copy()
        column_sum = df[column_name].sum()
        df[&#39;percentage&#39;] = df[column_name]/column_sum
        percentages = [0]  + df[&#39;percentage&#39;].cumsum().tolist()
        df[&#39;angle&#39;] = (df[column_name]/column_sum)*2 * np.pi
        df[&#39;starts&#39;] = [p * 2 * np.pi for p in percentages[:-1]]
        df[&#39;ends&#39;] = [p * 2 * np.pi for p in percentages[1:]]
        df[&#39;diff&#39;] = (df[&#39;ends&#39;] - df[&#39;starts&#39;])
        df[&#39;middle&#39;] = df[&#39;starts&#39;]+np.abs(df[&#39;ends&#39;]-df[&#39;starts&#39;])/2.
        df[&#39;cos&#39;] = np.cos(df[&#39;middle&#39;]) * 0.9
        df[&#39;sin&#39;] = np.sin(df[&#39;middle&#39;]) * 0.9

        df[&#39;text_size&#39;] = &#39;8pt&#39;
        df[&#39;textdisplayed&#39;] = df[&#39;permanentdisplay&#39;].str.pad(36, side = &#34;left&#34;)
        locale.setlocale(locale.LC_ALL, &#39;en_US&#39;)
        df[&#39;textdisplayed2&#39;] = [ locale.format(&#34;%d&#34;, i, grouping=True)\
                for i in df[column_name]]
        #df[&#39;textdisplayed2&#39;] = df[column_name].astype(str) #[i.str for i in df[column_name]]
        df[&#39;textdisplayed2&#39;] = df[&#39;textdisplayed2&#39;].str.pad(26, side = &#34;left&#34;)
        #df[&#39;textdisplayed2&#39;]  = df[column_name].str.pad(26, side = &#34;left&#34;)
        df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed&#39;]=&#39;&#39;
        df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed2&#39;]=&#39;&#39;
        df[&#39;percentage&#39;] = 100.*df[&#39;percentage&#39;]
        return df

    @decowrapper
    @decohistomap
    @decohistopie
    def pycoa_pie(self, srcfiltered, panels, date_slider):
        &#39;&#39;&#39;
            -----------------
            Create a pie chart according to arguments.
            See help(pycoa_pie).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
        &#39;&#39;&#39;
        standardfig = panels[0].child
        standardfig.plot_height=400
        standardfig.plot_width=400
        standardfig.x_range = Range1d(-1.1, 1.1)
        standardfig.y_range = Range1d(-1.1, 1.1)
        standardfig.axis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None

        standardfig.wedge(x=0, y=0, radius=1.,line_color=&#39;#E8E8E8&#39;,
        start_angle=cumsum(&#39;angle&#39;, include_zero=True), end_angle=cumsum(&#39;angle&#39;),
        fill_color=&#39;colors&#39;, legend_label=&#39;clustername&#39;, source=srcfiltered)
        standardfig.legend.visible = False

        labels = LabelSet(x=0, y=0,text=&#39;textdisplayed&#39;,angle=cumsum(&#39;angle&#39;, include_zero=True),
        text_font_size=&#34;10pt&#34;,source=srcfiltered,render_mode=&#39;canvas&#39;)

        labels2 = LabelSet(x=0, y=0, text=&#39;textdisplayed2&#39;,
        angle=cumsum(&#39;angle&#39;, include_zero=True),text_font_size=&#34;8pt&#34;,source=srcfiltered)

        standardfig.add_layout(labels)
        standardfig.add_layout(labels2)
        if date_slider:
            standardfig = column(date_slider,standardfig)
        return standardfig

    &#39;&#39;&#39; MAP FOLIUM &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    def pycoa_mapfolium(self, geopdwd, input_field, **kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a map folium to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
        &#39;&#39;&#39;
        title = kwargs.get(&#39;title&#39;, None)
        tile =  kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])
        tile = CocoDisplay.convert_tile(tile, &#39;folium&#39;)
        maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
        plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
        plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

        geopdwd[&#39;cases&#39;] = geopdwd[input_field]
        geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
        geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered[input_field]
        my_date = geopdwd.date.unique()
        dico_utc = {i: DateSlider(value=i).value for i in my_date}
        geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
        #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
        #geopdwd_filtered = geopdwd_filtered.sort_values(by=&#39;cases&#39;, ascending = False).reset_index()
        #locunique = geopdwd_filtered.clustername.unique()#geopdwd_filtered.location.unique()
        if self.database_name == &#39;risklayer&#39;:
            geopdwd_filtered = geopdwd_filtered.loc[geopdwd_filtered.geometry.notna()]

        uniqloc = list(geopdwd_filtered.codelocation.unique())
        geopdwd_filtered = geopdwd_filtered.drop(columns=[&#39;date&#39;, &#39;colors&#39;])

        msg = &#34;(data from: {})&#34;.format(self.database_name)

        minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds

        mapa = folium.Map(tiles=tile, attr=&#39;&lt;a href=\&#34;http://pycoa.fr\&#34;&gt; ©pycoa.fr &lt;/a&gt;&#39; + msg)
        #min_lat=minx, max_lat=maxx, min_lon=miny, max_lon=maxy)
        #location=[geopdwd_filtered.centroid.y.mean(),geopdwd_filtered.centroid.x.mean()],)
        if self.dbld[self.database_name][0] != &#39;WW&#39;:
            mapa.fit_bounds([(miny, minx), (maxy, maxx)])

        fig = Figure(width=plot_width, height=plot_height)
        fig.add_child(mapa)
        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[input_field]),
                                                     np.nanmax(geopdwd_filtered[input_field]))
        min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

        invViridis256 = Viridis256[::-1]
        if &#39;log&#39; in maplabel:
            geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0][&#39;cases&#39;]
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#d9d9d9&#39;)
            colormap =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
        else:
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#d9d9d9&#39;)
            colormap = branca.colormap.LinearColormap(color_mapper.palette).scale(min_col, max_col)
        colormap.caption =  title
        colormap.add_to(mapa)
        map_id = colormap.get_name()

        custom_label_colorbar_js = &#34;&#34;&#34;
        var div = document.getElementById(&#39;legend&#39;);
        var ticks = document.getElementsByClassName(&#39;tick&#39;)
        for(var i = 0; i &lt; ticks.length; i++){
        var values = ticks[i].textContent.replace(&#39;,&#39;,&#39;&#39;)
        val = parseFloat(values).toExponential(1).toString().replace(&#34;+&#34;, &#34;&#34;)
        if(parseFloat(ticks[i].textContent) == 0) val = 0.
        div.innerHTML = div.innerHTML.replace(ticks[i].textContent,val);
        }
        &#34;&#34;&#34;
        e = Element(custom_label_colorbar_js)
        html = colormap.get_root()
        html.script.get_root().render()
        html.script._children[e.get_name()] = e
        geopdwd_filtered[input_field + &#39;scientific_format&#39;] = \
            ([&#39;{:.5g}&#39;.format(i) for i in geopdwd_filtered[&#39;cases&#39;]])
        # ([&#39;{:.3g}&#39;.format(i) if i&gt;100000 else i for i in geopdwd_filter[input_field]])

        map_dict = geopdwd_filtered.set_index(&#39;location&#39;)[input_field].to_dict()
        if np.nanmin(geopdwd_filtered[input_field]) == np.nanmax(geopdwd_filtered[input_field]):
            map_dict[&#39;FakeCountry&#39;] = 0.

        if &#39;log&#39; in maplabel:
            color_scale =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
        else:
            color_scale = LinearColormap(color_mapper.palette, vmin=min(map_dict.values()), vmax=max(map_dict.values()))

        def get_color(feature):
            value = map_dict.get(feature[&#39;properties&#39;][&#39;location&#39;])
            if value is None or np.isnan(value):
                return &#39;#8c8c8c&#39;  # MISSING -&gt; gray
            else:
                return color_scale(value)

        displayed = &#39;rolloverdisplay&#39;
        folium.GeoJson(
            geopdwd_filtered,
            style_function=lambda x:
            {
                &#39;fillColor&#39;: get_color(x),
                &#39;fillOpacity&#39;: 0.8,
                &#39;color&#39;: None
            },
            highlight_function=lambda x: {&#39;weight&#39;: 2, &#39;color&#39;: &#39;green&#39;},
            tooltip=folium.features.GeoJsonTooltip(fields=[displayed, input_field + &#39;scientific_format&#39;],
                                                   aliases=[&#39;location&#39; + &#39;:&#39;, input_field + &#34;:&#34;],
                                                   style=&#34;&#34;&#34;
                        background-color: #F0EFEF;
                        border: 2px solid black;
                        border-radius: 3px;
                        box-shadow: 3px;
                        opacity: 0.2;
                        &#34;&#34;&#34;),
            # &#39;&lt;div style=&#34;barialckground-color: royalblue 0.2; color: black; padding: 2px; border: 1px solid black; border-radius: 2px;&#34;&gt;&#39;+input_field+&#39;&lt;/div&gt;&#39;])
        ).add_to(mapa)
        return mapa

    &#39;&#39;&#39; DECORATOR FOR MAP BOKEH &#39;&#39;&#39;
    def decopycoageo(func):
        @wraps(func)
        def innerdecopycoageo(self, geopdwd, input_field, **kwargs):
            geopdwd[&#39;cases&#39;] = geopdwd[input_field]
            geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
            geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
            geopdwd_filtered = gpd.GeoDataFrame(geopdwd_filtered, geometry=geopdwd_filtered.geometry, crs=&#34;EPSG:4326&#34;)
            geopdwd = geopdwd.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False])
            geopdwd_filtered = geopdwd_filtered.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False]).drop(columns=[&#39;date&#39;, &#39;colors&#39;])
            new_poly = []
            geolistmodified = dict()

            for index, row in geopdwd_filtered.iterrows():
                split_poly = []
                new_poly = []
                if row[&#39;geometry&#39;]:
                    for pt in self.get_polycoords(row):
                        if type(pt) == tuple:
                            new_poly.append(CocoDisplay.wgs84_to_web_mercator(pt))
                        elif type(pt) == list:
                            shifted = []
                            for p in pt:
                                shifted.append(CocoDisplay.wgs84_to_web_mercator(p))
                            new_poly.append(sg.Polygon(shifted))
                        else:
                            raise CoaTypeError(&#34;Neither tuple or list don&#39;t know what to do with \
                                your geometry description&#34;)

                    if type(new_poly[0]) == tuple:
                        geolistmodified[row[&#39;location&#39;]] = sg.Polygon(new_poly)
                    else:
                        geolistmodified[row[&#39;location&#39;]] = sg.MultiPolygon(new_poly)
            ng = pd.DataFrame(geolistmodified.items(), columns=[&#39;location&#39;, &#39;geometry&#39;])
            geolistmodified = gpd.GeoDataFrame({&#39;location&#39;: ng[&#39;location&#39;], &#39;geometry&#39;: gpd.GeoSeries(ng[&#39;geometry&#39;])}, crs=&#34;epsg:3857&#34;)
            geopdwd_filtered = geopdwd_filtered.drop(columns=&#39;geometry&#39;)
            geopdwd_filtered = pd.merge(geolistmodified, geopdwd_filtered, on=&#39;location&#39;)
            #if kwargs[&#39;wanted_dates&#39;]:
            #    kwargs.pop(&#39;wanted_dates&#39;)
            return func(self, geopdwd, geopdwd_filtered, **kwargs)
        return innerdecopycoageo

    &#39;&#39;&#39; RETURN GEOMETRY, LOCATIO + CASES &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    def pycoageo(self, geopdwd, geopdwd_filtered, **kwargs):
        return geopdwd_filtered

    def decomap(func):
        @wraps(func)
        def innerdecomap(self, geopdwd, geopdwd_filtered, **kwargs):
            title = kwargs.get(&#39;title&#39;, None)
            maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
            tile =  kwargs.get(&#39;tile&#39;, None)
            if tile:
                tile = CocoDisplay.convert_tile(tile, &#39;bokeh&#39;)

            uniqloc = list(geopdwd_filtered.clustername.unique())
            dfLabel = pd.DataFrame()
            sourcemaplabel = ColumnDataSource(dfLabel)
            if maplabel or func.__name__ == &#39;pycoa_pimpmap&#39;:
                locsum = geopdwd_filtered.clustername.unique()
                numberpercluster = geopdwd_filtered[&#39;clustername&#39;].value_counts().to_dict()
                sumgeo = geopdwd_filtered.copy()
                sumgeo[&#39;geometry&#39;] = sumgeo[&#39;geometry&#39;].buffer(0.001) #needed with geopandas 0.10.2
                sumgeo = sumgeo.dissolve(by=&#39;clustername&#39;, aggfunc=&#39;sum&#39;).reset_index()
                sumgeo[&#39;nb&#39;] = sumgeo[&#39;clustername&#39;].map(numberpercluster)
                #print(geopdwd_filtered.loc[geopdwd_filtered.clustername==&#39;Île-de-France&#39;].reset_index(drop=True).explode(index_parts=False))
                centrosx = sumgeo[&#39;geometry&#39;].centroid.x
                centrosy = sumgeo[&#39;geometry&#39;].centroid.y
                cases = sumgeo[&#39;cases&#39;]/sumgeo[&#39;nb&#39;]
                dfLabel=pd.DataFrame({&#39;clustername&#39;:sumgeo.clustername,&#39;centroidx&#39;:centrosx,&#39;centroidy&#39;:centrosy,&#39;cases&#39;:cases,&#39;geometry&#39;:sumgeo[&#39;geometry&#39;]})

                if &#39;spark&#39; in maplabel:
                    sparkos = {i: CocoDisplay.sparkline(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                                (geopdwd.date &gt;= self.when_beg) &amp;
                                (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[&#39;cases&#39;]) for i in locsum }
                    dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                    dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)
                if &#39;spiral&#39; in maplabel:
                    sparkos = {i: CocoDisplay.spiral(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                                (geopdwd.date &gt;= self.when_beg) &amp;
                                (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[[&#39;date&#39;,&#39;cases&#39;,&#39;clustername&#39;]]) for i in locsum }
                    dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                    dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)

                dfLabel[&#39;cases&#39;] = dfLabel[&#39;cases&#39;].round(2)
                # Converting links to html tags
                if &#39;label%&#39; in maplabel:
                    dfLabel[&#39;cases&#39;] = [str(round(float(i*100),2))+&#39;%&#39; for i in dfLabel[&#39;cases&#39;]]
                else:
                    dfLabel[&#39;cases&#39;]=[str(i) for i in dfLabel[&#39;cases&#39;]]
                sourcemaplabel = ColumnDataSource(dfLabel.drop(columns=&#39;geometry&#39;))
            minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds #self.boundary
            #if self.dbld[self.database_name][0] != &#39;WW&#39;:
            #    ratio = 0.05
            #    minx -= ratio*minx
            #    maxx += ratio*maxx
            #    miny -= ratio*miny
            #    maxy += ratio*maxy
            #if func.__name__ == &#39;pycoa_pimpmap&#39;:
            #    dico[&#39;titlebar&#39;]=tit[:-12]+&#39; [ &#39;+dico[&#39;when_beg&#39;].strftime(&#39;%d/%m/%Y&#39;)+ &#39;-&#39;+ tit[-12:-1]+&#39;])&#39;

            kwargs[&#39;plot_width&#39;]=kwargs[&#39;plot_height&#39;]
            x_range=(minx,maxx)
            y_range=(miny,maxy)
            if func.__name__ == &#39;pycoa_pimpmap&#39;:
                standardfig = self.standardfig(x_range=x_range, y_range=y_range, x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)
            else:
                standardfig = self.standardfig(x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)

            if tile:
                wmt = WMTSTileSource(
                            url=tile)
                standardfig.add_tile(wmt)
            else:
                standardfig.background_fill_color = &#34;lightgrey&#34;

            geopdwd_filtered = geopdwd_filtered[[&#39;cases&#39;,&#39;geometry&#39;,&#39;location&#39;,&#39;clustername&#39;,&#39;codelocation&#39;,&#39;rolloverdisplay&#39;]]
            if not dfLabel.empty:
                geopdwd_filtered = geopdwd_filtered.drop(columns = &#39;geometry&#39;)
                geopdwd_filtered = pd.merge(geopdwd_filtered, dfLabel[[&#39;clustername&#39;,&#39;geometry&#39;]], on = &#39;clustername&#39;)
                geopdwd_filtered = geopdwd_filtered.drop_duplicates(subset = [&#39;clustername&#39;])
            if self.dbld[self.database_name][0] == &#39;BEL&#39; :
                reorder = list(geopdwd_filtered.location.unique())
                geopdwd_filtered = geopdwd_filtered.set_index(&#39;location&#39;)
                geopdwd_filtered = geopdwd_filtered.reindex(index = reorder)
                geopdwd_filtered = geopdwd_filtered.reset_index()

            if self.dbld[self.database_name][0] == &#39;GBR&#39; :
                geopdwd = geopdwd.loc[~geopdwd.cases.isnull()]
                geopdwd_filtered  = geopdwd_filtered.loc[~geopdwd_filtered.cases.isnull()]
            return func(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs)
        return innerdecomap

    &#39;&#39;&#39; MAP BOKEH &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    @decomap
    def pycoa_map(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a map bokeh with arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
            - tile : tile
            - maplabel: False
        &#39;&#39;&#39;

        date_slider = kwargs[&#39;date_slider&#39;]
        maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                     np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

        min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

        json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
        geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

        invViridis256 = Viridis256[::-1]
        if &#39;log&#39; in maplabel:
            color_mapper = LogColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#ffffff&#39;)
        else:
            color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
            color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4, width=standardfig.plot_width, bar_line_cap=&#39;round&#39;,
                             border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
        color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))

        if &#39;label%&#39; in maplabel:
            color_bar.formatter = BasicTickFormatter(use_scientific=False)
            color_bar.formatter = NumeralTickFormatter(format=&#34;0.0%&#34;)

        standardfig.add_layout(color_bar, &#39;below&#39;)

        if date_slider:
            allcases_location, allcases_dates = pd.DataFrame(), pd.DataFrame()
            allcases_location = geopdwd.groupby(&#39;location&#39;)[&#39;cases&#39;].apply(list)
            geopdwd_tmp = geopdwd.drop_duplicates(subset = [&#39;location&#39;]).drop(columns = &#39;cases&#39;)
            geopdwd_tmp = pd.merge(geopdwd_tmp, allcases_location, on = &#39;location&#39;)
            geopdwd_tmp  = geopdwd_tmp.drop_duplicates(subset = [&#39;clustername&#39;])
            geopdwd_tmp = ColumnDataSource(geopdwd_tmp.drop(columns=[&#39;geometry&#39;]))

            sourcemaplabel.data[&#39;rolloverdisplay&#39;] = sourcemaplabel.data[&#39;clustername&#39;]
            callback = CustomJS(args =  dict(source = geopdwd_tmp, source_filter = geopdwd_filtered,
                                          date_sliderjs = date_slider, title=standardfig.title,
                                          maplabeljs = sourcemaplabel),
                        code = &#34;&#34;&#34;
                        var ind_date_max = (date_sliderjs.end-date_sliderjs.start)/(24*3600*1000);
                        var ind_date = (date_sliderjs.value-date_sliderjs.start)/(24*3600*1000);
                        var new_cases = [];
                        var dict = {};
                        var iloop = source_filter.data[&#39;clustername&#39;].length;

                        function form(value) {
                             if(value&gt;10000 || value &lt;0.01)
                                value =  Number.parseFloat(value).toExponential(2);
                             else
                                 value = Number.parseFloat(value).toFixed(2);
                            console.log(value);
                            return value;
                         }
                        for (var i = 0; i &lt; source.get_length(); i++)
                        {
                                var val=form(source.data[&#39;cases&#39;][i][ind_date_max-ind_date]);
                                new_cases.push(val);
                        }
                        if(source.get_length() == 1 &amp;&amp; iloop&gt;1)
                            for(var i = 0; i &lt; iloop; i++)
                                for(var j = 0; j &lt; new_cases.length; j++){
                                source_filter.data[&#39;cases&#39;][i][j] = new_cases[j];
                                }
                        else{
                            source_filter.data[&#39;cases&#39;] = new_cases;
                            }

                        if (maplabeljs.get_length() !== 0){
                            maplabeljs.data[&#39;cases&#39;] = source_filter.data[&#39;cases&#39;];
                            }
                        for (var i = 0; i &lt; maplabeljs.get_length(); i++)
                        {
                            maplabeljs.data[&#39;cases&#39;][i] = form(maplabeljs.data[&#39;cases&#39;][i]).toString();
                            maplabeljs.data[&#39;rolloverdisplay&#39;][i] = source_filter.data[&#39;rolloverdisplay&#39;][i];
                        }
                        var tmp = title.text;
                        tmp = tmp.slice(0, -11);
                        var dateconverted = new Date(date_sliderjs.value);
                        var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                        var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                        var yyyy = dateconverted.getFullYear();
                        var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                        title.text = tmp + dmy+&#34;)&#34;;
                        if (maplabeljs.get_length() !== 0)
                            maplabeljs.change.emit();

                        console.log(maplabeljs.data[&#39;cases&#39;]);
                        source_filter.change.emit();
                    &#34;&#34;&#34;)
            date_slider.js_on_change(&#39;value&#39;, callback)


        standardfig.xaxis.visible = False
        standardfig.yaxis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None
        standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                            fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                            line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)

        if &#39;text&#39; in maplabel :
            labels = LabelSet(
                x = &#39;centroidx&#39;,
                y = &#39;centroidy&#39;,
                text = &#39;cases&#39;,
                source = sourcemaplabel, text_font_size=&#39;10px&#39;,text_color=&#39;white&#39;,background_fill_color=&#39;grey&#39;,background_fill_alpha=0.5)
            standardfig.add_layout(labels)

        #cases_custom = CocoDisplay.rollerJS()
        callback = CustomJS(code=&#34;&#34;&#34;
        //document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.backgroundColor=&#34;transparent&#34;;
        document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.opacity=&#34;0.7&#34;;
        &#34;&#34;&#34; )
        tooltips = &#34;&#34;&#34;
                    &lt;b&gt;location: @rolloverdisplay&lt;br&gt;
                    cases: @cases{0,0.0}&lt;/b&gt;
                   &#34;&#34;&#34;
        standardfig.add_tools(HoverTool(tooltips = tooltips,
        formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;cases&#39;: &#39;printf&#39;,},
        point_policy = &#34;snap_to_data&#34;,callback=callback))  # ,PanTool())
        if date_slider:
            standardfig = column(date_slider, standardfig)
        return standardfig

    &#39;&#39;&#39; PIMPMAP BOKEH &#39;&#39;&#39;
    @decowrapper
    @decohistomap
    @decopycoageo
    @decomap
    def pycoa_pimpmap(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
        &#39;&#39;&#39;
            -----------------
            Create a bokeh map with pimpline label and with to arguments.
            See help(pycoa_histo).
            Keyword arguments
            -----------------
            - srcfiltered : A DataFrame with a Pycoa struture is mandatory
            |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
            - input_field = if None take second element could be a list
            - plot_heigh= width_height_default[1]
            - plot_width = width_height_default[0]
            - title = None
            - textcopyright = default
            - mode = mouse
            - cursor_date = None if True
                    - orientation = horizontal
            - when : default min and max according to the inpude DataFrame.
                         Dates are given under the format dd/mm/yyyy.
                         when format [dd/mm/yyyy : dd/mm/yyyy]
                         if [:dd/mm/yyyy] min date up to
                         if [dd/mm/yyyy:] up to max date
            - tile : tile
            - maplabel: False
        &#39;&#39;&#39;
        standardfig.xaxis.visible = False
        standardfig.yaxis.visible = False
        standardfig.xgrid.grid_line_color = None
        standardfig.ygrid.grid_line_color = None

        min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                     np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

        json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
        geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

        invViridis256 = Viridis256[::-1]
        color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
        color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4,
                             border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
        color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))
        standardfig.add_layout(color_bar, &#39;below&#39;)
        standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                                    fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                                    line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)
        standardfig.image_url(url=&#39;pimpmap&#39;, x=&#39;centroidx&#39;, y=&#39;centroidy&#39;,source=sourcemaplabel,anchor=&#34;center&#34;)
        return standardfig
    ######################
    def tiles_list(self):
        return self.available_tiles
    ###################### BEGIN Static Methods ##################
    @staticmethod
    def convert_tile(tilename, which = &#39;bokeh&#39;):
        &#39;&#39;&#39; Return tiles url according to folium or bokeh resquested&#39;&#39;&#39;
        tile = &#39;openstreet&#39;
        if tilename == &#39;openstreet&#39;:
            if which == &#39;folium&#39;:
                tile = r&#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#39;
            else:
                tile = r&#39;http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png&#39;
        elif tilename == &#39;positron&#39;:
            print(&#39;Problem with positron tile (huge http resquest need to check), esri is then used ...&#39;)
            tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
        #    tile = &#39;https://tiles.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png&#39;
        elif tilename == &#39;esri&#39;:
            tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
        elif tilename == &#39;stamen&#39;:
            tile = r&#39;http://tile.stamen.com/toner/{z}/{x}/{y}.png&#39;
        else:
            print(&#39;Don\&#39;t know you tile ... take default one: &#39;)
        return tile
    #####################
    @staticmethod
    def dict_shorten_loc(toshort):
        &#39;&#39;&#39;
            return a shorten name location
        &#39;&#39;&#39;
        s = []
        if type(toshort) == np.ndarray:
            toshort = list(toshort)
            toshort = [toshort]
            s = &#39;&#39;
        elif type(toshort) == str:
            toshort = [toshort]
            s = &#39;&#39;
        #if type(toshort) != list:
        #    print(&#39;That is weird ...&#39;, toshort, &#39;not str nor list&#39;)
        for val in toshort:
            if not isinstance(val,str):
                val= str(val)
            if type(val) == list:
                val = val[0]
            if val.find(&#39;,&#39;) == -1:
                A = val
            else:
                txt = val.split(&#39;,&#39;)
                if len(txt[0]) &lt; 4 and len(txt[-1]) &lt; 4:
                    A = [txt[0] + &#39;...&#39; + txt[-1]]
                else:
                    A = txt[0][:5] + &#39;...&#39; + txt[-1][-5:]
            if type(s) == list:
                s.append(A)
            else:
                s = A
            if isinstance(s, list):
                s=s[0]
        return s
    ######################
    @staticmethod
    def bokeh_legend(bkfigure):
        toggle_legend_js = CustomJS(args=dict(leg=bkfigure.legend[0]),
                                    code=&#34;&#34;&#34;
        if(leg.visible)
        {
            leg.visible = false;
        }
        else
        {
            leg.visible = true;
        }
        &#34;&#34;&#34;)
        bkfigure.js_on_event(events.DoubleTap, toggle_legend_js)
    ######################
    @staticmethod
    def min_max_range(a_min, a_max):
        &#34;&#34;&#34; Return a cleverly rounded min and max giving raw min and raw max of data.
        Usefull for hist range and colormap
        &#34;&#34;&#34;
        min_p = 0
        max_p = 0
        if a_min != 0:
            min_p = math.floor(math.log10(math.fabs(a_min)))  # power
        if a_max != 0:
            max_p = math.floor(math.log10(math.fabs(a_max)))

        if a_min == 0:
            if a_max == 0:
                p = 0
            else:
                p = max_p
        else:
            if a_max == 0:
                p = min_p
            else:
                p = max(min_p, max_p)

        if a_min != 0:
            min_r = math.floor(a_min / 10 ** (p - 1)) * 10 ** (p - 1)  # min range rounded
        else:
            min_r = 0

        if a_max != 0:
            max_r = math.ceil(a_max / 10 ** (p - 1)) * 10 ** (p - 1)
        else:
            max_r = 0

        if min_r == max_r:
            if min_r == 0:
                min_r = -1
                max_r = 1
                k = 0
            elif max_r &gt; 0:
                k = 0.1
            else:
                k = -0.1
            max_r = (1 + k) * max_r
            min_r = (1 - k) * min_r

        return (min_r, max_r)
    ######################
    @staticmethod
    def save_map2png(map=None, pngfile=&#39;map.png&#39;):
        &#34;&#34;&#34;
        Save map as png geckodriver and PIL packages are needed
        &#34;&#34;&#34;
        size = width_height_default[0], width_height_default[1]
        if pngfile:
            pngfile = pngfile
        img_data = map._to_png(5)
        img = Image.open(io.BytesIO(img_data))
        img.thumbnail(size, Image.ANTIALIAS)
        img.save(pngfile)
        print(pngfile, &#39; is now save ...&#39;)
    ######################
    @staticmethod
    def save_pandas_as_png(df=None, pngfile=&#39;pandas.png&#39;):
        source = ColumnDataSource(df)
        df_columns = [df.index.name]
        df_columns.extend(df.columns.values)
        columns_for_table = []
        for column in df_columns:
            if column is not None:
                columns_for_table.append(TableColumn(field=column, title=column))
                # width_height_default
        data_table = DataTable(source=source, columns=columns_for_table,
                               height_policy=&#34;auto&#34;, width_policy=&#34;auto&#34;, index_position=None)
        export_png(data_table, filename=pngfile)
    ######################
    @staticmethod
    def changeto_nonan_date(df=None, when_end=None, field=None):
        if not isinstance(when_end, dt.date):
            raise CoaTypeError(&#39; Not a valid data ... &#39;)

        boolval = True
        j = 0
        while (boolval):
            boolval = df.loc[df.date == (when_end - dt.timedelta(days=j))][field].dropna().empty
            j += 1
        if j &gt; 1:
            verb(str(when_end) + &#39;: all the value seems to be nan! I will find an other previous date.\n&#39; +
                 &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
        return when_end - dt.timedelta(days=j - 1)
    ######################
    @staticmethod
    def changeto_nonull_date(df=None,when_end = None, field=None):
        if not isinstance(when_end, dt.date):
            raise CoaTypeError(&#39; Not a valid data ... &#39;)
        boolval = True
        j = 0
        #df = df.fillna(0)
        if all(df[field] == 0):
            print(&#39;all value is null for all date !&#39;)
            return when_end
        else:
            while(boolval):
                boolval = all(v == 0. or np.isnan(v) for v in df.loc[df.date == (when_end - dt.timedelta(days=j))][field].values)
                j += 1
            if j &gt; 1:
                verb(str(when_end) + &#39;: all the value seems to be 0! I will find an other previous date.\n&#39; +
                     &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
            return when_end - dt.timedelta(days=j - 1)
    ######################
    @staticmethod
    def get_utcdate(date):
        return (date - dt.date(1970, 1, 1)).total_seconds() * 1000.
    ######################
    @staticmethod
    def test_all_val_null(s):
        a = s.to_numpy()
        return (a == 0).all()
    ######################
    @staticmethod
    def get_polycoords(geopandasrow):
        &#34;&#34;&#34;
        Take a row of a geopandas as an input (i.e : for index, row in geopdwd.iterrows():...)
            and returns a tuple (if the geometry is a Polygon) or a list (if the geometry is a multipolygon)
            of an exterior.coords
        &#34;&#34;&#34;
        geometry = geopandasrow[&#39;geometry&#39;]
        all = []
        if geometry.type == &#39;Polygon&#39;:
            return list(geometry.exterior.coords)
        if geometry.type == &#39;MultiPolygon&#39;:
            for ea in geometry.geoms:
                all.append(list(ea.exterior.coords))
            return all
    ######################
    @staticmethod
    def wgs84_to_web_mercator(tuple_xy):
        &#34;&#34;&#34;
        Take a tuple (longitude,latitude) from a coordinate reference system crs=EPSG:4326
         and converts it to a  longitude/latitude tuple from to Web Mercator format
        &#34;&#34;&#34;
        k = 6378137
        x = tuple_xy[0] * (k * np.pi / 180.0)
        if tuple_xy[1] == -90:
            lat = -89.99
        else:
            lat = tuple_xy[1]
        y = np.log(np.tan((90 + lat) * np.pi / 360.0)) * k
        return x, y
    ######################
    @staticmethod
    def rollerJS():
        return CustomJSHover(code=&#34;&#34;&#34;
                var value;
                 //   if(Math.abs(value)&gt;100000 || Math.abs(value)&lt;0.001)
                 //       return value.toExponential(2);
                 //   else
                 //       return value.toFixed(2);
                 if(value&gt;10000 || value &lt;0.01)
                    value =  Number.parseFloat(value).toExponential(2);
                 else
                     value = Number.parseFloat(value).toFixed(2);
                return value.toString();
                /*  var s = value;
                  var s0=s;
                  var sp1=s.split(&#34;.&#34;);
                  var p1=sp1[0].length
                  if (sp1.length&gt;1) {
                    var sp2=s.split(&#34;e&#34;);
                    var p2=sp2[0].length
                    var p3=p2
                    while(s[p2-1]==&#34;0&#34; &amp;&amp; p2&gt;p1) {
                        p2=p2-1;
                    }
                    s=s0.substring(0,p2)+s0.substring(p3,s0.length);
                  }
                  if (s.split(&#34;.&#34;)[0].length==s.length-1) {
                    s=s.substring(0,s.length-1);
                  }
                  return s;*/
                &#34;&#34;&#34;)
    ######################
    @staticmethod
    def sparkline(data, figsize=(0.5, 0.5), **kwags):
        &#34;&#34;&#34;
        Returns a HTML image tag containing a base64 encoded sparkline style plot
        &#34;&#34;&#34;
        data = list(data)
        fig, ax = plt.subplots(1, 1, figsize=figsize, **kwags)
        ax.patch.set_alpha(0.3)
        ax.plot(data)
        for k,v in ax.spines.items():
            v.set_visible(False)
        ax.set_xticks([])
        ax.set_yticks([])
        plt.plot(len(data) - 1, data[len(data) - 1], &#39;r.&#39;)

        #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
        img = BytesIO()
        plt.savefig(img)
        img.seek(0)
        plt.close()
        return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())
    ###################### END Static Methods ##################
    @staticmethod
    def spiral(data, figsize=(0.5, 0.5), **kwags):
        &#34;&#34;&#34;
        Returns a HTML image tag containing a base64 encoded spiral style plot
        https://github.com/emilienschultz/researchnotebooks/blob/master/20220116%20-%20Visualisation%20polaire%20cas%20COVID-19.ipynb
        &#34;&#34;&#34;
        data[&#34;date&#34;] = pd.to_datetime(data[&#34;date&#34;])
        # Utiliser des méthodes de l&#39;objet date de Pandas pour créer de nouvelles colonnes
        data[&#34;dayofyear&#34;] = data[&#34;date&#34;].dt.dayofyear # j&#39;ai cherché comment faire dayofyear et il se trouve qu&#39;il y a une fonction
        data[&#34;year&#34;] = data[&#34;date&#34;].dt.year

        K = 2*data[&#39;cases&#39;].max()
        data[&#34;dayofyear_angle&#34;] = data[&#34;dayofyear&#34;]*2 * np.pi/365 # gérer plus finement l&#39;année bissextile
        data[&#34;r_baseline&#34;] = data.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)

        E = 8 # facteur d&#39;expansion des données
        data[&#34;r_cas_sup&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] + E*x[&#34;cases&#34;],axis=1)
        data[&#34;r_cas_inf&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] - E*x[&#34;cases&#34;],axis=1)

        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: &#39;polar&#39;},figsize=(1,1))

        #ax.set_xticklabels([&#39;     january&#39;, &#39;&#39;, &#39;april&#39;, &#39;&#39;, &#39;july    &#39;, &#39;&#39;, &#39;october&#39;, &#39;&#39;])
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_baseline&#34;])
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;black&#34;)
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;black&#34;)

        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
        ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)

        ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
        ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)
        ax.set_rticks([])
        ax.grid(False)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
        img = BytesIO()
        plt.savefig(img)
        img.seek(0)
        plt.close()
        return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="coa.display.CocoDisplay.bokeh_legend"><code class="name flex">
<span>def <span class="ident">bokeh_legend</span></span>(<span>bkfigure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def bokeh_legend(bkfigure):
    toggle_legend_js = CustomJS(args=dict(leg=bkfigure.legend[0]),
                                code=&#34;&#34;&#34;
    if(leg.visible)
    {
        leg.visible = false;
    }
    else
    {
        leg.visible = true;
    }
    &#34;&#34;&#34;)
    bkfigure.js_on_event(events.DoubleTap, toggle_legend_js)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.changeto_nonan_date"><code class="name flex">
<span>def <span class="ident">changeto_nonan_date</span></span>(<span>df=None, when_end=None, field=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def changeto_nonan_date(df=None, when_end=None, field=None):
    if not isinstance(when_end, dt.date):
        raise CoaTypeError(&#39; Not a valid data ... &#39;)

    boolval = True
    j = 0
    while (boolval):
        boolval = df.loc[df.date == (when_end - dt.timedelta(days=j))][field].dropna().empty
        j += 1
    if j &gt; 1:
        verb(str(when_end) + &#39;: all the value seems to be nan! I will find an other previous date.\n&#39; +
             &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
    return when_end - dt.timedelta(days=j - 1)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.changeto_nonull_date"><code class="name flex">
<span>def <span class="ident">changeto_nonull_date</span></span>(<span>df=None, when_end=None, field=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def changeto_nonull_date(df=None,when_end = None, field=None):
    if not isinstance(when_end, dt.date):
        raise CoaTypeError(&#39; Not a valid data ... &#39;)
    boolval = True
    j = 0
    #df = df.fillna(0)
    if all(df[field] == 0):
        print(&#39;all value is null for all date !&#39;)
        return when_end
    else:
        while(boolval):
            boolval = all(v == 0. or np.isnan(v) for v in df.loc[df.date == (when_end - dt.timedelta(days=j))][field].values)
            j += 1
        if j &gt; 1:
            verb(str(when_end) + &#39;: all the value seems to be 0! I will find an other previous date.\n&#39; +
                 &#39;Here the date I will take: &#39; + str(when_end - dt.timedelta(days=j - 1)))
        return when_end - dt.timedelta(days=j - 1)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.convert_tile"><code class="name flex">
<span>def <span class="ident">convert_tile</span></span>(<span>tilename, which='bokeh')</span>
</code></dt>
<dd>
<div class="desc"><p>Return tiles url according to folium or bokeh resquested</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_tile(tilename, which = &#39;bokeh&#39;):
    &#39;&#39;&#39; Return tiles url according to folium or bokeh resquested&#39;&#39;&#39;
    tile = &#39;openstreet&#39;
    if tilename == &#39;openstreet&#39;:
        if which == &#39;folium&#39;:
            tile = r&#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#39;
        else:
            tile = r&#39;http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png&#39;
    elif tilename == &#39;positron&#39;:
        print(&#39;Problem with positron tile (huge http resquest need to check), esri is then used ...&#39;)
        tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
    #    tile = &#39;https://tiles.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png&#39;
    elif tilename == &#39;esri&#39;:
        tile = r&#39;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}.png&#39;
    elif tilename == &#39;stamen&#39;:
        tile = r&#39;http://tile.stamen.com/toner/{z}/{x}/{y}.png&#39;
    else:
        print(&#39;Don\&#39;t know you tile ... take default one: &#39;)
    return tile</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.dict_shorten_loc"><code class="name flex">
<span>def <span class="ident">dict_shorten_loc</span></span>(<span>toshort)</span>
</code></dt>
<dd>
<div class="desc"><p>return a shorten name location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict_shorten_loc(toshort):
    &#39;&#39;&#39;
        return a shorten name location
    &#39;&#39;&#39;
    s = []
    if type(toshort) == np.ndarray:
        toshort = list(toshort)
        toshort = [toshort]
        s = &#39;&#39;
    elif type(toshort) == str:
        toshort = [toshort]
        s = &#39;&#39;
    #if type(toshort) != list:
    #    print(&#39;That is weird ...&#39;, toshort, &#39;not str nor list&#39;)
    for val in toshort:
        if not isinstance(val,str):
            val= str(val)
        if type(val) == list:
            val = val[0]
        if val.find(&#39;,&#39;) == -1:
            A = val
        else:
            txt = val.split(&#39;,&#39;)
            if len(txt[0]) &lt; 4 and len(txt[-1]) &lt; 4:
                A = [txt[0] + &#39;...&#39; + txt[-1]]
            else:
                A = txt[0][:5] + &#39;...&#39; + txt[-1][-5:]
        if type(s) == list:
            s.append(A)
        else:
            s = A
        if isinstance(s, list):
            s=s[0]
    return s</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.get_polycoords"><code class="name flex">
<span>def <span class="ident">get_polycoords</span></span>(<span>geopandasrow)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a row of a geopandas as an input (i.e : for index, row in geopdwd.iterrows():&hellip;)
and returns a tuple (if the geometry is a Polygon) or a list (if the geometry is a multipolygon)
of an exterior.coords</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_polycoords(geopandasrow):
    &#34;&#34;&#34;
    Take a row of a geopandas as an input (i.e : for index, row in geopdwd.iterrows():...)
        and returns a tuple (if the geometry is a Polygon) or a list (if the geometry is a multipolygon)
        of an exterior.coords
    &#34;&#34;&#34;
    geometry = geopandasrow[&#39;geometry&#39;]
    all = []
    if geometry.type == &#39;Polygon&#39;:
        return list(geometry.exterior.coords)
    if geometry.type == &#39;MultiPolygon&#39;:
        for ea in geometry.geoms:
            all.append(list(ea.exterior.coords))
        return all</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.get_utcdate"><code class="name flex">
<span>def <span class="ident">get_utcdate</span></span>(<span>date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_utcdate(date):
    return (date - dt.date(1970, 1, 1)).total_seconds() * 1000.</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.min_max_range"><code class="name flex">
<span>def <span class="ident">min_max_range</span></span>(<span>a_min, a_max)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a cleverly rounded min and max giving raw min and raw max of data.
Usefull for hist range and colormap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def min_max_range(a_min, a_max):
    &#34;&#34;&#34; Return a cleverly rounded min and max giving raw min and raw max of data.
    Usefull for hist range and colormap
    &#34;&#34;&#34;
    min_p = 0
    max_p = 0
    if a_min != 0:
        min_p = math.floor(math.log10(math.fabs(a_min)))  # power
    if a_max != 0:
        max_p = math.floor(math.log10(math.fabs(a_max)))

    if a_min == 0:
        if a_max == 0:
            p = 0
        else:
            p = max_p
    else:
        if a_max == 0:
            p = min_p
        else:
            p = max(min_p, max_p)

    if a_min != 0:
        min_r = math.floor(a_min / 10 ** (p - 1)) * 10 ** (p - 1)  # min range rounded
    else:
        min_r = 0

    if a_max != 0:
        max_r = math.ceil(a_max / 10 ** (p - 1)) * 10 ** (p - 1)
    else:
        max_r = 0

    if min_r == max_r:
        if min_r == 0:
            min_r = -1
            max_r = 1
            k = 0
        elif max_r &gt; 0:
            k = 0.1
        else:
            k = -0.1
        max_r = (1 + k) * max_r
        min_r = (1 - k) * min_r

    return (min_r, max_r)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.rollerJS"><code class="name flex">
<span>def <span class="ident">rollerJS</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def rollerJS():
    return CustomJSHover(code=&#34;&#34;&#34;
            var value;
             //   if(Math.abs(value)&gt;100000 || Math.abs(value)&lt;0.001)
             //       return value.toExponential(2);
             //   else
             //       return value.toFixed(2);
             if(value&gt;10000 || value &lt;0.01)
                value =  Number.parseFloat(value).toExponential(2);
             else
                 value = Number.parseFloat(value).toFixed(2);
            return value.toString();
            /*  var s = value;
              var s0=s;
              var sp1=s.split(&#34;.&#34;);
              var p1=sp1[0].length
              if (sp1.length&gt;1) {
                var sp2=s.split(&#34;e&#34;);
                var p2=sp2[0].length
                var p3=p2
                while(s[p2-1]==&#34;0&#34; &amp;&amp; p2&gt;p1) {
                    p2=p2-1;
                }
                s=s0.substring(0,p2)+s0.substring(p3,s0.length);
              }
              if (s.split(&#34;.&#34;)[0].length==s.length-1) {
                s=s.substring(0,s.length-1);
              }
              return s;*/
            &#34;&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.save_map2png"><code class="name flex">
<span>def <span class="ident">save_map2png</span></span>(<span>map=None, pngfile='map.png')</span>
</code></dt>
<dd>
<div class="desc"><p>Save map as png geckodriver and PIL packages are needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_map2png(map=None, pngfile=&#39;map.png&#39;):
    &#34;&#34;&#34;
    Save map as png geckodriver and PIL packages are needed
    &#34;&#34;&#34;
    size = width_height_default[0], width_height_default[1]
    if pngfile:
        pngfile = pngfile
    img_data = map._to_png(5)
    img = Image.open(io.BytesIO(img_data))
    img.thumbnail(size, Image.ANTIALIAS)
    img.save(pngfile)
    print(pngfile, &#39; is now save ...&#39;)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.save_pandas_as_png"><code class="name flex">
<span>def <span class="ident">save_pandas_as_png</span></span>(<span>df=None, pngfile='pandas.png')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_pandas_as_png(df=None, pngfile=&#39;pandas.png&#39;):
    source = ColumnDataSource(df)
    df_columns = [df.index.name]
    df_columns.extend(df.columns.values)
    columns_for_table = []
    for column in df_columns:
        if column is not None:
            columns_for_table.append(TableColumn(field=column, title=column))
            # width_height_default
    data_table = DataTable(source=source, columns=columns_for_table,
                           height_policy=&#34;auto&#34;, width_policy=&#34;auto&#34;, index_position=None)
    export_png(data_table, filename=pngfile)</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.sparkline"><code class="name flex">
<span>def <span class="ident">sparkline</span></span>(<span>data, figsize=(0.5, 0.5), **kwags)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a HTML image tag containing a base64 encoded sparkline style plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sparkline(data, figsize=(0.5, 0.5), **kwags):
    &#34;&#34;&#34;
    Returns a HTML image tag containing a base64 encoded sparkline style plot
    &#34;&#34;&#34;
    data = list(data)
    fig, ax = plt.subplots(1, 1, figsize=figsize, **kwags)
    ax.patch.set_alpha(0.3)
    ax.plot(data)
    for k,v in ax.spines.items():
        v.set_visible(False)
    ax.set_xticks([])
    ax.set_yticks([])
    plt.plot(len(data) - 1, data[len(data) - 1], &#39;r.&#39;)

    #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
    img = BytesIO()
    plt.savefig(img)
    img.seek(0)
    plt.close()
    return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.spiral"><code class="name flex">
<span>def <span class="ident">spiral</span></span>(<span>data, figsize=(0.5, 0.5), **kwags)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a HTML image tag containing a base64 encoded spiral style plot
<a href="https://github.com/emilienschultz/researchnotebooks/blob/master/20220116%20-%20Visualisation%20polaire%20cas%20COVID-19.ipynb">https://github.com/emilienschultz/researchnotebooks/blob/master/20220116%20-%20Visualisation%20polaire%20cas%20COVID-19.ipynb</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spiral(data, figsize=(0.5, 0.5), **kwags):
    &#34;&#34;&#34;
    Returns a HTML image tag containing a base64 encoded spiral style plot
    https://github.com/emilienschultz/researchnotebooks/blob/master/20220116%20-%20Visualisation%20polaire%20cas%20COVID-19.ipynb
    &#34;&#34;&#34;
    data[&#34;date&#34;] = pd.to_datetime(data[&#34;date&#34;])
    # Utiliser des méthodes de l&#39;objet date de Pandas pour créer de nouvelles colonnes
    data[&#34;dayofyear&#34;] = data[&#34;date&#34;].dt.dayofyear # j&#39;ai cherché comment faire dayofyear et il se trouve qu&#39;il y a une fonction
    data[&#34;year&#34;] = data[&#34;date&#34;].dt.year

    K = 2*data[&#39;cases&#39;].max()
    data[&#34;dayofyear_angle&#34;] = data[&#34;dayofyear&#34;]*2 * np.pi/365 # gérer plus finement l&#39;année bissextile
    data[&#34;r_baseline&#34;] = data.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)

    E = 8 # facteur d&#39;expansion des données
    data[&#34;r_cas_sup&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] + E*x[&#34;cases&#34;],axis=1)
    data[&#34;r_cas_inf&#34;] = data.apply(lambda x : x[&#34;r_baseline&#34;] - E*x[&#34;cases&#34;],axis=1)

    fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: &#39;polar&#39;},figsize=(1,1))

    #ax.set_xticklabels([&#39;     january&#39;, &#39;&#39;, &#39;april&#39;, &#39;&#39;, &#39;july    &#39;, &#39;&#39;, &#39;october&#39;, &#39;&#39;])
    ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_baseline&#34;])
    ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;black&#34;)
    ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;black&#34;)

    ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
    ax.plot(data[&#34;dayofyear_angle&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)

    ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_sup&#34;],color=&#34;lightblue&#34;)
    ax.fill_between(data[&#34;dayofyear_angle&#34;],data[&#34;r_baseline&#34;], data[&#34;r_cas_inf&#34;],color=&#34;lightblue&#34;)
    ax.set_rticks([])
    ax.grid(False)
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    #ax.fill_between(range(len(data)), data, len(data)*[min(data)], color=&#39;green&#39;,alpha=0.1)
    img = BytesIO()
    plt.savefig(img)
    img.seek(0)
    plt.close()
    return &#39;data:image/png;base64,&#39; + &#34;{}&#34;.format(base64.b64encode(img.read()).decode())</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.test_all_val_null"><code class="name flex">
<span>def <span class="ident">test_all_val_null</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def test_all_val_null(s):
    a = s.to_numpy()
    return (a == 0).all()</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.wgs84_to_web_mercator"><code class="name flex">
<span>def <span class="ident">wgs84_to_web_mercator</span></span>(<span>tuple_xy)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a tuple (longitude,latitude) from a coordinate reference system crs=EPSG:4326
and converts it to a
longitude/latitude tuple from to Web Mercator format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def wgs84_to_web_mercator(tuple_xy):
    &#34;&#34;&#34;
    Take a tuple (longitude,latitude) from a coordinate reference system crs=EPSG:4326
     and converts it to a  longitude/latitude tuple from to Web Mercator format
    &#34;&#34;&#34;
    k = 6378137
    x = tuple_xy[0] * (k * np.pi / 180.0)
    if tuple_xy[1] == -90:
        lat = -89.99
    else:
        lat = tuple_xy[1]
    y = np.log(np.tan((90 + lat) * np.pi / 360.0)) * k
    return x, y</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="coa.display.CocoDisplay.add_columns_for_pie_chart"><code class="name flex">
<span>def <span class="ident">add_columns_for_pie_chart</span></span>(<span>self, df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_columns_for_pie_chart(self,df,column_name):
    df = df.copy()
    column_sum = df[column_name].sum()
    df[&#39;percentage&#39;] = df[column_name]/column_sum
    percentages = [0]  + df[&#39;percentage&#39;].cumsum().tolist()
    df[&#39;angle&#39;] = (df[column_name]/column_sum)*2 * np.pi
    df[&#39;starts&#39;] = [p * 2 * np.pi for p in percentages[:-1]]
    df[&#39;ends&#39;] = [p * 2 * np.pi for p in percentages[1:]]
    df[&#39;diff&#39;] = (df[&#39;ends&#39;] - df[&#39;starts&#39;])
    df[&#39;middle&#39;] = df[&#39;starts&#39;]+np.abs(df[&#39;ends&#39;]-df[&#39;starts&#39;])/2.
    df[&#39;cos&#39;] = np.cos(df[&#39;middle&#39;]) * 0.9
    df[&#39;sin&#39;] = np.sin(df[&#39;middle&#39;]) * 0.9

    df[&#39;text_size&#39;] = &#39;8pt&#39;
    df[&#39;textdisplayed&#39;] = df[&#39;permanentdisplay&#39;].str.pad(36, side = &#34;left&#34;)
    locale.setlocale(locale.LC_ALL, &#39;en_US&#39;)
    df[&#39;textdisplayed2&#39;] = [ locale.format(&#34;%d&#34;, i, grouping=True)\
            for i in df[column_name]]
    #df[&#39;textdisplayed2&#39;] = df[column_name].astype(str) #[i.str for i in df[column_name]]
    df[&#39;textdisplayed2&#39;] = df[&#39;textdisplayed2&#39;].str.pad(26, side = &#34;left&#34;)
    #df[&#39;textdisplayed2&#39;]  = df[column_name].str.pad(26, side = &#34;left&#34;)
    df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed&#39;]=&#39;&#39;
    df.loc[df[&#39;diff&#39;] &lt;= np.pi/20,&#39;textdisplayed2&#39;]=&#39;&#39;
    df[&#39;percentage&#39;] = 100.*df[&#39;percentage&#39;]
    return df</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decohistomap"><code class="name flex">
<span>def <span class="ident">decohistomap</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator function used for histogram and map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decohistomap(func):
    &#34;&#34;&#34;
    Decorator function used for histogram and map
    &#34;&#34;&#34;
    @wraps(func)
    def inner_hm(self, input = None, input_field = None, **kwargs):
        tile = kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])

        maplabel = kwargs.get(&#39;maplabel&#39;, None)
        if not isinstance(maplabel,list):
                maplabel=[maplabel]
        #if maplabel:
        #    maplabel = maplabel

        if &#39;map&#39; in func.__name__:
            kwargs[&#39;maplabel&#39;] = maplabel

        orientation = kwargs.get(&#39;orientation&#39;, self.dvisu_default[&#39;orientation&#39;])
        cursor_date = kwargs.get(&#39;cursor_date&#39;, None)
        #if orientation:
        #    kwargs[&#39;orientation&#39;] = orientation
        #kwargs[&#39;cursor_date&#39;] = kwargs.get(&#39;cursor_date&#39;,  self.dvisu_default[&#39;cursor_date&#39;])
        if isinstance(input[&#39;location&#39;].iloc[0],list):
            input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
            input = input.explode(&#39;location&#39;)
        else:
            input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

        uniqloc = input.clustername.unique()

        geopdwd = input
        if maplabel and &#39;unsorted&#39; in maplabel:
            pass
        else:
            geopdwd = geopdwd.sort_values(by=input_field, ascending = False).reset_index(drop=True)

        started = geopdwd.date.min()
        ended = geopdwd.date.max()
        if cursor_date:
            date_slider = DateSlider(title = &#34;Date: &#34;, start = started, end = ended,
                                 value = ended, step=24 * 60 * 60 * 1000, orientation = orientation)
            #wanted_date = date_slider.value_as_datetime.date()

        #if func.__name__ == &#39;pycoa_mapfolium&#39; or func.__name__ == &#39;pycoa_map&#39; or func.__name__ == &#39;innerdecomap&#39; or func.__name__ == &#39;innerdecopycoageo&#39;:
        if func.__name__ in [&#39;pycoa_mapfolium&#39;,&#39;pycoa_map&#39;,&#39;pycoageo&#39; ,&#39;pycoa_pimpmap&#39;]:
            if isinstance(input.location.to_list()[0],list):
                geom = self.location_geometry
                geodic={loc:geom.loc[geom.location==loc][&#39;geometry&#39;].values[0] for loc in geopdwd.location.unique()}
                geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(geodic)
            else:
                geopdwd = pd.merge(geopdwd, self.location_geometry, on=&#39;location&#39;)

            kwargs[&#39;tile&#39;] = tile
            if self.iso3country in [&#39;USA&#39;]:#[&#39;FRA&#39;,&#39;USA&#39;]
                geo = copy.deepcopy(self.geo)
                d = geo._list_translation
                if func.__name__ != &#39;pycoa_mapfolium&#39;:
                    if any(i in list(geopdwd.codelocation.unique()) for i in d.keys()) \
                    or any(True for i in d.keys() if &#39;&#39;.join(list(geopdwd.codelocation.unique())).find(i)!=-1):
                        geo.set_dense_geometry()
                        kwargs.pop(&#39;tile&#39;)
                    else:
                        geo.set_main_geometry()
                        d = {}
                    new_geo = geo.get_data()[[&#39;name_&#39;+self.granularity,&#39;geometry&#39;]]
                    new_geo = new_geo.rename(columns={&#39;name_&#39;+self.granularity:&#39;location&#39;})
                    new_geo = new_geo.set_index(&#39;location&#39;)[&#39;geometry&#39;].to_dict()

                    geopdwd[&#39;geometry&#39;] = geopdwd[&#39;location&#39;].map(new_geo)
            geopdwd = gpd.GeoDataFrame(geopdwd, geometry=geopdwd.geometry, crs=&#34;EPSG:4326&#34;)

        if func.__name__ == &#39;pycoa_histo&#39;:
            pos = {}
            new = pd.DataFrame()
            n = 0
            for i in uniqloc:
                perloc = geopdwd.loc[geopdwd.clustername == i]
                if all(perloc != 0):
                    pos = perloc.index[0]
                    if new.empty:
                        new = perloc
                    else:
                        new = new.append(perloc)
                    n += 1
            geopdwd = new.reset_index(drop=True)
        if cursor_date:
            date_slider = date_slider
        else:
            date_slider = None
        kwargs[&#39;date_slider&#39;] = date_slider
        return func(self, geopdwd, input_field, **kwargs)
    return inner_hm</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decohistopie"><code class="name flex">
<span>def <span class="ident">decohistopie</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decohistopie(func):
    @wraps(func)
    def inner_decohistopie(self, geopdwd, input_field, **kwargs):
        &#34;&#34;&#34;
        Decorator for
        Horizontal histogram &amp; Pie Chart
        &#34;&#34;&#34;
        geopdwd[&#39;cases&#39;] = geopdwd[input_field]
        maplabel = kwargs.get(&#39;maplabel&#39;,None)
        plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
        plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

        geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filter = geopdwd_filter.reset_index(drop = True)
        geopdwd_filter[&#39;cases&#39;] = geopdwd_filter[input_field]
        cursor_date = kwargs.get(&#39;cursor_date&#39;,self.dvisu_default[&#39;cursor_date&#39;])
        date_slider = kwargs[&#39;date_slider&#39;]
        my_date = geopdwd.date.unique()
        dico_utc = {i: DateSlider(value=i).value for i in my_date}
        geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
        #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
        #geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])
        geopdwd = geopdwd.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
        geopdwd_filter = geopdwd_filter.drop_duplicates([&#34;date&#34;,&#34;clustername&#34;])
        locunique = geopdwd_filter.clustername.unique()#geopdwd_filtered.location.unique()
        geopdwd_filter = geopdwd_filter.copy()
        nmaxdisplayed = MAXCOUNTRIESDISPLAYED


        if len(locunique) &gt;= nmaxdisplayed :#and func.__name__ != &#39;pycoa_pie&#39; :
            if func.__name__ != &#39;pycoa_pie&#39; :
                geopdwd_filter = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed])]
            else:
                geopdwd_filter_first = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[:nmaxdisplayed-1])]
                geopdwd_filter_other = geopdwd_filter.loc[geopdwd_filter.clustername.isin(locunique[nmaxdisplayed-1:])]
                geopdwd_filter_other = geopdwd_filter_other.groupby(&#39;date&#39;).sum()
                geopdwd_filter_other[&#39;location&#39;] = &#39;others&#39;
                geopdwd_filter_other[&#39;clustername&#39;] = &#39;others&#39;
                geopdwd_filter_other[&#39;codelocation&#39;] = &#39;others&#39;
                geopdwd_filter_other[&#39;permanentdisplay&#39;] = &#39;others&#39;
                geopdwd_filter_other[&#39;rolloverdisplay&#39;] = &#39;others&#39;
                geopdwd_filter_other[&#39;colors&#39;] = &#39;#FFFFFF&#39;

                geopdwd_filter = geopdwd_filter_first
                geopdwd_filter = geopdwd_filter.append(geopdwd_filter_other)
        if func.__name__ == &#39;pycoa_horizonhisto&#39; :
            #geopdwd_filter[&#39;bottom&#39;] = geopdwd_filter.index
            geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;cases&#39;]
            geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;cases&#39;]
            geopdwd_filter[&#39;left&#39;] = geopdwd_filter[&#39;left&#39;].apply(lambda x: 0 if x &gt; 0 else x)
            geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 0 if x &lt; 0 else x)

            n = len(geopdwd_filter.index)
            d =  plot_height / n
            ymax = plot_height

            geopdwd_filter[&#39;top&#39;] = [ymax*(n-i)/n + d/2   for i in range(n)]
            geopdwd_filter[&#39;bottom&#39;] = [ymax*(n-i)/n - d/2 for i in range(n)]
            geopdwd_filter[&#39;horihistotexty&#39;] = geopdwd_filter[&#39;bottom&#39;] + d/2
            geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
            if maplabel and &#39;label%&#39; in maplabel:
                geopdwd_filter[&#39;right&#39;] = geopdwd_filter[&#39;right&#39;].apply(lambda x: 100.*x)
                geopdwd_filter[&#39;horihistotextx&#39;] = geopdwd_filter[&#39;right&#39;]
                geopdwd_filter[&#39;horihistotext&#39;] = [str(round(i))+&#39;%&#39; for i in geopdwd_filter[&#39;right&#39;]]
            else:
                geopdwd_filter[&#39;horihistotext&#39;] = [ &#39;{:.3g}&#39;.format(float(i)) if float(i)&gt;1.e4 else round(float(i),2) for i in geopdwd_filter[&#39;right&#39;] ]
                geopdwd_filter[&#39;horihistotext&#39;] = [str(i) for i in geopdwd_filter[&#39;horihistotext&#39;]]
        if func.__name__ == &#39;pycoa_pie&#39; :
            geopdwd_filter = self.add_columns_for_pie_chart(geopdwd_filter,input_field)
            geopdwd = self.add_columns_for_pie_chart(geopdwd,input_field)
            if maplabel and &#39;label%&#39; in maplabel:
                geopdwd_filter[&#39;textdisplayed2&#39;] = geopdwd_filter[&#39;percentage&#39;]
                geopdwd[&#39;textdisplayed2&#39;] =  geopdwd[&#39;percentage&#39;]

        source = ColumnDataSource(data = geopdwd)
        input_filter = geopdwd_filter
        srcfiltered = ColumnDataSource(data = input_filter)
        max_value = max(input_filter[&#39;cases&#39;])
        min_value = min(input_filter[&#39;cases&#39;])
        min_value_gt0 = min(input_filter[input_filter[&#39;cases&#39;] &gt; 0][&#39;cases&#39;])
        panels = []
        for axis_type in self.ax_type:
            plot_width = kwargs[&#39;plot_width&#39;]
            plot_height = kwargs[&#39;plot_height&#39;]
            standardfig = self.standardfig( x_axis_type = axis_type,  x_range = (1.05*min_value, 1.05 * max_value),**kwargs)
            if maplabel and &#39;label%&#39; in maplabel:
                standardfig.x_range = Range1d(0.01, 1.2 * max_value*100)
                standardfig.xaxis.axis_label = &#39;percentage(%)&#39;
                standardfig.xaxis.formatter = BasicTickFormatter(use_scientific=False)
            else:
                standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
                standardfig.x_range = Range1d(0.01, 1.2 * max_value)
            if not input_filter[input_filter[input_field] &lt; 0.].empty:
                standardfig.x_range = Range1d(1.2 * min_value, 1.2 * max_value)

            if axis_type == &#34;log&#34;:
                if not input_filter[input_filter[input_field] &lt; 0.].empty:
                    print(&#39;Some value are negative, can\&#39;t display log scale in this context&#39;)
                else:
                    if func.__name__ == &#39;pycoa_horizonhisto&#39; :
                        if maplabel and &#39;label%&#39; in maplabel:
                            standardfig.x_range = Range1d(0.01, 50 * max_value*100)
                        else:
                            standardfig.x_range = Range1d(0.01, 50 * max_value)
                        srcfiltered.data[&#39;left&#39;] = [0.01] * len(srcfiltered.data[&#39;right&#39;])

            if func.__name__ == &#39;pycoa_pie&#39;:
                if not input_filter[input_filter[input_field] &lt; 0.].empty:
                    raise CoaKeyError(&#39;Some values are negative, can\&#39;t display a Pie chart, try histo by location&#39;)
                standardfig.plot_width = plot_height
                standardfig.plot_height = plot_height

            if date_slider:
                date_slider.width = int(0.8*plot_width)
                callback = CustomJS(args = dict(source = source,
                                              source_filter = srcfiltered,
                                              date_slider = date_slider,
                                              ylabel = standardfig.yaxis[0],
                                              title = standardfig.title,
                                              x_range = standardfig.x_range,
                                              x_axis_type = axis_type,
                                              figure = standardfig),
                        code = &#34;&#34;&#34;
                        var date_slide = date_slider.value;
                        var dates = source.data[&#39;date_utc&#39;];
                        var val = source.data[&#39;cases&#39;];
                        var loc = source.data[&#39;clustername&#39;];
                        //var loc = source.data[&#39;location&#39;];
                        var subregion = source.data[&#39;name_subregion&#39;];
                        var codeloc = source.data[&#39;codelocation&#39;];
                        var colors = source.data[&#39;colors&#39;];

                        var newval = [];
                        var newloc = [];
                        var newcolors = [];
                        var newcodeloc = [];
                        var newname_subregion = [];
                        var labeldic = {};
                        for (var i = 0; i &lt; dates.length; i++){
                        if (dates[i] == date_slide){
                            newval.push(parseFloat(val[i]));
                            newloc.push(loc[i]);
                            newcodeloc.push(codeloc[i]);
                            newcolors.push(colors[i]);
                            if(typeof subregion !== &#39;undefined&#39;)
                                newname_subregion.push(subregion[i]);

                            }
                        }
                        var len = source_filter.data[&#39;clustername&#39;].length;

                        var indices = new Array(len);
                        for (var i = 0; i &lt; len; i++) indices[i] = i;

                        indices.sort(function (a, b) { return newval[a] &gt; newval[b] ? -1 : newval[a] &lt; newval[b] ? 1 : 0; });
                        var orderval = [];
                        var orderloc = [];
                        var ordercodeloc = [];
                        var ordername_subregion = [];
                        var ordercolors = [];
                        var textdisplayed = [];
                        for (var i = 0; i &lt; len; i++)
                        {
                            orderval.push(newval[indices[i]]);
                            orderloc.push(newloc[indices[i]]);
                            ordercodeloc.push(newcodeloc[indices[i]]);

                            if(typeof subregion !== &#39;undefined&#39;)
                                ordername_subregion.push(newname_subregion[i]);
                            ordercolors.push(newcolors[indices[i]]);
                            //labeldic[len-indices[i]] = newcodeloc[indices[i]];
                            textdisplayed.push(newcodeloc[indices[i]].padStart(40,&#39; &#39;));
                        }


                        source_filter.data[&#39;cases&#39;] = orderval;
                        const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;
                        var tot = orderval.reduce(reducer);
                        var top = [];
                        var bottom = [];
                        var starts = [];
                        var ends = [];
                        var middle = [];
                        var text_x = [];
                        var text_y = [];
                        var r = 0.7;
                        var bthick = 0.95;
                        var cumul = 0.;
                        var percentage = [];
                        var angle = [];
                        var text_size = [];
                        var left_quad = [];
                        var right_quad = [];

                        for(var i = 0; i &lt; orderval.length; i++)
                        {
                            cumul += ((orderval[i] / tot) * 2 * Math.PI);
                            ends.push(cumul);
                            if(i==0)
                                starts.push(0);
                            else
                                starts.push(ends[i-1]);
                            middle.push((ends[i]+starts[i])/2);
                            text_x.push(r*Math.cos(middle[i]));
                            text_y.push(r*Math.sin(middle[i]));
                            percentage.push(String(100.*orderval[i] / tot).slice(0, 4));
                            angle.push((orderval[i] / tot) * 2 * Math.PI)
                            /*if ((ends[i]-starts[i]) &gt; 0.08*(2 * Math.PI))
                                text_size.push(&#39;10pt&#39;);
                            else
                                text_size.push(&#39;6pt&#39;);*/

                            //top.push((orderval.length-i) + bthick/2);
                            //bottom.push((orderval.length-i) - bthick/2);

                            if (isNaN(orderval[i])) orderval[i] = 0.;
                            if(orderval[i]&lt;=0.)
                            {
                                left_quad.push(orderval[i]);
                                right_quad.push(0.);
                            }
                            else
                            {
                                left_quad.push(0);
                                right_quad.push(orderval[i]);
                            }
                        }

                        source_filter.data[&#39;clustername&#39;] = orderloc;
                        source_filter.data[&#39;codelocation&#39;] = ordercodeloc;
                        //source_filter.data[&#39;colors&#39;] = ordercolors;

                        if(typeof subregion !== &#39;undefined&#39;)
                            source_filter.data[&#39;rolloverdisplay&#39;] = ordername_subregion;
                        else
                            source_filter.data[&#39;rolloverdisplay&#39;] = orderloc;

                        source_filter.data[&#39;ends&#39;] = ends;
                        source_filter.data[&#39;starts&#39;] = starts;
                        source_filter.data[&#39;middle&#39;] = middle;
                        source_filter.data[&#39;text_x&#39;] = text_x;
                        source_filter.data[&#39;text_y&#39;] = text_y;
                        //source_filter.data[&#39;text_size&#39;] = text_size;
                        source_filter.data[&#39;percentage&#39;] = percentage;
                        source_filter.data[&#39;angle&#39;] = angle;


                        source_filter.data[&#39;left&#39;] = left_quad;
                        source_filter.data[&#39;right&#39;] = right_quad;

                        var mid =[];
                        var ht = [];
                        var textdisplayed2 = [];

                        var n = right_quad.length;
                        var d = figure.plot_height / n;
                        var ymax = figure.plot_height;

                        for(i=0; i&lt;right_quad.length;i++){
                            top.push(parseInt(ymax*(n-i)/n+d/2));
                            bottom.push(parseInt(ymax*(n-i)/n-d/2));
                            mid.push(parseInt(ymax*(n-i)/n));
                            labeldic[parseInt(ymax*(n-i)/n)] = ordercodeloc[i];

                            ht.push(right_quad[i].toFixed(2).toString());
                            var a=new Intl.NumberFormat().format(right_quad[i])
                            textdisplayed2.push(a.toString().padStart(26,&#39; &#39;));
                            //textdisplayed2.push(right_quad[i].toFixed(2).toString().padStart(40,&#39; &#39;));

                        }
                        source_filter.data[&#39;top&#39;] = top;
                        source_filter.data[&#39;bottom&#39;] = bottom;

                        source_filter.data[&#39;horihistotextxy&#39;] =  mid;
                        source_filter.data[&#39;horihistotextx&#39;] =  right_quad;
                        source_filter.data[&#39;horihistotext&#39;] =  ht;
                        source_filter.data[&#39;permanentdisplay&#39;] = ordercodeloc;
                        source_filter.data[&#39;textdisplayed&#39;] = textdisplayed;
                        source_filter.data[&#39;textdisplayed2&#39;] = textdisplayed2;
                        var maxx = Math.max.apply(Math, right_quad);
                        var minx = Math.min.apply(Math, left_quad);

                        ylabel.major_label_overrides = labeldic;
                        console.log(labeldic);
                        x_range.end =  1.2 * maxx;
                        x_range.start =  1.05 * minx;
                        if(minx &gt;= 0){
                            x_range.start =  0.01;
                            source_filter.data[&#39;left&#39;] = Array(left_quad.length).fill(0.01);
                            }
                        var tmp = title.text;
                        tmp = tmp.slice(0, -11);
                        var dateconverted = new Date(date_slide);
                        var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                        var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                        var yyyy = dateconverted.getFullYear();
                        var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                        title.text = tmp + dmy+&#34;)&#34;;

                        source_filter.change.emit();
                    &#34;&#34;&#34;)
                date_slider.js_on_change(&#39;value&#39;, callback)
            cases_custom = CocoDisplay.rollerJS()
            if func.__name__ == &#39;pycoa_pie&#39; :
                standardfig.add_tools(HoverTool(
                    tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), (&#39;%&#39;,&#39;@percentage&#39;), ],
                    formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, &#39;%&#39;:&#39;printf&#39;},
                    point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
            else:
                standardfig.add_tools(HoverTool(
                    tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (input_field, &#39;@cases{0,0.0}&#39;), ],
                    formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{&#39; + &#39;cases&#39; + &#39;}&#39;: cases_custom, },
                    point_policy=&#34;snap_to_data&#34;))  # ,PanTool())
            panel = Panel(child = standardfig, title = axis_type)
            panels.append(panel)
        return func(self, srcfiltered, panels, date_slider)
    return inner_decohistopie</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decomap"><code class="name flex">
<span>def <span class="ident">decomap</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decomap(func):
    @wraps(func)
    def innerdecomap(self, geopdwd, geopdwd_filtered, **kwargs):
        title = kwargs.get(&#39;title&#39;, None)
        maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
        tile =  kwargs.get(&#39;tile&#39;, None)
        if tile:
            tile = CocoDisplay.convert_tile(tile, &#39;bokeh&#39;)

        uniqloc = list(geopdwd_filtered.clustername.unique())
        dfLabel = pd.DataFrame()
        sourcemaplabel = ColumnDataSource(dfLabel)
        if maplabel or func.__name__ == &#39;pycoa_pimpmap&#39;:
            locsum = geopdwd_filtered.clustername.unique()
            numberpercluster = geopdwd_filtered[&#39;clustername&#39;].value_counts().to_dict()
            sumgeo = geopdwd_filtered.copy()
            sumgeo[&#39;geometry&#39;] = sumgeo[&#39;geometry&#39;].buffer(0.001) #needed with geopandas 0.10.2
            sumgeo = sumgeo.dissolve(by=&#39;clustername&#39;, aggfunc=&#39;sum&#39;).reset_index()
            sumgeo[&#39;nb&#39;] = sumgeo[&#39;clustername&#39;].map(numberpercluster)
            #print(geopdwd_filtered.loc[geopdwd_filtered.clustername==&#39;Île-de-France&#39;].reset_index(drop=True).explode(index_parts=False))
            centrosx = sumgeo[&#39;geometry&#39;].centroid.x
            centrosy = sumgeo[&#39;geometry&#39;].centroid.y
            cases = sumgeo[&#39;cases&#39;]/sumgeo[&#39;nb&#39;]
            dfLabel=pd.DataFrame({&#39;clustername&#39;:sumgeo.clustername,&#39;centroidx&#39;:centrosx,&#39;centroidy&#39;:centrosy,&#39;cases&#39;:cases,&#39;geometry&#39;:sumgeo[&#39;geometry&#39;]})

            if &#39;spark&#39; in maplabel:
                sparkos = {i: CocoDisplay.sparkline(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                            (geopdwd.date &gt;= self.when_beg) &amp;
                            (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[&#39;cases&#39;]) for i in locsum }
                dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)
            if &#39;spiral&#39; in maplabel:
                sparkos = {i: CocoDisplay.spiral(geopdwd.loc[ (geopdwd.clustername==i) &amp;
                            (geopdwd.date &gt;= self.when_beg) &amp;
                            (geopdwd.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)[[&#39;date&#39;,&#39;cases&#39;,&#39;clustername&#39;]]) for i in locsum }
                dfpimp = pd.DataFrame(list(sparkos.items()), columns=[&#39;clustername&#39;, &#39;pimpmap&#39;])
                dfLabel=pd.merge(dfLabel,dfpimp,on=[&#39;clustername&#39;],how=&#34;inner&#34;)

            dfLabel[&#39;cases&#39;] = dfLabel[&#39;cases&#39;].round(2)
            # Converting links to html tags
            if &#39;label%&#39; in maplabel:
                dfLabel[&#39;cases&#39;] = [str(round(float(i*100),2))+&#39;%&#39; for i in dfLabel[&#39;cases&#39;]]
            else:
                dfLabel[&#39;cases&#39;]=[str(i) for i in dfLabel[&#39;cases&#39;]]
            sourcemaplabel = ColumnDataSource(dfLabel.drop(columns=&#39;geometry&#39;))
        minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds #self.boundary
        #if self.dbld[self.database_name][0] != &#39;WW&#39;:
        #    ratio = 0.05
        #    minx -= ratio*minx
        #    maxx += ratio*maxx
        #    miny -= ratio*miny
        #    maxy += ratio*maxy
        #if func.__name__ == &#39;pycoa_pimpmap&#39;:
        #    dico[&#39;titlebar&#39;]=tit[:-12]+&#39; [ &#39;+dico[&#39;when_beg&#39;].strftime(&#39;%d/%m/%Y&#39;)+ &#39;-&#39;+ tit[-12:-1]+&#39;])&#39;

        kwargs[&#39;plot_width&#39;]=kwargs[&#39;plot_height&#39;]
        x_range=(minx,maxx)
        y_range=(miny,maxy)
        if func.__name__ == &#39;pycoa_pimpmap&#39;:
            standardfig = self.standardfig(x_range=x_range, y_range=y_range, x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)
        else:
            standardfig = self.standardfig(x_axis_type=&#34;mercator&#34;, y_axis_type=&#34;mercator&#34;,**kwargs,match_aspect=True)

        if tile:
            wmt = WMTSTileSource(
                        url=tile)
            standardfig.add_tile(wmt)
        else:
            standardfig.background_fill_color = &#34;lightgrey&#34;

        geopdwd_filtered = geopdwd_filtered[[&#39;cases&#39;,&#39;geometry&#39;,&#39;location&#39;,&#39;clustername&#39;,&#39;codelocation&#39;,&#39;rolloverdisplay&#39;]]
        if not dfLabel.empty:
            geopdwd_filtered = geopdwd_filtered.drop(columns = &#39;geometry&#39;)
            geopdwd_filtered = pd.merge(geopdwd_filtered, dfLabel[[&#39;clustername&#39;,&#39;geometry&#39;]], on = &#39;clustername&#39;)
            geopdwd_filtered = geopdwd_filtered.drop_duplicates(subset = [&#39;clustername&#39;])
        if self.dbld[self.database_name][0] == &#39;BEL&#39; :
            reorder = list(geopdwd_filtered.location.unique())
            geopdwd_filtered = geopdwd_filtered.set_index(&#39;location&#39;)
            geopdwd_filtered = geopdwd_filtered.reindex(index = reorder)
            geopdwd_filtered = geopdwd_filtered.reset_index()

        if self.dbld[self.database_name][0] == &#39;GBR&#39; :
            geopdwd = geopdwd.loc[~geopdwd.cases.isnull()]
            geopdwd_filtered  = geopdwd_filtered.loc[~geopdwd_filtered.cases.isnull()]
        return func(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs)
    return innerdecomap</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decoplot"><code class="name flex">
<span>def <span class="ident">decoplot</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for plot purpose</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decoplot(func):
    &#34;&#34;&#34;
    decorator for plot purpose
    &#34;&#34;&#34;
    @wraps(func)
    def inner_plot(self, input = None, input_field = None, **kwargs):
        mode = kwargs.get(&#39;mode&#39;, None)
        if mode:
            mode = mode
        else:
            mode = self.dvisu_default[&#39;mode&#39;]
        if mode not in self.available_modes:
            raise CoaTypeError(&#39;Don\&#39;t know the mode wanted. So far:&#39; + str(self.available_modes))
        kwargs[&#39;mode&#39;] = mode

        if &#39;location&#39; in input.columns:
            location_ordered_byvalues = list(
                input.loc[input.date == self.when_end].sort_values(by=input_field, ascending=False)[&#39;clustername&#39;].unique())
            input = input.copy()  # needed to avoid warning
            input.loc[:,&#39;clustername&#39;] = pd.Categorical(input.clustername,
                                                   categories=location_ordered_byvalues, ordered=True)

            input = input.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;]).reset_index(drop = True)

            if func.__name__ != &#39;pycoa_scrollingmenu&#39; :
                if len(location_ordered_byvalues) &gt;= MAXCOUNTRIESDISPLAYED:
                    input = input.loc[input.clustername.isin(location_ordered_byvalues[:MAXCOUNTRIESDISPLAYED])]
            list_max = []
            for i in input_field:
                list_max.append(max(input.loc[input.clustername.isin(location_ordered_byvalues)][i]))
            if len([x for x in list_max if not np.isnan(x)]) &gt; 0:
                amplitude = (np.nanmax(list_max) - np.nanmin(list_max))
                if amplitude &gt; 10 ** 4:
                    self.ax_type.reverse()
            if func.__name__ == &#39;pycoa_scrollingmenu&#39; :
                if isinstance(input_field,list):
                    if len(input_field) &gt; 1:
                        print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
                    input_field = input_field[0]
                if self.dbld[self.database_name][1] == &#39;nation&#39; and self.dbld[self.database_name][0] != &#39;WW&#39;:
                    func.__name__ = &#39;pycoa_date_plot&#39;
        return func(self, input, input_field, **kwargs)
    return inner_plot</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decopycoageo"><code class="name flex">
<span>def <span class="ident">decopycoageo</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decopycoageo(func):
    @wraps(func)
    def innerdecopycoageo(self, geopdwd, input_field, **kwargs):
        geopdwd[&#39;cases&#39;] = geopdwd[input_field]
        geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
        geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
        geopdwd_filtered = gpd.GeoDataFrame(geopdwd_filtered, geometry=geopdwd_filtered.geometry, crs=&#34;EPSG:4326&#34;)
        geopdwd = geopdwd.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False])
        geopdwd_filtered = geopdwd_filtered.sort_values(by=[&#39;clustername&#39;, &#39;date&#39;], ascending = [True, False]).drop(columns=[&#39;date&#39;, &#39;colors&#39;])
        new_poly = []
        geolistmodified = dict()

        for index, row in geopdwd_filtered.iterrows():
            split_poly = []
            new_poly = []
            if row[&#39;geometry&#39;]:
                for pt in self.get_polycoords(row):
                    if type(pt) == tuple:
                        new_poly.append(CocoDisplay.wgs84_to_web_mercator(pt))
                    elif type(pt) == list:
                        shifted = []
                        for p in pt:
                            shifted.append(CocoDisplay.wgs84_to_web_mercator(p))
                        new_poly.append(sg.Polygon(shifted))
                    else:
                        raise CoaTypeError(&#34;Neither tuple or list don&#39;t know what to do with \
                            your geometry description&#34;)

                if type(new_poly[0]) == tuple:
                    geolistmodified[row[&#39;location&#39;]] = sg.Polygon(new_poly)
                else:
                    geolistmodified[row[&#39;location&#39;]] = sg.MultiPolygon(new_poly)
        ng = pd.DataFrame(geolistmodified.items(), columns=[&#39;location&#39;, &#39;geometry&#39;])
        geolistmodified = gpd.GeoDataFrame({&#39;location&#39;: ng[&#39;location&#39;], &#39;geometry&#39;: gpd.GeoSeries(ng[&#39;geometry&#39;])}, crs=&#34;epsg:3857&#34;)
        geopdwd_filtered = geopdwd_filtered.drop(columns=&#39;geometry&#39;)
        geopdwd_filtered = pd.merge(geolistmodified, geopdwd_filtered, on=&#39;location&#39;)
        #if kwargs[&#39;wanted_dates&#39;]:
        #    kwargs.pop(&#39;wanted_dates&#39;)
        return func(self, geopdwd, geopdwd_filtered, **kwargs)
    return innerdecopycoageo</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.decowrapper"><code class="name flex">
<span>def <span class="ident">decowrapper</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Main decorator it mainly deals with arg testings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decowrapper(func):
    &#39;&#39;&#39;
        Main decorator it mainly deals with arg testings
    &#39;&#39;&#39;
    @wraps(func)
    def wrapper(self, input = None, input_field = None, **kwargs):
        &#34;&#34;&#34;
        Parse a standard input, return :
            - pandas: with location keyword (eventually force a column named &#39;where&#39; to &#39;location&#39;)
            - kwargs:
                * keys = [plot_width, plot_width, title, when, title_temporal,bins, what, which]
        Note that method used only the needed variables, some of them are useless
        &#34;&#34;&#34;
        if not isinstance(input, pd.DataFrame):
            raise CoaTypeError(input + &#39;Must be a pandas, with pycoa structure !&#39;)

        kwargs_test(kwargs, self.alloptions, &#39;Bad args used in the display function.&#39;)
        when = kwargs.get(&#39;when&#39;, None)
        which = kwargs.get(&#39;which&#39;, input.columns[2])
        if input_field and &#39;cur_&#39; in input_field:
            what =  which
        else:
             # cumul is the default
            what = kwargs.get(&#39;what&#39;, which)

        if input_field is None:
            input_field = which

        if isinstance(input_field,list):
            test = input_field[0]
        else:
            test = input_field
        if input[[test,&#39;date&#39;]].isnull().values.all():
            raise CoaKeyError(&#39;All values for &#39;+ which + &#39; is nan nor empty&#39;)

        option = kwargs.get(&#39;option&#39;, None)
        bins = kwargs.get(&#39;bins&#39;, 10)
        title = kwargs.get(&#39;title&#39;, None)
        #textcopyright = kwargs.get(&#39;textcopyright&#39;, &#39;default&#39;)
        kwargs[&#39;plot_width&#39;] = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
        kwargs[&#39;plot_height&#39;] = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])

        if &#39;where&#39; in input.columns:
            input = input.rename(columns={&#39;where&#39;: &#39;location&#39;})

        if &#39;codelocation&#39; and &#39;clustername&#39; not in input.columns:
            input[&#39;codelocation&#39;] = input[&#39;location&#39;]
            input[&#39;clustername&#39;] = input[&#39;location&#39;]
            input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]
            input[&#39;permanentdisplay&#39;] = input[&#39;location&#39;]
        else:
            if self.granularity == &#39;nation&#39; :
                #input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;) if len(x)&lt; 10 else x[0]+&#39;...&#39;+x[-1] )
                input[&#39;permanentdisplay&#39;] = input.apply(lambda x: x.clustername if self.geo.get_GeoRegion().is_region(x.clustername) else str(x.codelocation), axis = 1)
            else:
                if self.granularity == &#39;subregion&#39; :
                    input = input.reset_index(drop=True)
                    if isinstance(input[&#39;codelocation&#39;][0],list):
                        input[&#39;codelocation&#39;] = input[&#39;codelocation&#39;].apply(lambda x: str(x).replace(&#34;&#39;&#34;, &#39;&#39;)\
                                                     if len(x)&lt;5 else &#39;[&#39;+str(x[0]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;,...,&#39;+str(x[-1]).replace(&#34;&#39;&#34;, &#39;&#39;)+&#39;]&#39;)

                    trad={}
                    cluster = input.clustername.unique()
                    if isinstance(input.location[0],list):
                       cluster = [i for i in cluster]
                    for i in cluster:
                        if i == self.namecountry:
                            input[&#39;permanentdisplay&#39;] = input.clustername #[self.dbld[self.database_name][2]]*len(input)
                        else:
                            if self.geo.is_region(i):
                                trad[i] = self.geo.is_region(i)
                            elif self.geo.is_subregion(i):
                                trad[i] = self.geo.is_subregion(i)#input.loc[input.clustername==i][&#39;codelocation&#39;].iloc[0]
                            else:
                                trad[i] = i
                            trad={k:(v[:3]+&#39;...&#39;+v[-3:] if len(v)&gt;8 else v) for k,v in trad.items()}
                            if &#39;,&#39; in input.codelocation[0]:
                                input[&#39;permanentdisplay&#39;] = input.clustername
                            else:
                                input[&#39;permanentdisplay&#39;] = input.codelocation#input.clustername.map(trad)
                elif self.granularity == &#39;region&#39; :
                    if all(i == self.namecountry for i in input.clustername.unique()):
                        input[&#39;permanentdisplay&#39;] = [self.namecountry]*len(input)
                    else:
                        input[&#39;permanentdisplay&#39;] = input.codelocation
            input[&#39;rolloverdisplay&#39;] = input[&#39;location&#39;]

        maplabel = kwargs.get(&#39;maplabel&#39;, None)
        if maplabel and &#39;unsorted&#39; in maplabel:
            pass
        else:
            input = input.sort_values(by=input_field, ascending = False).reset_index(drop=True)

        uniqloc = input.clustername.unique()

        if len(uniqloc) &lt; 5:
            colors = self.scolors
        else:
            colors = self.lcolors
        colors = itertools.cycle(colors)
        dico_colors = {i: next(colors) for i in uniqloc}

        input = input.copy()
        if not &#39;colors&#39; in input.columns:
            input.loc[:,&#39;colors&#39;] = input[&#39;clustername&#39;].map(dico_colors)#(pd.merge(input, country_col, on=&#39;location&#39;))

        if not isinstance(input_field, list):
              input_field = [input_field]
        else:
              input_field = input_field
        col2=which
        when_beg = input[[col2,&#39;date&#39;]].date.min()
        when_end = input[[col2,&#39;date&#39;]].date.max()

        if when:
            when_beg, when_end = extract_dates(when)
            if when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                when_end = input[[col2,&#39;date&#39;]].date.max()

            if when_beg == dt.date(1, 1, 1):
                when_beg = input[[col2,&#39;date&#39;]].date.min()

            if not isinstance(when_beg, dt.date):
                raise CoaNoData(&#34;With your current cuts, there are no data to plot.&#34;)

            if when_end &lt;= when_beg:
                print(&#39;Requested date below available one, take&#39;, when_beg)
                when_end = when_beg
            if when_beg &gt; input[[col2,&#39;date&#39;]].date.max() or when_end &gt; input[[col2,&#39;date&#39;]].date.max():
                raise CoaNoData(&#34;No available data after &#34;+str(input[[input_field[0],&#39;date&#39;]].date.max()))
        when_end_change = when_end

        for i in input_field:
            if input[i].isnull().all():
                raise CoaTypeError(&#34;Sorry all data are NaN for &#34; + i)
            else:
                when_end_change = min(when_end_change,CocoDisplay.changeto_nonull_date(input, when_end, i))

        if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
            if len(input_field) &gt; 1:
                print(str(input_field) + &#39; is dim = &#39; + str(len(input_field)) + &#39;. No effect with &#39; + func.__name__ + &#39;! Take the first input: &#39; + input_field[0])
            input_field = input_field[0]

        if when_end_change != when_end:
            when_end = when_end_change

        self.when_beg = when_beg
        self.when_end = when_end
        input = input.loc[(input[&#39;date&#39;] &gt;=  self.when_beg) &amp; (input[&#39;date&#39;] &lt;=  self.when_end)]

        title_temporal = &#39; (&#39; + &#39;between &#39; + when_beg.strftime(&#39;%d/%m/%Y&#39;) + &#39; and &#39; + when_end.strftime(&#39;%d/%m/%Y&#39;) + &#39;)&#39;
        if func.__name__ not in [&#39;pycoa_date_plot&#39;, &#39;pycoa_plot&#39;, &#39;pycoa_scrollingmenu&#39;, &#39;pycoa_spiral_plot&#39;,&#39;pycoa_yearly_plot&#39;]:
            title_temporal = &#39; (&#39; + when_end.strftime(&#39;%d/%m/%Y&#39;)  + &#39;)&#39;
        title_option=&#39;&#39;
        if option:
            if &#39;sumallandsmooth7&#39; in option:
                option.remove(&#39;sumallandsmooth7&#39;)
                option += [&#39;sumall&#39;,&#39;smooth7&#39;]
            title_option = &#39; (option: &#39; + str(option)+&#39;)&#39;

        input_field_tostring = str(input_field).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;).replace(&#39;\&#39;&#39;, &#39;&#39;)
        whichtitle = which
        if &#39;pop&#39; in input_field_tostring:
            whichtitle = input_field_tostring.replace(&#39;weekly &#39;,&#39;&#39;).replace(&#39;daily &#39;,&#39;&#39;)

        if &#39;daily&#39; in input_field_tostring:
            titlefig = whichtitle + &#39;, &#39; + &#39;day to day difference&#39; + title_option
        elif &#39;weekly&#39; in input_field_tostring:
            titlefig = whichtitle + &#39;, &#39; + &#39;week to week difference&#39; + title_option
        else:
            if &#39;cur_&#39; in  which or &#39;idx_&#39; in  which:
                #titlefig = which + &#39;, &#39; + &#39;current &#39; + which.replace(&#39;cur_&#39;,&#39;&#39;).replace(&#39;idx_&#39;,&#39;&#39;)+ title_option
                titlefig = whichtitle + &#39;, current value&#39; + title_option
            else:
                titlefig = whichtitle + &#39;, cumulative&#39;+ title_option

        if title:
            title = title
        else:
            title  = titlefig
        self.uptitle = title

        textcopyright = kwargs.get(&#39;textcopyright&#39;, None)
        if textcopyright:
            textcopyright = &#39;©pycoa.fr &#39; + textcopyright + title_temporal
            kwargs.pop(&#39;textcopyright&#39;)
        else:
            textcopyright = &#39;©pycoa.fr data from: {}&#39;.format(self.database_name)+&#39; &#39;+title_temporal

        self.subtitle = textcopyright
        kwargs[&#39;title&#39;] = title+title_temporal
        return func(self, input, input_field, **kwargs)
    return wrapper</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.get_listfigures"><code class="name flex">
<span>def <span class="ident">get_listfigures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_listfigures(self):
    return  self.listfigs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_date_plot"><code class="name flex">
<span>def <span class="ident">pycoa_date_plot</span></span>(<span>self, input=None, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a date plot according to arguments. See help(pycoa_date_plot).
Keyword Arguments</p>
<hr>
<ul>
<li>input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>guideline = False</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decoplot
def pycoa_date_plot(self, input = None, input_field = None, **kwargs):
    &#39;&#39;&#39;
    -----------------
    Create a date plot according to arguments. See help(pycoa_date_plot).
    Keyword arguments
    -----------------
    - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
    |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
    - input_field = if None take second element could be a list
    - plot_heigh= width_height_default[1]
    - plot_width = width_height_default[0]
    - title = None
    - textcopyright = default
    - mode = mouse
    - guideline = False
    - cursor_date = None if True
            - orientation = horizontal
    - when : default min and max according to the inpude DataFrame.
             Dates are given under the format dd/mm/yyyy.
             when format [dd/mm/yyyy : dd/mm/yyyy]
             if [:dd/mm/yyyy] min date up to
             if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
    panels = []
    listfigs = []
    cases_custom = CocoDisplay.rollerJS()
    if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
        input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
    for axis_type in self.ax_type:
        standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;,**kwargs)
        i = 0
        r_list=[]
        maxou=-1000
        lcolors = iter(self.lcolors)
        line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;,&#39;dashdot&#39;]
        for val in input_field:
            for loc in list(input.clustername.unique()):
                input_filter = input.loc[input.clustername == loc].reset_index(drop = True)

                src = ColumnDataSource(input_filter)
                leg = input_filter.clustername[0]
                #leg = input_filter.permanentdisplay[0]
                if len(input_field)&gt;1:
                    leg = input_filter.permanentdisplay[0] + &#39;, &#39; + val
                if len(list(input.clustername.unique())) == 1:
                    color = next(lcolors)
                else:
                    color = input_filter.colors[0]
                r = standardfig.line(x = &#39;date&#39;, y = val, source = src,
                                 color = color, line_width = 3,
                                 legend_label = leg,
                                 hover_line_width = 4, name = val, line_dash=line_style[i%4])
                r_list.append(r)
                maxou=max(maxou,np.nanmax(input_filter[val].values))
            i += 1
        for r in r_list:
            label = r.name
            tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
            formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
            hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
            standardfig.add_tools(hover)
            if guideline:
                cross= CrosshairTool()
                standardfig.add_tools(cross)

        if axis_type == &#39;linear&#39;:
            if maxou  &lt; 1e4 :
                standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

        standardfig.legend.label_text_font_size = &#34;12px&#34;
        panel = Panel(child=standardfig, title = axis_type)
        panels.append(panel)
        standardfig.legend.background_fill_alpha = 0.6

        standardfig.legend.location = &#34;top_left&#34;
        standardfig.legend.click_policy=&#34;hide&#34;
        standardfig.legend.label_text_font_size = &#39;8pt&#39;
        if len(input_field) &gt; 1 and len(input_field)*len(input.clustername.unique())&gt;16:
            standardfig.legend.visible=False
        standardfig.xaxis.formatter = DatetimeTickFormatter(
            days = [&#34;%d/%m/%y&#34;], months = [&#34;%d/%m/%y&#34;], years = [&#34;%b %Y&#34;])
        CocoDisplay.bokeh_legend(standardfig)
        listfigs.append(standardfig)
    self.set_listfigures(listfigs)
    tabs = Tabs(tabs = panels)
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_histo"><code class="name flex">
<span>def <span class="ident">pycoa_histo</span></span>(<span>self, geopdwd, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create 1D histogramme by value according to arguments.
See help(pycoa_histo).
Keyword Arguments</p>
<hr>
<ul>
<li>geopdwd : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
def pycoa_histo(self,  geopdwd, input_field = None, **kwargs):
    &#39;&#39;&#39;
        -----------------
        Create 1D histogramme by value according to arguments.
        See help(pycoa_histo).
        Keyword arguments
        -----------------
        - geopdwd : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - when : default min and max according to the inpude DataFrame.
                 Dates are given under the format dd/mm/yyyy.
                 when format [dd/mm/yyyy : dd/mm/yyyy]
                 if [:dd/mm/yyyy] min date up to
                 if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    geopdwd_filter = geopdwd.loc[geopdwd.date == self.when_end]
    geopdwd_filter = geopdwd_filter.reset_index(drop = True)

    input = geopdwd_filter.rename(columns = {&#39;cases&#39;: input_field})
    bins = kwargs.get(&#39;bins&#39;, None)

    if &#39;location&#39; in input.columns:
        uniqloc = list(input.clustername.unique())
        allval  = input.loc[input.clustername.isin(uniqloc)][[&#39;clustername&#39;, input_field,&#39;permanentdisplay&#39;]]
        min_val = allval[input_field].min()
        max_val = allval[input_field].max()

        if bins:
            bins = bins
        else:
            if len(uniqloc) == 1:
                bins = 2
                min_val = 0.
            else:
                bins = 11

        delta = (max_val - min_val ) / bins
        interval = [ min_val + i*delta for i in range(bins+1)]

        contributors = {  i : [] for i in range(bins+1)}
        for i in range(len(allval)):
            rank = bisect.bisect_left(interval, allval.iloc[i][input_field])
            if rank == bins+1:
                rank = bins
            contributors[rank].append(allval.iloc[i][&#39;clustername&#39;])

        colors = itertools.cycle(self.lcolors)
        lcolors = [next(colors) for i in range(bins+1)]
        contributors = dict(sorted(contributors.items()))
        frame_histo = pd.DataFrame({
                          &#39;left&#39;: [0]+interval[:-1],
                          &#39;right&#39;:interval,
                          &#39;middle_bin&#39;: [format((i+j)/2, &#34;.1f&#34;) for i,j in zip([0]+interval[:-1],interval)],
                          &#39;top&#39;: [len(i) for i in list(contributors.values())],
                          &#39;contributors&#39;: [&#39;, &#39;.join(i) for i in contributors.values()],
                          &#39;colors&#39;: lcolors})
    #tooltips = &#34;&#34;&#34;
    #&lt;div style=&#34;width: 400px&#34;&gt;
    #&lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
    #&lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
    #&lt;/div&gt;
    #&#34;&#34;&#34;
    tooltips = &#34;&#34;&#34;
    &lt;b&gt;Middle value:&lt;/b&gt; @middle_bin &lt;br&gt;
    &lt;b&gt;Contributors:&lt;/b&gt; @contributors{safe} &lt;br&gt;
    &#34;&#34;&#34;
    hover_tool = HoverTool(tooltips = tooltips)
    panels = []
    bottom = 0
    x_axis_type, y_axis_type, axis_type_title = 3 * [&#39;linear&#39;]
    for axis_type in [&#34;linear&#34;, &#34;linlog&#34;, &#34;loglin&#34;, &#34;loglog&#34;]:
        if axis_type == &#39;linlog&#39;:
            y_axis_type, axis_type_title = &#39;log&#39;, &#39;logy&#39;
        if axis_type == &#39;loglin&#39;:
            x_axis_type, y_axis_type, axis_type_title = &#39;log&#39;, &#39;linear&#39;, &#39;logx&#39;
        if axis_type == &#39;loglog&#39;:
            x_axis_type, y_axis_type = &#39;log&#39;, &#39;log&#39;
            axis_type_title = &#39;loglog&#39;

        standardfig = self.standardfig(x_axis_type=x_axis_type, y_axis_type=y_axis_type, **kwargs)

        standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)
        standardfig.xaxis[0].formatter = PrintfTickFormatter(format=&#34;%4.2e&#34;)
        standardfig.add_tools(hover_tool)
        standardfig.x_range = Range1d(1.05 * interval[0], 1.05 * interval[-1])
        standardfig.y_range = Range1d(0, 1.05 * frame_histo[&#39;top&#39;].max())
        if x_axis_type == &#34;log&#34;:
            left = 0.8
            if frame_histo[&#39;left&#39;][0] &lt;= 0:
                frame_histo.at[0, &#39;left&#39;] = left
            else:
                left  = frame_histo[&#39;left&#39;][0]
            standardfig.x_range = Range1d(left, 10 * interval[-1])

        if y_axis_type == &#34;log&#34;:
            bottom = 0.0001
            standardfig.y_range = Range1d(0.001, 10 * frame_histo[&#39;top&#39;].max())

        standardfig.quad(source=ColumnDataSource(frame_histo), top=&#39;top&#39;, bottom=bottom, left=&#39;left&#39;, \
                         right=&#39;right&#39;, fill_color=&#39;colors&#39;)
        panel = Panel(child=standardfig, title=axis_type_title)
        panels.append(panel)
    tabs = Tabs(tabs=panels)
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_horizonhisto"><code class="name flex">
<span>def <span class="ident">pycoa_horizonhisto</span></span>(<span>self, srcfiltered, panels, date_slider)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create 1D histogramme by location according to arguments.
See help(pycoa_histo).
Keyword Arguments</p>
<hr>
<ul>
<li>srcfiltered : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
@decohistopie
def pycoa_horizonhisto(self, srcfiltered, panels, date_slider):
    &#39;&#39;&#39;
        -----------------
        Create 1D histogramme by location according to arguments.
        See help(pycoa_histo).
        Keyword arguments
        -----------------
        - srcfiltered : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    n = len(panels)
    new_panels = []
    for i in range(n):
        fig = panels[i].child
        fig.y_range = Range1d(min(srcfiltered.data[&#39;bottom&#39;]), max(srcfiltered.data[&#39;top&#39;]))
        fig.yaxis[0].formatter = NumeralTickFormatter(format=&#34;0.0&#34;)
        ytick_loc = [int(i) for i in srcfiltered.data[&#39;horihistotexty&#39;]]
        fig.yaxis.ticker  = ytick_loc
        label_dict = dict(zip(ytick_loc,srcfiltered.data[&#39;permanentdisplay&#39;]))
        fig.yaxis.major_label_overrides = label_dict

        #print(fig.y_range ,fig.yaxis.major_label_overrides)
        fig.quad(source = srcfiltered,
            top=&#39;top&#39;, bottom = &#39;bottom&#39;, left = &#39;left&#39;, right = &#39;right&#39;, color = &#39;colors&#39;, line_color = &#39;black&#39;,
            line_width = 1, hover_line_width = 2)

        labels = LabelSet(
                x = &#39;horihistotextx&#39;,
                y = &#39;horihistotexty&#39;,
                x_offset=5,
                y_offset=-4,
                text = &#39;horihistotext&#39;,
                source = srcfiltered,text_font_size=&#39;10px&#39;,text_color=&#39;black&#39;)
        fig.add_layout(labels)

        panel = Panel(child = fig, title = panels[i].title)
        new_panels.append(panel)
    tabs = Tabs(tabs = new_panels)
    if date_slider:
            tabs = column(date_slider,tabs)
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_map"><code class="name flex">
<span>def <span class="ident">pycoa_map</span></span>(<span>self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a map bokeh with arguments.
See help(pycoa_histo).
Keyword Arguments</p>
<hr>
<ul>
<li>srcfiltered : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
<li>tile : tile</li>
<li>maplabel: False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
@decopycoageo
@decomap
def pycoa_map(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
    &#39;&#39;&#39;
        -----------------
        Create a map bokeh with arguments.
        See help(pycoa_histo).
        Keyword arguments
        -----------------
        - srcfiltered : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
        - tile : tile
        - maplabel: False
    &#39;&#39;&#39;

    date_slider = kwargs[&#39;date_slider&#39;]
    maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
    min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                 np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

    min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

    json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
    geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

    invViridis256 = Viridis256[::-1]
    if &#39;log&#39; in maplabel:
        color_mapper = LogColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#ffffff&#39;)
    else:
        color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
        color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4, width=standardfig.plot_width, bar_line_cap=&#39;round&#39;,
                         border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
    color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))

    if &#39;label%&#39; in maplabel:
        color_bar.formatter = BasicTickFormatter(use_scientific=False)
        color_bar.formatter = NumeralTickFormatter(format=&#34;0.0%&#34;)

    standardfig.add_layout(color_bar, &#39;below&#39;)

    if date_slider:
        allcases_location, allcases_dates = pd.DataFrame(), pd.DataFrame()
        allcases_location = geopdwd.groupby(&#39;location&#39;)[&#39;cases&#39;].apply(list)
        geopdwd_tmp = geopdwd.drop_duplicates(subset = [&#39;location&#39;]).drop(columns = &#39;cases&#39;)
        geopdwd_tmp = pd.merge(geopdwd_tmp, allcases_location, on = &#39;location&#39;)
        geopdwd_tmp  = geopdwd_tmp.drop_duplicates(subset = [&#39;clustername&#39;])
        geopdwd_tmp = ColumnDataSource(geopdwd_tmp.drop(columns=[&#39;geometry&#39;]))

        sourcemaplabel.data[&#39;rolloverdisplay&#39;] = sourcemaplabel.data[&#39;clustername&#39;]
        callback = CustomJS(args =  dict(source = geopdwd_tmp, source_filter = geopdwd_filtered,
                                      date_sliderjs = date_slider, title=standardfig.title,
                                      maplabeljs = sourcemaplabel),
                    code = &#34;&#34;&#34;
                    var ind_date_max = (date_sliderjs.end-date_sliderjs.start)/(24*3600*1000);
                    var ind_date = (date_sliderjs.value-date_sliderjs.start)/(24*3600*1000);
                    var new_cases = [];
                    var dict = {};
                    var iloop = source_filter.data[&#39;clustername&#39;].length;

                    function form(value) {
                         if(value&gt;10000 || value &lt;0.01)
                            value =  Number.parseFloat(value).toExponential(2);
                         else
                             value = Number.parseFloat(value).toFixed(2);
                        console.log(value);
                        return value;
                     }
                    for (var i = 0; i &lt; source.get_length(); i++)
                    {
                            var val=form(source.data[&#39;cases&#39;][i][ind_date_max-ind_date]);
                            new_cases.push(val);
                    }
                    if(source.get_length() == 1 &amp;&amp; iloop&gt;1)
                        for(var i = 0; i &lt; iloop; i++)
                            for(var j = 0; j &lt; new_cases.length; j++){
                            source_filter.data[&#39;cases&#39;][i][j] = new_cases[j];
                            }
                    else{
                        source_filter.data[&#39;cases&#39;] = new_cases;
                        }

                    if (maplabeljs.get_length() !== 0){
                        maplabeljs.data[&#39;cases&#39;] = source_filter.data[&#39;cases&#39;];
                        }
                    for (var i = 0; i &lt; maplabeljs.get_length(); i++)
                    {
                        maplabeljs.data[&#39;cases&#39;][i] = form(maplabeljs.data[&#39;cases&#39;][i]).toString();
                        maplabeljs.data[&#39;rolloverdisplay&#39;][i] = source_filter.data[&#39;rolloverdisplay&#39;][i];
                    }
                    var tmp = title.text;
                    tmp = tmp.slice(0, -11);
                    var dateconverted = new Date(date_sliderjs.value);
                    var dd = String(dateconverted.getDate()).padStart(2, &#39;0&#39;);
                    var mm = String(dateconverted.getMonth() + 1).padStart(2, &#39;0&#39;); //January is 0!
                    var yyyy = dateconverted.getFullYear();
                    var dmy = dd + &#39;/&#39; + mm + &#39;/&#39; + yyyy;
                    title.text = tmp + dmy+&#34;)&#34;;
                    if (maplabeljs.get_length() !== 0)
                        maplabeljs.change.emit();

                    console.log(maplabeljs.data[&#39;cases&#39;]);
                    source_filter.change.emit();
                &#34;&#34;&#34;)
        date_slider.js_on_change(&#39;value&#39;, callback)


    standardfig.xaxis.visible = False
    standardfig.yaxis.visible = False
    standardfig.xgrid.grid_line_color = None
    standardfig.ygrid.grid_line_color = None
    standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                        fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                        line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)

    if &#39;text&#39; in maplabel :
        labels = LabelSet(
            x = &#39;centroidx&#39;,
            y = &#39;centroidy&#39;,
            text = &#39;cases&#39;,
            source = sourcemaplabel, text_font_size=&#39;10px&#39;,text_color=&#39;white&#39;,background_fill_color=&#39;grey&#39;,background_fill_alpha=0.5)
        standardfig.add_layout(labels)

    #cases_custom = CocoDisplay.rollerJS()
    callback = CustomJS(code=&#34;&#34;&#34;
    //document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.backgroundColor=&#34;transparent&#34;;
    document.getElementsByClassName(&#39;bk-tooltip&#39;)[0].style.opacity=&#34;0.7&#34;;
    &#34;&#34;&#34; )
    tooltips = &#34;&#34;&#34;
                &lt;b&gt;location: @rolloverdisplay&lt;br&gt;
                cases: @cases{0,0.0}&lt;/b&gt;
               &#34;&#34;&#34;
    standardfig.add_tools(HoverTool(tooltips = tooltips,
    formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;cases&#39;: &#39;printf&#39;,},
    point_policy = &#34;snap_to_data&#34;,callback=callback))  # ,PanTool())
    if date_slider:
        standardfig = column(date_slider, standardfig)
    return standardfig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_mapfolium"><code class="name flex">
<span>def <span class="ident">pycoa_mapfolium</span></span>(<span>self, geopdwd, input_field, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a map folium to arguments.
See help(pycoa_histo).
Keyword Arguments</p>
<hr>
<ul>
<li>srcfiltered : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
def pycoa_mapfolium(self, geopdwd, input_field, **kwargs):
    &#39;&#39;&#39;
        -----------------
        Create a map folium to arguments.
        See help(pycoa_histo).
        Keyword arguments
        -----------------
        - srcfiltered : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    title = kwargs.get(&#39;title&#39;, None)
    tile =  kwargs.get(&#39;tile&#39;, self.dvisu_default[&#39;tile&#39;])
    tile = CocoDisplay.convert_tile(tile, &#39;folium&#39;)
    maplabel = kwargs.get(&#39;maplabel&#39;,self.dvisu_default[&#39;maplabel&#39;])
    plot_width = kwargs.get(&#39;plot_width&#39;,self.dfigure_default[&#39;plot_width&#39;])
    plot_height = kwargs.get(&#39;plot_height&#39;,self.dfigure_default[&#39;plot_height&#39;])

    geopdwd[&#39;cases&#39;] = geopdwd[input_field]
    geopdwd_filtered = geopdwd.loc[geopdwd.date == self.when_end]
    geopdwd_filtered = geopdwd_filtered.reset_index(drop = True)
    geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered[input_field]
    my_date = geopdwd.date.unique()
    dico_utc = {i: DateSlider(value=i).value for i in my_date}
    geopdwd[&#39;date_utc&#39;] = [dico_utc[i] for i in geopdwd.date]
    #geopdwd = geopdwd.drop_duplicates([&#34;date&#34;, &#34;codelocation&#34;,&#34;clustername&#34;])#for sumall avoid duplicate
    #geopdwd_filtered = geopdwd_filtered.sort_values(by=&#39;cases&#39;, ascending = False).reset_index()
    #locunique = geopdwd_filtered.clustername.unique()#geopdwd_filtered.location.unique()
    if self.database_name == &#39;risklayer&#39;:
        geopdwd_filtered = geopdwd_filtered.loc[geopdwd_filtered.geometry.notna()]

    uniqloc = list(geopdwd_filtered.codelocation.unique())
    geopdwd_filtered = geopdwd_filtered.drop(columns=[&#39;date&#39;, &#39;colors&#39;])

    msg = &#34;(data from: {})&#34;.format(self.database_name)

    minx, miny, maxx, maxy =  geopdwd_filtered.total_bounds

    mapa = folium.Map(tiles=tile, attr=&#39;&lt;a href=\&#34;http://pycoa.fr\&#34;&gt; ©pycoa.fr &lt;/a&gt;&#39; + msg)
    #min_lat=minx, max_lat=maxx, min_lon=miny, max_lon=maxy)
    #location=[geopdwd_filtered.centroid.y.mean(),geopdwd_filtered.centroid.x.mean()],)
    if self.dbld[self.database_name][0] != &#39;WW&#39;:
        mapa.fit_bounds([(miny, minx), (maxy, maxx)])

    fig = Figure(width=plot_width, height=plot_height)
    fig.add_child(mapa)
    min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[input_field]),
                                                 np.nanmax(geopdwd_filtered[input_field]))
    min_col_non0 = (np.nanmin(geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0.][&#39;cases&#39;]))

    invViridis256 = Viridis256[::-1]
    if &#39;log&#39; in maplabel:
        geopdwd_filtered[&#39;cases&#39;] = geopdwd_filtered.loc[geopdwd_filtered[&#39;cases&#39;]&gt;0][&#39;cases&#39;]
        color_mapper = LinearColorMapper(palette=invViridis256, low=min_col_non0, high=max_col, nan_color=&#39;#d9d9d9&#39;)
        colormap =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
    else:
        color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#d9d9d9&#39;)
        colormap = branca.colormap.LinearColormap(color_mapper.palette).scale(min_col, max_col)
    colormap.caption =  title
    colormap.add_to(mapa)
    map_id = colormap.get_name()

    custom_label_colorbar_js = &#34;&#34;&#34;
    var div = document.getElementById(&#39;legend&#39;);
    var ticks = document.getElementsByClassName(&#39;tick&#39;)
    for(var i = 0; i &lt; ticks.length; i++){
    var values = ticks[i].textContent.replace(&#39;,&#39;,&#39;&#39;)
    val = parseFloat(values).toExponential(1).toString().replace(&#34;+&#34;, &#34;&#34;)
    if(parseFloat(ticks[i].textContent) == 0) val = 0.
    div.innerHTML = div.innerHTML.replace(ticks[i].textContent,val);
    }
    &#34;&#34;&#34;
    e = Element(custom_label_colorbar_js)
    html = colormap.get_root()
    html.script.get_root().render()
    html.script._children[e.get_name()] = e
    geopdwd_filtered[input_field + &#39;scientific_format&#39;] = \
        ([&#39;{:.5g}&#39;.format(i) for i in geopdwd_filtered[&#39;cases&#39;]])
    # ([&#39;{:.3g}&#39;.format(i) if i&gt;100000 else i for i in geopdwd_filter[input_field]])

    map_dict = geopdwd_filtered.set_index(&#39;location&#39;)[input_field].to_dict()
    if np.nanmin(geopdwd_filtered[input_field]) == np.nanmax(geopdwd_filtered[input_field]):
        map_dict[&#39;FakeCountry&#39;] = 0.

    if &#39;log&#39; in maplabel:
        color_scale =  branca.colormap.LinearColormap(color_mapper.palette).to_step(data=list(geopdwd_filtered[&#39;cases&#39;]),n=10,method=&#39;log&#39;)
    else:
        color_scale = LinearColormap(color_mapper.palette, vmin=min(map_dict.values()), vmax=max(map_dict.values()))

    def get_color(feature):
        value = map_dict.get(feature[&#39;properties&#39;][&#39;location&#39;])
        if value is None or np.isnan(value):
            return &#39;#8c8c8c&#39;  # MISSING -&gt; gray
        else:
            return color_scale(value)

    displayed = &#39;rolloverdisplay&#39;
    folium.GeoJson(
        geopdwd_filtered,
        style_function=lambda x:
        {
            &#39;fillColor&#39;: get_color(x),
            &#39;fillOpacity&#39;: 0.8,
            &#39;color&#39;: None
        },
        highlight_function=lambda x: {&#39;weight&#39;: 2, &#39;color&#39;: &#39;green&#39;},
        tooltip=folium.features.GeoJsonTooltip(fields=[displayed, input_field + &#39;scientific_format&#39;],
                                               aliases=[&#39;location&#39; + &#39;:&#39;, input_field + &#34;:&#34;],
                                               style=&#34;&#34;&#34;
                    background-color: #F0EFEF;
                    border: 2px solid black;
                    border-radius: 3px;
                    box-shadow: 3px;
                    opacity: 0.2;
                    &#34;&#34;&#34;),
        # &#39;&lt;div style=&#34;barialckground-color: royalblue 0.2; color: black; padding: 2px; border: 1px solid black; border-radius: 2px;&#34;&gt;&#39;+input_field+&#39;&lt;/div&gt;&#39;])
    ).add_to(mapa)
    return mapa</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_pie"><code class="name flex">
<span>def <span class="ident">pycoa_pie</span></span>(<span>self, srcfiltered, panels, date_slider)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a pie chart according to arguments.
See help(pycoa_pie).
Keyword Arguments</p>
<hr>
<ul>
<li>srcfiltered : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
@decohistopie
def pycoa_pie(self, srcfiltered, panels, date_slider):
    &#39;&#39;&#39;
        -----------------
        Create a pie chart according to arguments.
        See help(pycoa_pie).
        Keyword arguments
        -----------------
        - srcfiltered : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
    &#39;&#39;&#39;
    standardfig = panels[0].child
    standardfig.plot_height=400
    standardfig.plot_width=400
    standardfig.x_range = Range1d(-1.1, 1.1)
    standardfig.y_range = Range1d(-1.1, 1.1)
    standardfig.axis.visible = False
    standardfig.xgrid.grid_line_color = None
    standardfig.ygrid.grid_line_color = None

    standardfig.wedge(x=0, y=0, radius=1.,line_color=&#39;#E8E8E8&#39;,
    start_angle=cumsum(&#39;angle&#39;, include_zero=True), end_angle=cumsum(&#39;angle&#39;),
    fill_color=&#39;colors&#39;, legend_label=&#39;clustername&#39;, source=srcfiltered)
    standardfig.legend.visible = False

    labels = LabelSet(x=0, y=0,text=&#39;textdisplayed&#39;,angle=cumsum(&#39;angle&#39;, include_zero=True),
    text_font_size=&#34;10pt&#34;,source=srcfiltered,render_mode=&#39;canvas&#39;)

    labels2 = LabelSet(x=0, y=0, text=&#39;textdisplayed2&#39;,
    angle=cumsum(&#39;angle&#39;, include_zero=True),text_font_size=&#34;8pt&#34;,source=srcfiltered)

    standardfig.add_layout(labels)
    standardfig.add_layout(labels2)
    if date_slider:
        standardfig = column(date_slider,standardfig)
    return standardfig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_pimpmap"><code class="name flex">
<span>def <span class="ident">pycoa_pimpmap</span></span>(<span>self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a bokeh map with pimpline label and with to arguments.
See help(pycoa_histo).
Keyword Arguments</p>
<hr>
<ul>
<li>srcfiltered : A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
<li>tile : tile</li>
<li>maplabel: False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
@decopycoageo
@decomap
def pycoa_pimpmap(self, geopdwd, geopdwd_filtered, sourcemaplabel, standardfig,**kwargs):
    &#39;&#39;&#39;
        -----------------
        Create a bokeh map with pimpline label and with to arguments.
        See help(pycoa_histo).
        Keyword arguments
        -----------------
        - srcfiltered : A DataFrame with a Pycoa struture is mandatory
        |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
        - input_field = if None take second element could be a list
        - plot_heigh= width_height_default[1]
        - plot_width = width_height_default[0]
        - title = None
        - textcopyright = default
        - mode = mouse
        - cursor_date = None if True
                - orientation = horizontal
        - when : default min and max according to the inpude DataFrame.
                     Dates are given under the format dd/mm/yyyy.
                     when format [dd/mm/yyyy : dd/mm/yyyy]
                     if [:dd/mm/yyyy] min date up to
                     if [dd/mm/yyyy:] up to max date
        - tile : tile
        - maplabel: False
    &#39;&#39;&#39;
    standardfig.xaxis.visible = False
    standardfig.yaxis.visible = False
    standardfig.xgrid.grid_line_color = None
    standardfig.ygrid.grid_line_color = None

    min_col, max_col = CocoDisplay.min_max_range(np.nanmin(geopdwd_filtered[&#39;cases&#39;]),
                                                 np.nanmax(geopdwd_filtered[&#39;cases&#39;]))

    json_data = json.dumps(json.loads(geopdwd_filtered.to_json()))
    geopdwd_filtered = GeoJSONDataSource(geojson=json_data)

    invViridis256 = Viridis256[::-1]
    color_mapper = LinearColorMapper(palette=invViridis256, low=min_col, high=max_col, nan_color=&#39;#ffffff&#39;)
    color_bar = ColorBar(color_mapper=color_mapper, label_standoff=4,
                         border_line_color=None, location=(0, 0), orientation=&#39;horizontal&#39;, ticker=BasicTicker())
    color_bar.formatter = BasicTickFormatter(use_scientific=True, precision=1, power_limit_low=int(max_col))
    standardfig.add_layout(color_bar, &#39;below&#39;)
    standardfig.patches(&#39;xs&#39;, &#39;ys&#39;, source = geopdwd_filtered,
                                fill_color = {&#39;field&#39;: &#39;cases&#39;, &#39;transform&#39;: color_mapper},
                                line_color = &#39;black&#39;, line_width = 0.25, fill_alpha = 1)
    standardfig.image_url(url=&#39;pimpmap&#39;, x=&#39;centroidx&#39;, y=&#39;centroidy&#39;,source=sourcemaplabel,anchor=&#34;center&#34;)
    return standardfig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_plot"><code class="name flex">
<span>def <span class="ident">pycoa_plot</span></span>(<span>self, input=None, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a versus plot according to arguments.
See help(pycoa_plot).
Keyword Arguments</p>
<hr>
<ul>
<li>input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element. It should be a list dim=2. Moreover the 2 variables must be present
in the DataFrame considered.</li>
<li>plot_heigh = width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decoplot
def pycoa_plot(self, input = None, input_field = None ,**kwargs):
    &#39;&#39;&#39;
    -----------------
    Create a versus plot according to arguments.
    See help(pycoa_plot).
    Keyword arguments
    -----------------
    - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
    |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
    - input_field = if None take second element. It should be a list dim=2. Moreover the 2 variables must be present
    in the DataFrame considered.
    - plot_heigh = width_height_default[1]
    - plot_width = width_height_default[0]
    - title = None
    - textcopyright = default
    - mode = mouse
    - cursor_date = None if True
            - orientation = horizontal
    - when : default min and max according to the inpude DataFrame.
             Dates are given under the format dd/mm/yyyy.
             when format [dd/mm/yyyy : dd/mm/yyyy]
             if [:dd/mm/yyyy] min date up to
             if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    if len(input_field) != 2:
        raise CoaTypeError(&#39;Two variables are needed to plot a versus chart ... &#39;)
    panels = []
    cases_custom = CocoDisplay.rollerJS()
    if self.get_listfigures():
        self.set_listfigures([])
    listfigs=[]
    for axis_type in self.ax_type:
        standardfig = self.standardfig( x_axis_label = input_field[0], y_axis_label = input_field[1],
                                            y_axis_type = axis_type, **kwargs )

        standardfig.add_tools(HoverTool(
            tooltips=[(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;),
                      (input_field[0], &#39;@{casesx}&#39; + &#39;{custom}&#39;),
                      (input_field[1], &#39;@{casesy}&#39; + &#39;{custom}&#39;)],
            formatters={&#39;location&#39;: &#39;printf&#39;, &#39;@{casesx}&#39;: cases_custom, &#39;@{casesy}&#39;: cases_custom,
                        &#39;@date&#39;: &#39;datetime&#39;}, mode = kwargs[&#39;mode&#39;],
            point_policy=&#34;snap_to_data&#34;))  # ,PanTool())

        for loc in input.clustername.unique():
            pandaloc = input.loc[input.clustername == loc].sort_values(by=&#39;date&#39;, ascending=&#39;True&#39;)
            pandaloc.rename(columns={input_field[0]: &#39;casesx&#39;, input_field[1]: &#39;casesy&#39;}, inplace=True)
            standardfig.line(x=&#39;casesx&#39;, y=&#39;casesy&#39;,
                             source=ColumnDataSource(pandaloc), legend_label=pandaloc.clustername.iloc[0],
                             color=pandaloc.colors.iloc[0], line_width=3, hover_line_width=4)

        standardfig.legend.label_text_font_size = &#34;12px&#34;
        panel = Panel(child=standardfig, title=axis_type)
        panels.append(panel)
        standardfig.legend.background_fill_alpha = 0.6

        standardfig.legend.location = &#34;top_left&#34;
        listfigs.append(standardfig)
        CocoDisplay.bokeh_legend(standardfig)
    self.set_listfigures(listfigs)
    tabs = Tabs(tabs=panels)
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_resume_data"><code class="name flex">
<span>def <span class="ident">pycoa_resume_data</span></span>(<span>self, input, input_field, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
def pycoa_resume_data(self, input, input_field, **kwargs):
    loc=list(input[&#39;clustername&#39;].unique())
    input[&#39;cases&#39;] = input[input_field]
    resumetype = kwargs.get(&#39;resumetype&#39;,&#39;spiral&#39;)
    if resumetype == &#39;spiral&#39;:
        dspiral={i:CocoDisplay.spiral(input.loc[ (input.clustername==i) &amp;
                    (input.date &gt;= self.when_beg) &amp;
                    (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
        input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(dspiral)
    elif resumetype == &#39;spark&#39;:
        spark={i:CocoDisplay.sparkline(input.loc[ (input.clustername==i) &amp;
                    (input.date &gt;= self.when_beg) &amp;
                    (input.date &lt;= self.when_end)].sort_values(by=&#39;date&#39;)) for i in loc}
        input[&#39;resume&#39;]=input[&#39;clustername&#39;].map(spark)
    else:
        raise CoaError(&#39;pycoa_resume_data can use spiral or spark ... here what ?&#39;)
    input = input.loc[input.date==input.date.max()].reset_index(drop=True)
    def path_to_image_html(path):
        return &#39;&lt;img src=&#34;&#39;+ path + &#39;&#34; width=&#34;60&#34; &gt;&#39;

    input=input.drop(columns=[&#39;permanentdisplay&#39;,&#39;rolloverdisplay&#39;,&#39;colors&#39;,&#39;cases&#39;])
    input=input.apply(lambda x: x.round(2) if x.name in [input_field,&#39;daily&#39;,&#39;weekly&#39;] else x)
    if isinstance(input[&#39;location&#39;][0], list):
        col=[i for i in list(input.columns) if i not in [&#39;clustername&#39;,&#39;location&#39;,&#39;codelocation&#39;]]
        col.insert(0,&#39;clustername&#39;)
        input = input[col]
        input=input.set_index(&#39;clustername&#39;)
    else:
       input = input.drop(columns=&#39;clustername&#39;)
       input=input.set_index(&#39;location&#39;)

    return input.to_html(escape=False,formatters=dict(resume=path_to_image_html))</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_scrollingmenu"><code class="name flex">
<span>def <span class="ident">pycoa_scrollingmenu</span></span>(<span>self, input=None, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a date plot, with a scrolling menu location, according to arguments.
See help(pycoa_scrollingmenu).
Keyword Arguments</p>
<hr>
<p>len(location) &gt; 2
- input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
- input_field = if None take second element could be a list
- plot_heigh= width_height_default[1]
- plot_width = width_height_default[0]
- title = None
- textcopyright = default
- mode = mouse
-guideline = False
- cursor_date = None if True
- orientation = horizontal
- when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decoplot
def pycoa_scrollingmenu(self, input = None, input_field = None, **kwargs):
    &#39;&#39;&#39;
    -----------------
    Create a date plot, with a scrolling menu location, according to arguments.
    See help(pycoa_scrollingmenu).
    Keyword arguments
    -----------------
    len(location) &gt; 2
    - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
    |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
    - input_field = if None take second element could be a list
    - plot_heigh= width_height_default[1]
    - plot_width = width_height_default[0]
    - title = None
    - textcopyright = default
    - mode = mouse
    -guideline = False
    - cursor_date = None if True
            - orientation = horizontal
    - when : default min and max according to the inpude DataFrame.
             Dates are given under the format dd/mm/yyyy.
             when format [dd/mm/yyyy : dd/mm/yyyy]
             if [:dd/mm/yyyy] min date up to
             if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    mode = kwargs.get(&#39;mode&#39;,self.dvisu_default[&#39;mode&#39;])
    guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])

    uniqloc = input.clustername.unique().to_list()
    uniqloc.sort()
    if &#39;location&#39; in input.columns:
        if len(uniqloc) &lt; 2:
            raise CoaTypeError(&#39;What do you want me to do ? You have selected, only one country.&#39;
                               &#39;There is no sens to use this method. See help.&#39;)
    input = input[[&#39;date&#39;, &#39;clustername&#39;, input_field]]
    input = input.sort_values(by=&#39;clustername&#39;, ascending = True).reset_index(drop=True)

    mypivot = pd.pivot_table(input, index=&#39;date&#39;, columns=&#39;clustername&#39;, values=input_field)
    column_order = uniqloc
    mypivot = mypivot.reindex(column_order, axis=1)
    source = ColumnDataSource(mypivot)

    filter_data1 = mypivot[[uniqloc[0]]].rename(columns={uniqloc[0]: &#39;cases&#39;})
    src1 = ColumnDataSource(filter_data1)

    filter_data2 = mypivot[[uniqloc[1]]].rename(columns={uniqloc[1]: &#39;cases&#39;})
    src2 = ColumnDataSource(filter_data2)

    cases_custom = CocoDisplay.rollerJS()
    hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                           formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;}, mode = mode,
                           point_policy=&#34;snap_to_data&#34;)  # ,PanTool())

    panels = []
    for axis_type in self.ax_type:
        standardfig = self.standardfig( y_axis_type = axis_type, x_axis_type = &#39;datetime&#39;, **kwargs)

        standardfig.yaxis[0].formatter = PrintfTickFormatter(format = &#34;%4.2e&#34;)

        standardfig.add_tools(hover_tool)
        if guideline:
            cross= CrosshairTool()
            standardfig.add_tools(cross)
        def add_line(src, options, init, color):
            s = Select(options = options, value = init)
            r = standardfig.line(x = &#39;date&#39;, y = &#39;cases&#39;, source = src, line_width = 3, line_color = color)
            li = LegendItem(label = init, renderers = [r])
            s.js_on_change(&#39;value&#39;, CustomJS(args=dict(s0=source, s1=src, li=li),
                                             code=&#34;&#34;&#34;
                                        var c = cb_obj.value;
                                        var y = s0.data[c];
                                        s1.data[&#39;cases&#39;] = y;
                                        li.label = {value: cb_obj.value};
                                        s1.change.emit();
                                 &#34;&#34;&#34;))
            return s, li

        s1, li1 = add_line(src1, uniqloc, uniqloc[0], self.scolors[0])
        s2, li2 = add_line(src2, uniqloc, uniqloc[1], self.scolors[1])
        standardfig.add_layout(Legend(items = [li1, li2]))
        standardfig.legend.location = &#39;top_left&#39;
        layout = row(column(row(s1, s2), row(standardfig)))
        panel = Panel(child = layout, title = axis_type)
        panels.append(panel)

    tabs = Tabs(tabs = panels)
    label = standardfig.title
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_spiral_plot"><code class="name flex">
<span>def <span class="ident">pycoa_spiral_plot</span></span>(<span>self, input=None, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decoplot
def pycoa_spiral_plot(self, input = None, input_field = None, **kwargs):
    guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
    panels = []
    listfigs = []
    if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
        input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
    borne=300
    kwargs.pop(&#39;plot_width&#39;)
    standardfig = self.standardfig(y_axis_type = None, x_axis_type = None,
    width=kwargs[&#39;plot_height&#39;], x_range=[-borne, borne], y_range=[-borne, borne], match_aspect=True,**kwargs)

    if len(input.clustername.unique()) &gt; 1 :
        print(&#39;Can only display spiral for ONE location. I took the first one:&#39;, input.clustername[0])
        input = input.loc[input.clustername == input.clustername[0]].copy()
    input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
    input[&#34;dayofyear&#34;]=input.date.dt.dayofyear
    input[&#39;year&#39;]=input.date.dt.year
    input[&#39;cases&#39;] = input[input_field]

    K = 2*input[input_field].max()
    #drop bissextile fine tuning in needed in the future
    input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
    input[&#34;dayofyear_angle&#34;] = input[&#34;dayofyear&#34;]*2 * np.pi/365
    input[&#34;r_baseline&#34;] = input.apply(lambda x : ((x[&#34;year&#34;]-2020)*2 * np.pi + x[&#34;dayofyear_angle&#34;])*K,axis=1)
    size_factor = 16
    input[&#34;r_cas_sup&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] + 0.5*x[input_field]*size_factor,axis=1)
    input[&#34;r_cas_inf&#34;] = input.apply(lambda x : x[&#34;r_baseline&#34;] - 0.5*x[input_field]*size_factor,axis=1)

    radius = 200
    def polar(theta,r,norm=radius/input[&#34;r_baseline&#34;].max()):
        x = norm*r*np.cos(theta)
        y = norm*r*np.sin(theta)
        return x,y
    x_base,y_base=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_baseline&#34;])
    x_cas_sup,y_cas_sup=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_sup&#34;])
    x_cas_inf,y_cas_inf=polar(input[&#34;dayofyear_angle&#34;],input[&#34;r_cas_inf&#34;])

    xcol,ycol=[],[]
    [ xcol.append([i,j]) for i,j in zip(x_cas_inf,x_cas_sup)]
    [ ycol.append([i,j]) for i,j in zip(y_cas_inf,y_cas_sup)]
    standardfig.patches(xcol,ycol,color=&#39;blue&#39;,fill_alpha = 0.5)

    src = ColumnDataSource(data=dict(
    x=x_base,
    y=y_base,
    date=input[&#39;date&#39;],
    cases=input[&#39;cases&#39;]
    ))
    standardfig.line( x = &#39;x&#39;, y = &#39;y&#39;, source = src, legend_label = input.clustername[0],
                    line_width = 3, line_color = &#39;blue&#39;)
    circle = standardfig.circle(&#39;x&#39;, &#39;y&#39;, size=2, source=src)

    cases_custom = CocoDisplay.rollerJS()
    hover_tool = HoverTool(tooltips=[(&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;)],
                           formatters={&#39;Cases&#39;: &#39;printf&#39;, &#39;@{cases}&#39;: cases_custom, &#39;@date&#39;: &#39;datetime&#39;},
                           renderers=[circle],
                           point_policy=&#34;snap_to_data&#34;)
    standardfig.add_tools(hover_tool)

    outer_radius=250
    [standardfig.annular_wedge(
        x=0, y=0, inner_radius=0, outer_radius=outer_radius, start_angle=i*np.pi/6,\
        end_angle=(i+1)*np.pi/6,fill_color=None,line_color=&#39;black&#39;,line_dash=&#39;dotted&#39;)
    for i in range(12)]

    label = [&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;,&#39;May&#39;,&#39;June&#39;,&#39;July&#39;,&#39;August&#39;,&#39;September&#39;,&#39;October&#39;,&#39;November&#39;,&#39;December&#39;]
    xr,yr = polar(np.linspace(0, 2 * np.pi, 13),outer_radius,1)
    standardfig.text(xr[:-1], yr[:-1], label,text_font_size=&#34;9pt&#34;, text_align=&#34;center&#34;, text_baseline=&#34;middle&#34;)

    standardfig.legend.background_fill_alpha = 0.6
    standardfig.legend.location = &#34;top_left&#34;
    standardfig.legend.click_policy=&#34;hide&#34;
    return standardfig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoa_yearly_plot"><code class="name flex">
<span>def <span class="ident">pycoa_yearly_plot</span></span>(<span>self, input=None, input_field=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Create a date plot according to arguments. See help(pycoa_date_plot).
Keyword Arguments</p>
<hr>
<ul>
<li>input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
|location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|</li>
<li>input_field = if None take second element could be a list</li>
<li>plot_heigh= width_height_default[1]</li>
<li>plot_width = width_height_default[0]</li>
<li>title = None</li>
<li>textcopyright = default</li>
<li>mode = mouse</li>
<li>guideline = False</li>
<li>cursor_date = None if True
- orientation = horizontal</li>
<li>when : default min and max according to the inpude DataFrame.
Dates are given under the format dd/mm/yyyy.
when format [dd/mm/yyyy : dd/mm/yyyy]
if [:dd/mm/yyyy] min date up to
if [dd/mm/yyyy:] up to max date</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decoplot
def pycoa_yearly_plot(self, input = None, input_field = None, **kwargs):
    &#39;&#39;&#39;
    -----------------
    Create a date plot according to arguments. See help(pycoa_date_plot).
    Keyword arguments
    -----------------
    - input = None : if None take first element. A DataFrame with a Pycoa struture is mandatory
    |location|date|Variable desired|daily|cumul|weekly|codelocation|clustername|permanentdisplay|rolloverdisplay|
    - input_field = if None take second element could be a list
    - plot_heigh= width_height_default[1]
    - plot_width = width_height_default[0]
    - title = None
    - textcopyright = default
    - mode = mouse
    - guideline = False
    - cursor_date = None if True
            - orientation = horizontal
    - when : default min and max according to the inpude DataFrame.
             Dates are given under the format dd/mm/yyyy.
             when format [dd/mm/yyyy : dd/mm/yyyy]
             if [:dd/mm/yyyy] min date up to
             if [dd/mm/yyyy:] up to max date
    &#39;&#39;&#39;
    guideline = kwargs.get(&#39;guideline&#39;,self.dvisu_default[&#39;guideline&#39;])
    if len(input.clustername.unique()) &gt; 1 :
        print(&#39;Can only display yearly plot for ONE location. I took the first one:&#39;, input.clustername[0])
    input = input.loc[input.clustername == input.clustername[0]].copy()

    panels = []
    listfigs = []
    cases_custom = CocoDisplay.rollerJS()
    input[&#39;date&#39;]=pd.to_datetime(input[&#34;date&#34;])
    #drop bissextile fine tuning in needed in the future
    input = input.loc[~(input[&#39;date&#39;].dt.month.eq(2) &amp; input[&#39;date&#39;].dt.day.eq(29))].reset_index(drop=True)
    input = input.copy()
    input.loc[:,&#39;allyears&#39;]=input[&#39;date&#39;].apply(lambda x : x.year)
    input[&#39;allyears&#39;] = input[&#39;allyears&#39;].astype(int)
    input.loc[:,&#39;dayofyear&#39;]= input[&#39;date&#39;].apply(lambda x : x.dayofyear)
    allyears = list(input.allyears.unique())
    if isinstance(input[&#39;rolloverdisplay&#39;][0],list):
        input[&#39;rolloverdisplay&#39;] = input[&#39;clustername&#39;]
    if len(input_field)&gt;1:
        CoaError(&#39;Only one variable could be displayed&#39;)
    else:
        input_field=input_field[0]
    for axis_type in self.ax_type:
        standardfig = self.standardfig( y_axis_type = axis_type,**kwargs)
        i = 0
        r_list=[]
        maxou=-1000
        input[&#39;cases&#39;]=input[input_field]
        line_style = [&#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;dotdash&#39;]
        colors = itertools.cycle(self.lcolors)
        for loc in list(input.clustername.unique()):
            for year in allyears:
                input_filter = input.loc[(input.clustername == loc) &amp; (input[&#39;date&#39;].dt.year.eq(year))].reset_index(drop = True)
                src = ColumnDataSource(input_filter)
                leg = loc + &#39; &#39; + str(year)
                r = standardfig.line(x = &#39;dayofyear&#39;, y = input_field, source = src,
                                 color = next(colors), line_width = 3,
                                 legend_label = leg,
                                 hover_line_width = 4, name = input_field)
                maxou=max(maxou,np.nanmax(input_filter[input_field].values))

        label = input_field
        tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (&#39;Cases&#39;, &#39;@cases{0,0.0}&#39;)]
        formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
        hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;])  # ,PanTool())
        standardfig.add_tools(hover)
        if guideline:
            cross= CrosshairTool()
            standardfig.add_tools(cross)

        if axis_type == &#39;linear&#39;:
            if maxou  &lt; 1e4 :
                standardfig.yaxis.formatter = BasicTickFormatter(use_scientific=False)

        standardfig.legend.label_text_font_size = &#34;12px&#34;
        panel = Panel(child=standardfig, title = axis_type)
        panels.append(panel)
        standardfig.legend.background_fill_alpha = 0.6

        standardfig.legend.location = &#34;top_left&#34;
        standardfig.legend.click_policy=&#34;hide&#34;

        labelspd=input.loc[(input.allyears.eq(2021)) &amp; (input.date.dt.day.eq(1))]
        standardfig.xaxis.ticker = list(labelspd[&#39;dayofyear&#39;].astype(int))
        replacelabelspd =  labelspd[&#39;date&#39;].apply(lambda x: str(x.strftime(&#34;%b&#34;)))
        #label_dict = dict(zip(input.loc[input.allyears.eq(2020)][&#39;daymonth&#39;],input.loc[input.allyears.eq(2020)][&#39;date&#39;].apply(lambda x: str(x.day)+&#39;/&#39;+str(x.month))))
        standardfig.xaxis.major_label_overrides = dict(zip(list(labelspd[&#39;dayofyear&#39;].astype(int)),list(replacelabelspd)))

        CocoDisplay.bokeh_legend(standardfig)
        listfigs.append(standardfig)

    tooltips = [(&#39;Location&#39;, &#39;@rolloverdisplay&#39;), (&#39;date&#39;, &#39;@date{%F}&#39;), (r.name, &#39;@$name{0,0.0}&#39;)]
    formatters = {&#39;location&#39;: &#39;printf&#39;, &#39;@date&#39;: &#39;datetime&#39;, &#39;@name&#39;: &#39;printf&#39;}
    hover=HoverTool(tooltips = tooltips, formatters = formatters, point_policy = &#34;snap_to_data&#34;, mode = kwargs[&#39;mode&#39;], renderers=[r])  # ,PanTool())
    standardfig.add_tools(hover)
    if guideline:
        cross= CrosshairTool()
        standardfig.add_tools(cross)
    self.set_listfigures(listfigs)
    tabs = Tabs(tabs = panels)
    return tabs</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.pycoageo"><code class="name flex">
<span>def <span class="ident">pycoageo</span></span>(<span>self, geopdwd, geopdwd_filtered, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@decowrapper
@decohistomap
@decopycoageo
def pycoageo(self, geopdwd, geopdwd_filtered, **kwargs):
    return geopdwd_filtered</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.set_listfigures"><code class="name flex">
<span>def <span class="ident">set_listfigures</span></span>(<span>self, fig)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_listfigures(self,fig):
        if not isinstance(fig,list):
            fig = [fig]
        self.listfigs = fig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.standardfig"><code class="name flex">
<span>def <span class="ident">standardfig</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a standard Bokeh figure, with pycoa.fr copyright, used in all the bokeh charts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardfig(self, **kwargs):
    &#34;&#34;&#34;
     Create a standard Bokeh figure, with pycoa.fr copyright, used in all the bokeh charts
     &#34;&#34;&#34;
    plot_width = kwargs.get(&#39;plot_width&#39;, self.dfigure_default[&#39;plot_width&#39;])
    plot_height = kwargs.get(&#39;plot_height&#39;, self.dfigure_default[&#39;plot_height&#39;])
    textcopyright = kwargs.get(&#39;textcopyright&#39;, self.dfigure_default[&#39;textcopyright&#39;])

    if textcopyright  == &#39;default&#39;:
            textcopyright = &#39;©pycoa.fr (data from: {})&#39;.format(self.database_name)
    else:
            textcopyright = &#39;©pycoa.fr &#39; + textcopyright

    citation = Label(x=0.65 * plot_width - len(textcopyright), y=0.01 * plot_height,
                                      x_units=&#39;screen&#39;, y_units=&#39;screen&#39;,
                                      text_font_size=&#39;1.5vh&#39;, background_fill_color=&#39;white&#39;, background_fill_alpha=.75,
                                      text=textcopyright)

    for i in list(self.dvisu_default.keys())  + self.options_front + self.options_charts + [&#39;textcopyright&#39;] + self.options_stats + [&#39;date_slider&#39;]:
        if i in kwargs.keys():
            kwargs.pop(i)
    kwargs.pop(&#39;title&#39;)
    fig = figure(**kwargs, tools=[&#39;save&#39;, &#39;box_zoom,reset&#39;], toolbar_location=&#34;right&#34;)
    #fig.add_layout(citation)
    fig.add_layout(Title(text=self.uptitle, text_font_size=&#34;10pt&#34;), &#39;above&#39;)
    fig.add_layout(Title(text=self.subtitle, text_font_size=&#34;8pt&#34;, text_font_style=&#34;italic&#34;), &#39;below&#39;)
    return fig</code></pre>
</details>
</dd>
<dt id="coa.display.CocoDisplay.tiles_list"><code class="name flex">
<span>def <span class="ident">tiles_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiles_list(self):
    return self.available_tiles</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#about">About :</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coa" href="index.html">coa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coa.display.CocoDisplay" href="#coa.display.CocoDisplay">CocoDisplay</a></code></h4>
<ul class="">
<li><code><a title="coa.display.CocoDisplay.add_columns_for_pie_chart" href="#coa.display.CocoDisplay.add_columns_for_pie_chart">add_columns_for_pie_chart</a></code></li>
<li><code><a title="coa.display.CocoDisplay.bokeh_legend" href="#coa.display.CocoDisplay.bokeh_legend">bokeh_legend</a></code></li>
<li><code><a title="coa.display.CocoDisplay.changeto_nonan_date" href="#coa.display.CocoDisplay.changeto_nonan_date">changeto_nonan_date</a></code></li>
<li><code><a title="coa.display.CocoDisplay.changeto_nonull_date" href="#coa.display.CocoDisplay.changeto_nonull_date">changeto_nonull_date</a></code></li>
<li><code><a title="coa.display.CocoDisplay.convert_tile" href="#coa.display.CocoDisplay.convert_tile">convert_tile</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decohistomap" href="#coa.display.CocoDisplay.decohistomap">decohistomap</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decohistopie" href="#coa.display.CocoDisplay.decohistopie">decohistopie</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decomap" href="#coa.display.CocoDisplay.decomap">decomap</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decoplot" href="#coa.display.CocoDisplay.decoplot">decoplot</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decopycoageo" href="#coa.display.CocoDisplay.decopycoageo">decopycoageo</a></code></li>
<li><code><a title="coa.display.CocoDisplay.decowrapper" href="#coa.display.CocoDisplay.decowrapper">decowrapper</a></code></li>
<li><code><a title="coa.display.CocoDisplay.dict_shorten_loc" href="#coa.display.CocoDisplay.dict_shorten_loc">dict_shorten_loc</a></code></li>
<li><code><a title="coa.display.CocoDisplay.get_listfigures" href="#coa.display.CocoDisplay.get_listfigures">get_listfigures</a></code></li>
<li><code><a title="coa.display.CocoDisplay.get_polycoords" href="#coa.display.CocoDisplay.get_polycoords">get_polycoords</a></code></li>
<li><code><a title="coa.display.CocoDisplay.get_utcdate" href="#coa.display.CocoDisplay.get_utcdate">get_utcdate</a></code></li>
<li><code><a title="coa.display.CocoDisplay.min_max_range" href="#coa.display.CocoDisplay.min_max_range">min_max_range</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_date_plot" href="#coa.display.CocoDisplay.pycoa_date_plot">pycoa_date_plot</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_histo" href="#coa.display.CocoDisplay.pycoa_histo">pycoa_histo</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_horizonhisto" href="#coa.display.CocoDisplay.pycoa_horizonhisto">pycoa_horizonhisto</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_map" href="#coa.display.CocoDisplay.pycoa_map">pycoa_map</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_mapfolium" href="#coa.display.CocoDisplay.pycoa_mapfolium">pycoa_mapfolium</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_pie" href="#coa.display.CocoDisplay.pycoa_pie">pycoa_pie</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_pimpmap" href="#coa.display.CocoDisplay.pycoa_pimpmap">pycoa_pimpmap</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_plot" href="#coa.display.CocoDisplay.pycoa_plot">pycoa_plot</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_resume_data" href="#coa.display.CocoDisplay.pycoa_resume_data">pycoa_resume_data</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_scrollingmenu" href="#coa.display.CocoDisplay.pycoa_scrollingmenu">pycoa_scrollingmenu</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_spiral_plot" href="#coa.display.CocoDisplay.pycoa_spiral_plot">pycoa_spiral_plot</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoa_yearly_plot" href="#coa.display.CocoDisplay.pycoa_yearly_plot">pycoa_yearly_plot</a></code></li>
<li><code><a title="coa.display.CocoDisplay.pycoageo" href="#coa.display.CocoDisplay.pycoageo">pycoageo</a></code></li>
<li><code><a title="coa.display.CocoDisplay.rollerJS" href="#coa.display.CocoDisplay.rollerJS">rollerJS</a></code></li>
<li><code><a title="coa.display.CocoDisplay.save_map2png" href="#coa.display.CocoDisplay.save_map2png">save_map2png</a></code></li>
<li><code><a title="coa.display.CocoDisplay.save_pandas_as_png" href="#coa.display.CocoDisplay.save_pandas_as_png">save_pandas_as_png</a></code></li>
<li><code><a title="coa.display.CocoDisplay.set_listfigures" href="#coa.display.CocoDisplay.set_listfigures">set_listfigures</a></code></li>
<li><code><a title="coa.display.CocoDisplay.sparkline" href="#coa.display.CocoDisplay.sparkline">sparkline</a></code></li>
<li><code><a title="coa.display.CocoDisplay.spiral" href="#coa.display.CocoDisplay.spiral">spiral</a></code></li>
<li><code><a title="coa.display.CocoDisplay.standardfig" href="#coa.display.CocoDisplay.standardfig">standardfig</a></code></li>
<li><code><a title="coa.display.CocoDisplay.test_all_val_null" href="#coa.display.CocoDisplay.test_all_val_null">test_all_val_null</a></code></li>
<li><code><a title="coa.display.CocoDisplay.tiles_list" href="#coa.display.CocoDisplay.tiles_list">tiles_list</a></code></li>
<li><code><a title="coa.display.CocoDisplay.wgs84_to_web_mercator" href="#coa.display.CocoDisplay.wgs84_to_web_mercator">wgs84_to_web_mercator</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>